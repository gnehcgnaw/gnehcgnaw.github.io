<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="gnehcgnaw">
  <meta name="keywords" content="">
  <title>反射工具箱 ~ BeatShadow&#39;s blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>BeatShadow&#39;s blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019-12-09-qxxJGM.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期二, 十一月 26日 2019, 8:39 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    4.4k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      19 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="反射工具箱"><a href="#反射工具箱" class="headerlink" title="反射工具箱"></a>反射工具箱</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​        Mybatis在进行参数处理、结果集映射等操作时，会涉及大量的反射操作。Java中的反射虽然功能强大，但是代码编写起来比较复杂容易出错，为了简化反射操作的相关代码，Mybatis提供了专门的反射模块，该模块位于<code>org.apache.ibatis.reflection</code>包中，它对常见的反射操作做了封装，提供了更加简洁方便的反射API。</p>
<img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126092626-rve1an.png" srcset="undefined" style="zoom:67%;" />

<h1 id="2-Reflector-amp-ReflectorFactory"><a href="#2-Reflector-amp-ReflectorFactory" class="headerlink" title="2. Reflector&amp;ReflectorFactory"></a>2. Reflector&amp;ReflectorFactory</h1><h2 id="2-1-Reflector"><a href="#2-1-Reflector" class="headerlink" title="2.1. Reflector"></a>2.1. Reflector</h2><p>​         <code>Reflector</code>是<code>Mybatis</code>中反射模块的基础，每个<code>Reflector</code>对象都对应一个类，在Reflector中缓存了反射操作需要使用的类的元信息。Reflector中各个字段的含义如下所示：</p>
<pre><code class="java">/**
   * 对应类的类型
   */
  private final Class&lt;?&gt; type;
  /**
   * 可读属性的名称集合，可读属性就是存在相应的getter方法的属性，初始值为空数组
   */
  private final String[] readablePropertyNames;
  /**
   * 可写属性的名称集合，可写属性就是存在相应setter方法的属性，初始值为空数组
   */
  private final String[] writablePropertyNames;
  /**
   * 记录了属性相应的setter方法，key是属性名称，value是Invoke对象，它是对setter方法对应Method对象的封装，后面会详细介绍
   */
  private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;();
  /**
   * 记录了属性相应的getter方法集合，key是属性名称，value是Invoke对象，
   */
  private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;();
  /**
   * 记录了属性相应的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型
   */
  private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;();
  /**
   * 记录了属性相应的getter方法的返回值类型，key是属性名称，value是getter方法的返回值类型
   */
  private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;();
  /**
   * 记录了默认的构造方法
   */
  private Constructor&lt;?&gt; defaultConstructor;
  /**
   * 记录了所有属性名称的集合
   */
  private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;();</code></pre>
<p>​        在<code>Reflector</code>的构造方法中会解析指定的<code>Class</code>对象，并填充上述集合，具体实现如下所示：</p>
<pre><code class="java">/**
   * 此构造方法中会解析指定的Class对象，并填充上述集合
   * @param clazz 需要解析的Class对象
   */
  public Reflector(Class&lt;?&gt; clazz) {
    //初始化type字段
    type = clazz;
    //查找clazz的默认构造方法（无参构造方法），具体实现是通过反射遍历所有构造方法
    addDefaultConstructor(clazz);
    //处理clazz中的getter方法，填充getMethods集合和getTypes集合
    addGetMethods(clazz);
    //处理clazz中的setter方法，填充setMethods集合和setTypes集合
    addSetMethods(clazz);
    //处理没有getter/setter方法的字段
    addFields(clazz);
    //根据getMethods和setMethods集合，初始化可读、可写属性的名称集合
    readablePropertyNames = getMethods.keySet().toArray(new String[0]);
    writablePropertyNames = setMethods.keySet().toArray(new String[0]);
    //初始化caseInsensitivePropertyMap，其中记录了所有大写格式的属性名称
    for (String propName : readablePropertyNames) {
      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
    for (String propName : writablePropertyNames) {
      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
    }
  }
</code></pre>
<p>​        以上代码中<code>addDefaultConstructor(clazz);</code>很是简单，所以没有必要去分析这个方法，其次就是<code>addGetMethods(clazz);</code>和<code>addSetMethods(clazz);</code>方法，<code>Reflector.addGetMethods()</code>方法主要腹泻解析类中定义的<code>getter</code>方法，<code>Reflector.addSetMethods()</code>方法负责解析类中的<code>setter</code>方法，两者的逻辑类似，这里以<code>addSetMethods(clazz);</code>方法为例进行介绍，<code>addSetMethods()</code>方法不做详细介绍，<code>Reflector.addGetMethods()</code>主要有如下三个核心步骤：</p>
<pre><code class="java">/**
   * 负责解析类中的get方法
   * @param clazz
   */
  private void addGetMethods(Class&lt;?&gt; clazz) {
    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;&gt;();
    /**
     * 1. 调用{@link Reflector#getClassMethods(Class)} 方法获取当前类以及其父类中定义的所有方法的唯一签名以及相应的Method对象。
     */
    Method[] methods = getClassMethods(clazz);
    /**
     * 2. 按照JavaBean的规范，从Reflector#getClassMethods(Class)方法返回的Methods数组中查找该类中定义的getter方法，
     *    将其记录在conflictingGetters集合中，conflictingGetters集合（ Map&lt;String, List&lt;Method&gt;&gt;类型）的key为属性名称，value是该属性对应的getter方法集合。
     *
     *    2.1. 具体步骤
     *      2.1.1. 得到所有的get方法，（参数类别为空，标志是get的方法）；
     *      2.1.2. 将得到的get方法添加到方法冲突集合中；
     *          例如：父类 public List&lt;User&gt; getUserList(); 子类 public ArrayList&lt;User&gt; getUserList();
     *               在进行{@link Reflector#getClassMethods(Class)}中的{@link Reflector#getSignature(Method)}返回结果是：
     *               java.util.List#getUserList和java.util.ArrayList#getUserList，即得到两个方法签名，在{@link Reflector#addUniqueMethods(Map, Method[])}
     *               方法中会被认为是两个不同的方法添加到 uniqueMethods集合中，这显然不是我们想要的结果。
     *
     *  所以后续步骤3 会去解决这种Getter方法的冲突。
     *
     *  (lambda表达式 :filter forEach )
     */
    Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))
      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));
    /**
     * 3. 解决Getter冲突
     *   1. 为什么会产生冲突呢？
     *      步骤2已经解释过为什么会产生冲突了。
     *   2. 解决方式是什么？
     */
    resolveGetterConflicts(conflictingGetters);
  }</code></pre>
<ul>
<li><p>首先，调用<code>Reflector.getClassMethods()</code>方法获取当前类及其父类中定义的所以方法的唯一签名以及相应的<code>Methods</code>对象。</p>
<pre><code class="java">private Method[] getClassMethods(Class&lt;?&gt; clazz) {
    Map&lt;String, Method&gt; uniqueMethods = new HashMap&lt;&gt;();
    Class&lt;?&gt; currentClass = clazz;
    while (currentClass != null &amp;&amp; currentClass != Object.class) {
      //记录currentClass这个类中定义的全部方法
      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());

      // we also need to look for interface methods -
      // because the class may be abstract
      // 记录接口中定义的方法
      Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();
      for (Class&lt;?&gt; anInterface : interfaces) {
        addUniqueMethods(uniqueMethods, anInterface.getMethods());
      }
      //获取父类，继续while循环
      currentClass = currentClass.getSuperclass();
    }

    Collection&lt;Method&gt; methods = uniqueMethods.values();
    //转换成Methods方法数组返回
    return methods.toArray(new Method[0]);
  }</code></pre>
<p>在<code>Reflector.addUniqueMethods()</code>方法中会为每个方法生成唯一签名，并记录到<code>uniqueMethods</code>集合中，具体实现如下所示：</p>
<pre><code class="java"> /**
   * 为每个方法生成一个唯一签名，并记录到uniqueMethods集合中
   * @param uniqueMethods
   * @param methods
   */
  private void addUniqueMethods(Map&lt;String, Method&gt; uniqueMethods, Method[] methods) {
    for (Method currentMethod : methods) {
      if (!currentMethod.isBridge()) {
        /**
         * 通过{@link Reflector#getSignature(Method)}方法得到方法的签名是：返回值类型#方法名称：参数类型列表。
         * 例如： Reflector.getSignature(Method)的方法签名是：java.lang.String#getSignature:java.lang.reflect.Method
         * 通过Reflector.getSignature(Method)方法得到的方法签名是全局唯一的，可以作为该方法的唯一标识
         */
        String signature = getSignature(currentMethod);
        // check to see if the method is already known
        // if it is known, then an extended class must have
        // overridden a method
        /**
         * 检查是否添加过该方法，如果添加过，就无须在向uniqueMethods中添加该方法了。
         * 其实这个段代码，如果细品有另一种意思：
         *    因为addUniqueMethods方法在{@link Reflector#getClassMethods(Class)}中的while循环被调用了，一次循环被调用两次，
         *    这两次调用：先是子类调用，然后是父类接口调用，
         * 所以这里检查是否添加过该方法的另一层含义是：
         *    检测是否在子类中已经添加过该方法，如果在子类中添加过，则表示子类覆盖了该方法，无须再向uniqueMethods集合中添加该方法了。
         *
         */
        if (!uniqueMethods.containsKey(signature)) {
          //记录该签名和方法的对应关系
          uniqueMethods.put(signature, currentMethod);
        }
      }
    }
  }
</code></pre>
</li>
<li><p>然后，按照<code>JavaBean</code>的规范，从<code>Reflector.getClassMethods()</code>返回的Method数组中查找该类中定义的<code>getter</code>方法（具体哪些方法算是<code>getter</code>方法，后面会详细介绍），将其记录到<code>conflictingGetters</code>集合中。<code>conflictingGetters</code>集合（<code>Map&lt;String, List&lt;Method&gt;&gt;</code>类型）的<code>key</code>是属性名称，<code>value</code>是该属性对应的<code>getter</code>方法集合。</p>
<pre><code class="java">//Reflector.java
Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))
      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));</code></pre>
<pre><code class="java">//Reflector.java
/**
   * 添加方法冲突
   * @param conflictingMethods
   * @param name
   * @param method
   *
   */
  private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) {
    if (isValidPropertyName(name)) {
      /**
       * {@link Map#computeIfAbsent(Object, Function)}
       * @see red.reksai.reflection.ComputeIfAbsentTest   map jdk1.8新特性
       */
      List&lt;Method&gt; list = conflictingMethods.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;());
      list.add(method);
    }
  }</code></pre>
<pre><code class="java">//PropertyNamer.java
/**
   * 根据Javabean的规范，获取对应的属性名称
   * @param name
   * @return
   */
  public static String methodToProperty(String name) {
    if (name.startsWith(&quot;is&quot;)) {
      name = name.substring(2);
    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
      name = name.substring(3);
    } else {
      throw new ReflectionException(&quot;Error parsing property name &#39;&quot; + name + &quot;&#39;.  Didn&#39;t start with &#39;is&#39;, &#39;get&#39; or &#39;set&#39;.&quot;);
    }

    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {
      name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);
    }

    return name;
  }</code></pre>
</li>
<li><p>当子类覆盖了父类的getter方法且返回值发生变化时，在步骤1中就会产生两个签名不用的方法。</p>
<ul>
<li>例如：</li>
</ul>
<pre><code class="java">import org.apache.ibatis.reflection.Reflector;

import java.util.ArrayList;
import java.util.List;

/**
 * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt;
 * @since : 2019/11/26 10:19
 */
public class ReflectorTest {
  public static void main(String[] args) {
    Reflector reflector = new Reflector(User.class);
    System.out.println(reflector);
  }
}

class  User extends Person{

  public User() {
  }

  public User(String userName, String passWord) {
    this.userName = userName;
    this.passWord = passWord;
  }

  private String userName ;
  private String passWord ;

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

  public String getPassWord() {
    return passWord;
  }

  public void setPassWord(String passWord) {
    this.passWord = passWord;
  }

  public boolean isStatus() {
    return super.getStatus() ;
  }

  @Override
  public void setStatus(boolean status) {
    super.setStatus(status);
  }

  @Override
  public ArrayList&lt;Items&gt; getList() {
    return (ArrayList&lt;Items&gt;) super.getList();
  }

  @Override
  public void setList(List&lt;Items&gt; list) {
    super.setList(list);
  }
}

class Person {

  private List&lt;Items&gt; list;

  private boolean status ;

  public boolean getStatus() {
    return status;
  }

  public void setStatus(boolean status) {
    this.status = status;
  }

  public List&lt;Items&gt; getList() {
    return list;
  }

  public void setList(List&lt;Items&gt; list) {
    this.list = list;
  }

  public Person() {
  }

  public Person(List&lt;Items&gt; list) {
    this.list = list;
  }
}
class Items{
  private String itmeId;
  private String itmeName ;
}
</code></pre>
<ul>
<li>在以下位置打断点</li>
</ul>
<p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233022-6FOt8I.png" srcset="undefined" alt=""></p>
<ul>
<li>观察conflictingGetters集合中的值，如下所示：</li>
</ul>
<p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233326-2wTK6y.png" srcset="undefined" alt=""></p>
<p>其中属性名称为<code>list</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，这就是因为<code>User</code>在覆盖<code>Person</code>中的<code>getList()</code>方法是返回值从<code>List</code>变成了<code>ArrayList</code>，又因为生成方法签名的规则如下所示，所以就造成了有两个不同方法签名的方法被添加到了<code>uniqueMethods</code>集合中，这不是我们想要的结果。</p>
<pre><code class="java">// Reflector.java
/**
   * 生成方法签名
   * @param method
   * @return
   */
  private String getSignature(Method method) {
    StringBuilder sb = new StringBuilder();
    Class&lt;?&gt; returnType = method.getReturnType();
    if (returnType != null) {
      sb.append(returnType.getName()).append(&#39;#&#39;);
    }
    sb.append(method.getName());
    Class&lt;?&gt;[] parameters = method.getParameterTypes();
    for (int i = 0; i &lt; parameters.length; i++) {
      sb.append(i == 0 ? &#39;:&#39; : &#39;,&#39;).append(parameters[i].getName());
    }
    return sb.toString();
  }</code></pre>
<p>其中属性为<code>status</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，一个是父类中的<code>boolean getStatus()</code>，另一个是子类中的 <code>boolean isStatus()</code>（涉及到JavaBean规范），说白了此时<code>uniqueMethods</code>集合中也有两个，这也不是我们想要的结果。</p>
</li>
<li><p>所以步骤3会调用<code>Reflector.resolveGetterConflicts(conflictingGetters)</code>方法对步骤2中这种覆写的情况进行处理，同时会将处理得到的<code>getter</code>方法记录到<code>getMethods</code>集合中，并将其返回值类型填充到<code>getTypes</code>集合中，<code>Reflector.resolveGetterConflicts()</code>方法的具体实现如下所示：</p>
</li>
</ul>
<pre><code class="Java"> //Reflector.java
 /**
   * 解决get方法的冲突，同时会将处理得到的getter方法记录到getMethods集合中，并将其返回值类型填充到getTypes集合中
   * @param conflictingGetters
   */
  private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) {
    //遍历conflictingGetters集合
    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) {
      //优胜Method对象
      Method winner = null;
      //方法名称
      String propName = entry.getKey();
      boolean isAmbiguous = false;
      // candidate 候选Method对象
      for (Method candidate : entry.getValue()) {
        //如果优胜对象为空，这时候将候选对象复制给优胜对象
        if (winner == null) {
          winner = candidate;
          // continue是跳过当次循环中剩下的语句，执行下一次循环
          continue;
        }
        //获取优胜者返回值类型
        Class&lt;?&gt; winnerType = winner.getReturnType();
        //获取候选者返回值类型
        Class&lt;?&gt; candidateType = candidate.getReturnType();
        /**
         * 如果返回值类型相同，就要判断返回值是不是boolean？为什么要判断是不是boolean呢？
         */
        if (candidateType.equals(winnerType)) {
          //如果返回值不是boolean直接
          if (!boolean.class.equals(candidateType)) {
            isAmbiguous = true;
            //break只能跳出1层循环
            break;
          } else if (candidate.getName().startsWith(&quot;is&quot;)) {
            winner = candidate;
          }
        }
        /**
         * @see red.reksai.javabase.IsAssignableFromTest
         * 判断返回值类型有三种情况：
         *  1. 候选者是优胜者的父类，不做任何操作，最终返回子类就行
         *  2. 优胜者是候选者的父类，这时候先要将候选者赋值给优胜者，然后返回
         *  3. 返回值相同，二义性，
         */
        else if (candidateType.isAssignableFrom(winnerType)) {
          // OK getter type is descendant
        } else if (winnerType.isAssignableFrom(candidateType)) {
          winner = candidate;
        } else {
          isAmbiguous = true;
          break;
        }
      }
      //该字段只有一个getter方法，直接添加到getMethods集合并填充getTypes集合
      addGetMethod(propName, winner, isAmbiguous);
    }
  }</code></pre>
<p>正如上面描述的那样，在<code>Reflector.addGetMethod(propName, winner, isAmbiguous);</code>方法中完成了对<code>getMethods</code>集合和<code>getType</code>集合的填充，具体实现如下所示：</p>
<pre><code class="java">  private void addGetMethod(String name, Method method, boolean isAmbiguous) {
    /**
     * 验证：
     *    1. 如果有含糊不清的直接报错，
     *    2. 如果验证通过，则进行方法的封装
     */
    MethodInvoker invoker = isAmbiguous
        ? new AmbiguousMethodInvoker(method, MessageFormat.format(
            &quot;Illegal overloaded getter method with ambiguous type for property &#39;&#39;{0}&#39;&#39; in class &#39;&#39;{1}&#39;&#39;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;,
            name, method.getDeclaringClass().getName()))
        : new MethodInvoker(method);

    getMethods.put(name, invoker);
    /**
     * 获取返回值的Type ，{@link TypeParameterResolver}
     */
    Type returnType = TypeParameterResolver.resolveReturnType(method, type);
    getTypes.put(name, typeToClass(returnType));
  }</code></pre>
<h2 id="2-2-TypeParameterResolver"><a href="#2-2-TypeParameterResolver" class="headerlink" title="2.2. TypeParameterResolver"></a>2.2. TypeParameterResolver</h2><h2 id="2-3-ObjectFactory"><a href="#2-3-ObjectFactory" class="headerlink" title="2.3. ObjectFactory"></a>2.3. ObjectFactory</h2><h2 id="2-4-Property工具集"><a href="#2-4-Property工具集" class="headerlink" title="2.4. Property工具集"></a>2.4. Property工具集</h2><p>本小节主要介绍反射模块中使用到的三个属性工具类，分别是<code>PropertyTokenizer</code>、<code>PropertyNamer</code>和<code>PropertyCopier</code>。</p>
<hr>
<p><strong>此段我暂时也不知道怎么去解释，也许是后续学习能解释这个问题吧。</strong></p>
<p>在使用<code>Mybatis</code>的过程中，我们会经常碰到一些属性表达式，例如，在查询某用户（<code>User</code>）的订单（<code>Order</code>）的结果集如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">user_name</th>
<th align="center">order</th>
<th align="center">item1</th>
<th align="center">item2</th>
<th align="center">. . .</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Mary</td>
<td align="center">12460</td>
<td align="center">IPhone</td>
<td align="center">Computer</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Lisa</td>
<td align="center">36546</td>
<td align="center">MX</td>
<td align="center">Wather</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">. . .</td>
<td align="center">. . .</td>
<td align="center">. . .</td>
<td align="center">. . .</td>
<td align="center">. . .</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-1-PropertyTokenizer"><a href="#2-4-1-PropertyTokenizer" class="headerlink" title="2.4.1. PropertyTokenizer"></a>2.4.1. PropertyTokenizer</h3><p><code>PropertyTokenizer</code>是一个属性分词器工具，它继承了<code>Iterator</code>接口，它可以迭代处理嵌套的多层表达式。</p>
<p>由“<code>*</code>”和“<code>[]</code>”组成的表达式是由<code>PropertyTokenizer</code>进行解析的，<code>PropertyTokenizer</code>中各个字段的含义如下所示：</p>
<pre><code class="java">// fullName = &quot;order[0].items[0].name&quot;
  // String[] split = {&quot;order[0]&quot; ,&quot;item[0]&quot; ,&quot;name&quot;}
  /**
   * 当前表达式的名称:
   * e.g. order
   *      items
   *      name
   */
  private String name;
  /**
   * 当前表达式的索引名
   * e.g. order[0]
   *      items[0]
   *      name
   */
  private final String indexedName;
  /**
   * 索引下标
   * e.g. [0]
   *      [0]
   *      null
   */
  private String index;
  /**
   * 子表达式
   * e.g. items[0].name
   *      name
   *      null
   */
  private final String children;
</code></pre>
<p>核心方法有三个分别是：</p>
<ul>
<li><code>PropertyTokenizer()</code></li>
</ul>
<pre><code class="java">/**
   * 解析表达式
   * @param fullname  要解析的表达式
   *                  e.g. order[0].items[0].name
   */
  public PropertyTokenizer(String fullname) {
    //查找&quot;.&quot;的位置
    int delim = fullname.indexOf(&#39;.&#39;);
    if (delim &gt; -1) {
      //初始化name
      name = fullname.substring(0, delim);
      //初始化children
      children = fullname.substring(delim + 1);
    } else {
      name = fullname;
      children = null;
    }
    //初始化indexName
    indexedName = name;
    //查找&quot;[&quot;的位置，如果存在，最后要把上面步骤赋值给name中的&quot;[]&quot;去掉
    delim = name.indexOf(&#39;[&#39;);
    if (delim &gt; -1) {
      //初始化index
      index = name.substring(delim + 1, name.length() - 1);
      //重新赋值给name
      name = name.substring(0, delim);
    }
  }</code></pre>
<ul>
<li><code>hasNext()</code></li>
</ul>
<pre><code class="java">  /**
   * 判断是否还有children
   * @return
   */
  @Override
  public boolean hasNext() {
    return children != null;
  }
</code></pre>
<ul>
<li><code>next()</code></li>
</ul>
<pre><code class="java">  /**
   * 继续解析孩子节点
   * @return
   */
  @Override
  public PropertyTokenizer next() {
    return new PropertyTokenizer(children);
  }</code></pre>
<p>例子：</p>
<pre><code class="java">import org.apache.ibatis.reflection.property.PropertyTokenizer;

/**
 * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt;
 * @since : 2019/11/29 11:12
 */
public class PropertyTokenizerTest {
  public static void main(String[] args) {
    String fullName = &quot;orders[0.items[0].name&quot; ;
    doTokenizer(fullName);
  }

  private static void doTokenizer(String name){
    PropertyTokenizer propertyTokenizer = new PropertyTokenizer(name);
    System.out.println(propertyTokenizer.getIndexedName());
    System.out.println(propertyTokenizer.getName());
    System.out.println(propertyTokenizer.getIndex());
    System.out.println(propertyTokenizer.getChildren());
    System.out.println(&quot;.................&quot;);
    String children = propertyTokenizer.getChildren();
    if (propertyTokenizer.hasNext()){
      doTokenizer(children);
    }
  }
}</code></pre>
<p>运行结果：</p>
<pre><code>orders[0
orders

items[0].name
.................
items[0]
items
0
name
.................
name
name
null
null
.................</code></pre><h3 id="2-4-2-PropertyNamer"><a href="#2-4-2-PropertyNamer" class="headerlink" title="2.4.2. PropertyNamer"></a>2.4.2. PropertyNamer</h3><h3 id="2-4-3-PropertyCopier"><a href="#2-4-3-PropertyCopier" class="headerlink" title="2.4.3. PropertyCopier"></a>2.4.3. PropertyCopier</h3><h2 id="2-5-MetaClass"><a href="#2-5-MetaClass" class="headerlink" title="2.5. MetaClass"></a>2.5. MetaClass</h2><h3 id="2-5-1-主要方法详解"><a href="#2-5-1-主要方法详解" class="headerlink" title="2.5.1. 主要方法详解"></a>2.5.1. 主要方法详解</h3><p><code>MetaClass</code>通过<code>Reflector</code>和<code>PropertyTokenizer</code>组合使用，实现了对复杂的属性表达式的解析，并实现了获取指定属性描述信息的功能。<code>MetaClass</code>中各个字段的含义如下：</p>
<pre><code class="java">  /**
   * ReflectorFactory对象，用于缓存Reflector对象
   */
  private final ReflectorFactory reflectorFactory;
  /**
   *   在创建MetaClass时会指定一个类，该Reflector对象会用于记录该类相关信息
   */
  private final Reflector reflector;</code></pre>
<p><code>MetaClass</code>的构造函数中会为指定的<code>Class</code>创建相应的<code>Reflector</code>对象，并用其初始化<code>MetaClass.reflector</code>字段，具体代码如下所示：</p>
<pre><code class="java">  /**
   * 此构造方法是一个private
   * @param type
   * @param reflectorFactory  
   */
  private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {
    this.reflectorFactory = reflectorFactory;
    //创建reflector对象，默认使用的是DefaultReflectorFactory.findForClass()方法
    this.reflector = reflectorFactory.findForClass(type);
  }

  /**
   * 使用静态方法创建MetaClass对象
   * @param type
   * @param reflectorFactory
   * @return
   */
  public static MetaClass forClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {
    return new MetaClass(type, reflectorFactory);
  }</code></pre>
<p><code>MetaClass</code>中比较重要的是<code>findProperty()</code>方法，它是通过调用<code>MetaClass.buildProperty()</code>方法实现的：</p>
<pre><code class="Java">//MetaClass.java  
  /**
   * 只查找&quot;.&quot;导航的属性，并且没有检测下标
   * @param name 要查找的属性名称
   * @return
   */
  public String findProperty(String name) {
    //委托给buildProperty()方法实现
    StringBuilder prop = buildProperty(name, new StringBuilder());
    return prop.length() &gt; 0 ? prop.toString() : null;
  }</code></pre>
<pre><code class="java"> private StringBuilder buildProperty(String name, StringBuilder builder) {
    //解析表达式
    PropertyTokenizer prop = new PropertyTokenizer(name);
    //判断是否还有子表达式
    if (prop.hasNext()) {
      String propertyName = reflector.findPropertyName(prop.getName());
      if (propertyName != null) {
        builder.append(propertyName);
        builder.append(&quot;.&quot;);
        //查找属性所对应的MetaClass
        MetaClass metaProp = metaClassForProperty(propertyName);
        metaProp.buildProperty(prop.getChildren(), builder);
      }
    } else {
      String propertyName = reflector.findPropertyName(name);
      if (propertyName != null) {
        builder.append(propertyName);
      }
    }
    return builder;
  }</code></pre>
<p>有上述代码可以看出：findPropertory()方法值查找“.”导航的属性，并没有检测下标。</p>
<p>这里以解析User类中的tele.contry这个属性表达式为例解释上述过程：</p>
<ol>
<li><p>首先使用findPropertory(“tele.contry”)；</p>
</li>
<li><p>MetaClass.buildPropertry(“tele.country”,stringBuilder)；</p>
</li>
<li><p>接着使用PropertryTokenizer解析数据，发现还有子表达式：country，说明此属性表达式所属的类不是当前了，需要查找此属性属于的类；</p>
</li>
<li><p>所以要通过MetaClass.metaClassForPropertry(“tele”)，获取到对应的实体类，其中使用到了Reflector.getGetterType()得到了返回值的类型，然后使用MetaClass.forClass()返回返回值对应的元类。</p>
</li>
<li><p>递归调用2。</p>
</li>
</ol>
<p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129152716-h9Os7u.png" srcset="undefined" alt=""></p>
<p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153239-L5s0UA.png" srcset="undefined" alt=""></p>
<p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153351-r3eIeh.png" srcset="undefined" alt=""></p>
<p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153624-PBw7Sr.png" srcset="undefined" alt=""></p>
<p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153949-KaKXgI.png" srcset="undefined" alt=""></p>
<h3 id="2-5-2-测试用例"><a href="#2-5-2-测试用例" class="headerlink" title="2.5.2. 测试用例"></a>2.5.2. 测试用例</h3><pre><code class="java">package red.reksai.reflection;

import org.apache.ibatis.reflection.DefaultReflectorFactory;
import org.apache.ibatis.reflection.MetaClass;
import org.junit.jupiter.api.Test;
import red.reksai.reflection.entity.User;
/**
 * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt;
 * @since : 2019/11/29 10:07
 */

public class MetaClassTest {

  @Test
  public  void test() {
    MetaClass metaClass = MetaClass.forClass(User.class, new DefaultReflectorFactory());
    System.out.println(metaClass.findProperty(&quot;tele.country&quot;));     //tele.country
    System.out.println(metaClass.getGetterType(&quot;tele.country&quot;));    // class java.lang.String
    System.out.println(metaClass.hasGetter(&quot;tete.country&quot;));    //true
    System.out.println(metaClass.getGetterType(&quot;orders[0].items[0]&quot;));    // class red.reksai.reflection.entity.Item
  }
}
</code></pre>
<h2 id="2-6-ObjectWrapper"><a href="#2-6-ObjectWrapper" class="headerlink" title="2.6. ObjectWrapper"></a>2.6. ObjectWrapper</h2><h2 id="2-7-MetaObject"><a href="#2-7-MetaObject" class="headerlink" title="2.7. MetaObject"></a>2.7. MetaObject</h2>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Mybatis源码分析</a>
                  &nbsp;
                
                  <a class="hover-with-bg" href="/categories/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82">基础支持层</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Mybatis源码分析</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <b>Contact me at :</b>
    <a href="https://github.com/gnehcgnaw" target="_blank" rel="nofollow noopener"><i class="fab fa-github"></i></a>
    <a href="mailto:gnehcgnaw@gmail.com" target="_blank" rel="nofollow noopener"><i class="fas fa-envelope-square"></i></a>
    <br>
    <b>© Blog 2018 powered by Hexo, made by <a href="https://github.com/gnehcgnaw" target="_blank" rel="nofollow noopener">gnehcgnaw</a>.</b>
    <br>
    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "反射工具箱&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
