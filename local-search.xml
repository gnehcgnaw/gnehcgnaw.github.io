<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mybatis初始化</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis初始化"><a href="#Mybatis初始化" class="headerlink" title="Mybatis初始化"></a>Mybatis初始化</h1><p>类似于<code>Spring</code>，<code>Mybatis</code>等灵活性和扩展性都很高的开源框架都提供了很多配置项，开发人员需要在使用时提供相应的配置信息，实现相应的需求。<code>Mybatis</code>中的配置文件主要有两个，分别是<code>mybatis-config.xml</code>配置文件和映射配置文件。</p><p>现在主流的配置方式除了使用XML配置文件，还会配合注解进行配置。在<code>Mybatis</code>初始化过程中，除了会读取<code>mybatis-config.xml</code>配置文件以及映射配置文件，还会加载配置文件指定的类，处理类中的注解，创建一些配置对象，最终完成框架中各个模块的初始化。另外，也可以使用<code>Java API</code>方式对<code>Mybatis</code>进行配置，这种硬编码的配置方式主要用在配置量比较少且配置信息不常变化的场景下。</p><h1 id="1-建造者模式"><a href="#1-建造者模式" class="headerlink" title="1. 建造者模式"></a>1. 建造者模式</h1><h1 id="2-BaseBuidler"><a href="#2-BaseBuidler" class="headerlink" title="2. BaseBuidler"></a>2. BaseBuidler</h1><p><code>BaseBuilder</code>的子类如下所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128141904-lVPgr8.png" srcset="undefined" style="zoom:50%;" /><p>因为<code>VelocitySqlSourceBuilder</code>只是一个测试用例，所以我暂且不把它划为<code>BaseBuilder</code>，包括其静态内部类</p><p><code>ParameterMappingTokenHandler</code>，这样<code>BaseBuilder</code>的子类结构图就如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128142203-inbhpO.png" srcset="undefined" alt=""></p><p>正如签名所示，<code>Mybatis</code>的初始化过程使用了建造者模式，这里的<code>BaseBuilder</code>抽象类就扮演了建造者接口的角色。<code>BaseBuilder</code>中的核心字段的含义如下：</p><ul><li><code>Configuration</code></li><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#3-TypeHandlerRegistry" target="_blank" rel="noopener">TypeHandlerRegistry</a></li><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a></li></ul><pre><code class="java"> /**  * Configuration对象是Mybatis初始化过程中的核心对象，Mybatis中几乎所有配置信息都会保存到Configuration对象中。  *    * Configuration对象是Mybatis初始化过程中创建的且是全局唯一的。   * 也有人称它是一个“All in One” 对象   */  protected final Configuration configuration;  /**   * 在mybatis-config.xml配置文件中可以使用&lt;typeAliases&gt;&lt;/typeAliases&gt;标签定义别名，这些定义的别名都会记录在TypeAliasesRegistry对象中   */  protected final TypeAliasRegistry typeAliasRegistry;  /**   * 在mybatis-config.xml配置文件中可以使用&lt;typeHandler&gt;&lt;/typeHandler&gt;标签定义添加的自定义的TypeHandler，   * 完成指定数据库类型与Java类型的转换，这些TypeHandler都会记录在TypeHandlerRegistry中   */  protected final TypeHandlerRegistry typeHandlerRegistry;</code></pre><p><code>BaseBuilder</code>中记录的<code>TypeAliasRegistry</code>对象和<code>TypeHandlerRegistry</code>对象，其实是全局唯一的，它们都是在<code>Configuration</code>对象初始化时创建的，代码如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128145108-dgZGGY.png" srcset="undefined" alt=""></p><p>在<code>BaseBuilder</code>构造函数中，通过相应的<code>Configuration.get*()</code>方法得到<code>TypeAliasRegistry</code>和<code>TypeHandlerRegistry</code>对象，并赋值给<code>BaseBuilder</code>相应的字段。</p><pre><code class="java">  /**   * 构造方法   * @param configuration   */  public BaseBuilder(Configuration configuration) {    this.configuration = configuration;    this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();    this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();  }</code></pre><p><code>Configuration</code>中还包含了很多配置项，为了便于读者理解，这里不会罗杰出内个字段的含义，而是在后面介绍的过程中，每涉及到一个配置项时，会结合其在<code>Configuration</code>中相应字段进行详细分析。</p><p><code>BaseBuilder.resolveAlias()</code>方法依赖<code>TypeAliasRegistry</code>解析别名，<code>BaseBuilder.resolveTypeHandler()</code>方法依赖<code>TypeHandlerRegistry</code>查找指定的<code>TypeHandler</code>对象。在阅读完<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a>和<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#3-TypeHandlerRegistry" target="_blank" rel="noopener">TypeHandlerRegistry</a>的相关实现的介绍后，<code>BaseBuilder.resolveAlias()</code>和<code>BaseBuilder.resolveTypeHandler()</code>就不难理解了。</p><p>前面提到过，<code>Mybatis</code>使用<code>JdbcType</code>枚举类型表示<code>JDBC</code>类型。<code>Mybatis</code>中常用的枚举类型还有<code>ResultSetType</code>和<code>ParameterMode</code>：</p><ul><li><code>ResultSetType</code>枚举表示结果集类型；</li><li><code>ParameterMode</code>枚举类型表示存储过程中的参数类型。</li></ul><p>在<code>BaseBuilder</code>中提供了相应的<code>resolveJdbcType()</code>、<code>resolveResultSetType()</code>、<code>resolveParameterMode()</code>方法，将<code>String</code>转换成对应的枚举类型，实现比较简单。</p><h1 id="3-XMLConfigBuilder"><a href="#3-XMLConfigBuilder" class="headerlink" title="3. XMLConfigBuilder"></a>3. XMLConfigBuilder</h1><p><code>XMLConfigBuilder</code>是<code>BaseBuilder</code>的众多子类之一，它扮演的是具体建造者的角色。<code>XMLConfigBuilder</code>主要负责解析<code>mybatis-config.xml</code>配置文件，其核心字段如下：</p><ul><li>XPathParser</li><li>ReflectorFactory</li></ul><pre><code class="java">/**   *   标识是否被解析过mybatis-config.xml   */  private boolean parsed;  /**   * 用于解析mybatis-config.xml配置文件的XPathParse对象，   */  private final XPathParser parser;  /**   * 标识&lt;environment&gt;&lt;environment/&gt;配置的名称，默认读取&lt;environment&gt;&lt;environment/&gt;标签的default属性   */  private String environment;  /**   * ReflectorFactory负责创建和缓存Reflector对象   */  private final ReflectorFactory localReflectorFactory = new DefaultReflectorFactory();</code></pre><p><code>XMLConfigBuilder.parse()</code>方法是解析<code>mybatis-config.xml</code>配置文件的入口，它通过调用<code>XMLConfigBuilder.parseConfiguration()</code>方法实现整个解析过程，具体实现如下所示：</p><pre><code class="java">//XMLConfigBuilder.java/**   * 解析配置：   *    这里其实有一个细节，就是{@link #parsed} 字段，这是一个boolbean类型的，也就是默认值是false，   *    根据以下代码，发现只有当parsed = false才回去解析配置，为true的时候不会去解析，直接抛出异常，   *    这么做的原因是：因为在解析mybatis中配置文件的时候是一件很消耗性能的事情，所以只解析一次。   * @return configuration配置 （e.g. &lt;configuration&gt; ....&lt;configuration/&gt;）   */  public Configuration parse() {    if (parsed) {      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);    }    parsed = true;    //在mybatis-config.xml配置文件中查找&lt;configuration&gt;&lt;/configuration&gt;节点，并开始解析    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));    return configuration;  }</code></pre><pre><code class="java">//XMLConfigBuilder.java/**   * 解析Configuration标签中的配置   * @param root   */  private void parseConfiguration(XNode root) {    try {      //issue #117 read properties first      //解析&lt;properties&gt;节点      propertiesElement(root.evalNode(&quot;properties&quot;));      // 解析&lt;settings&gt;节点      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));      //设置vfsImpl字段      loadCustomVfs(settings);      //设置logImpl字段      loadCustomLogImpl(settings);      // 解析&lt;typeAliases&gt;节点      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));      // 解析&lt;plugins&gt;节点      pluginElement(root.evalNode(&quot;plugins&quot;));      // 解析&lt;objectFactory&gt;节点      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));      // 解析&lt;objectWrapperFactory&gt;节点      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));      // 解析&lt;reflectorFactory&gt;节点      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));      //将settings值设置到Configuration中      settingsElement(settings);      // read it after objectFactory and objectWrapperFactory issue #631      // 解析&lt;environments&gt;节点      environmentsElement(root.evalNode(&quot;environments&quot;));      // 解析&lt;databaseIdProvider&gt;节点      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));      // 解析&lt;typeHandlers&gt;节点      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));      // 解析&lt;mappers&gt;节点      mapperElement(root.evalNode(&quot;mappers&quot;));    } catch (Exception e) {      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);    }  }</code></pre><p><code>parseConfiguration()</code>方法的代码还是比较整洁的，我们可以清楚地看到，<code>XMLConfigBuilder</code>将<code>mybatis-config.xml</code>配置文件中每一个节点的解析过程封装成一个相应的方法，本小节的后续内容将逐一分析这些节点的解析过程。</p><h2 id="3-1-解析-lt-properties-gt-节点"><a href="#3-1-解析-lt-properties-gt-节点" class="headerlink" title="3.1. 解析&lt;properties&gt;节点"></a>3.1. 解析<code>&lt;properties&gt;</code>节点</h2><p><code>XMLConfigBuilder.propertiesElement()</code>方法会解析<code>mybatis-config.xml</code>配置文件中的<code>&lt;properties&gt;</code>节点，并信形成<code>java.uitl.Properties</code>对象，之后将该<code>Properties</code>对象设置到<code>XPathParser</code>和<code>Configuration</code>的<code>variable</code>字段中。在后面的解析过程中，会使用该<code>Properties</code>对象中的信息替换占位符。<code>propertiesElement()</code>方法的具体实现如下所示：</p><pre><code class="java">/**   * `XMLConfigBuilder.propertiesElement()`方法会解析`mybatis-config.xml`配置文件中的`&lt;properties&gt;`节点，   * 并信形成`java.uitl.Properties`对象，之后将该`Properties`对象设置到`XPathParser`和`Configuration`的`variable`字段中。   * 在后面的解析过程中，会使用该`Properties`对象中的信息替换占位符。   * @param context  e.g. &lt;properties resource=&quot;resources/config.properties&quot;&gt;   *                         &lt;property name=&quot;username&quot; value=&quot;xxx&quot;/&gt;   *                         &lt;property name=&quot;password&quot; value=&quot;xxx&quot;/&gt;   *                      &lt;/properties&gt;   * @throws Exception   */  private void propertiesElement(XNode context) throws Exception {    if (context != null) {      // username = xxx 和password = xxx 两个      Properties defaults = context.getChildrenAsProperties();      String resource = context.getStringAttribute(&quot;resource&quot;);      String url = context.getStringAttribute(&quot;url&quot;);      //properties元素不能同时指定URL和基于资源的属性文件引用。请指定其中一个。      if (resource != null &amp;&amp; url != null) {        throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);      }      //这个其实就是使用外部化配置覆盖内部值      if (resource != null) {        defaults.putAll(Resources.getResourceAsProperties(resource));      } else if (url != null) {        defaults.putAll(Resources.getUrlAsProperties(url));      }      Properties vars = configuration.getVariables();      if (vars != null) {        defaults.putAll(vars);      }      //更新XPathParser和Configuration的variable字段      parser.setVariables(defaults);      configuration.setVariables(defaults);    }  }</code></pre><h2 id="3-2-解析-lt-settings-gt-节点"><a href="#3-2-解析-lt-settings-gt-节点" class="headerlink" title="3.2. 解析&lt;settings&gt;节点"></a>3.2. 解析<code>&lt;settings&gt;</code>节点</h2><p><code>XMLConfigBuilder.settingsAsProperties()</code>方法负责解析<code>&lt;settings&gt;</code>节点，在<code>&lt;settings&gt;</code>节点下的配置是<strong>Mybatis全局性的配置</strong>，它们会改变<code>Mybatis</code>的运行时行为，具体的配置项的含义请阅读参考<a href="https://mybatis.org/mybatis-3/configuration.html#settings" target="_blank" rel="noopener">Mybatis官方文档</a>。需要注意的是，在<code>Mybatis</code>初始化时，这些全局配置信息都会被记录到<code>Configuration</code>对象的对应属性中。例如，开发人员可以通过设置————————。</p><p>在<code>Configuration</code>中存在一个同名的相应字段，如下：</p><p><code>settingsAsProperties()</code>方法的解析方式和<code>propertiesElement()</code>方法类似，但是多了使用<code>MetaClass</code>检测<code>key</code>指定的属性在<code>Configuration</code>类中是否有对应<code>setter</code>方法的步骤。<code>settingsAsProperties()</code>方法的代码如下所示：</p><pre><code class="java">  private Properties settingsAsProperties(XNode context) {    if (context == null) {      return new Properties();    }    Properties props = context.getChildrenAsProperties();    // Check that all settings are known to the configuration class    MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);    //使用`MetaClass`检测`key`指定的属性在`Configuration`类中是否有对应`setter`方法的步骤    for (Object key : props.keySet()) {      if (!metaConfig.hasSetter(String.valueOf(key))) {        throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);      }    }    return props;  }</code></pre><h2 id="3-3-设置vfsImpl和logImpl"><a href="#3-3-设置vfsImpl和logImpl" class="headerlink" title="3.3. 设置vfsImpl和logImpl"></a>3.3. 设置<code>vfsImpl</code>和<code>logImpl</code></h2><p>这两个参数一般不会去处理，所以我只罗列出来，不去解析：</p><h3 id="3-3-1-设置vfsImpl"><a href="#3-3-1-设置vfsImpl" class="headerlink" title="3.3.1. 设置vfsImpl"></a>3.3.1. 设置vfsImpl</h3><p>参看VFS详解</p><pre><code class="java">  private void loadCustomVfs(Properties props) throws ClassNotFoundException {    String value = props.getProperty(&quot;vfsImpl&quot;);    if (value != null) {      String[] clazzes = value.split(&quot;,&quot;);      for (String clazz : clazzes) {        if (!clazz.isEmpty()) {          @SuppressWarnings(&quot;unchecked&quot;)          Class&lt;? extends VFS&gt; vfsImpl = (Class&lt;? extends VFS&gt;)Resources.classForName(clazz);          configuration.setVfsImpl(vfsImpl);        }      }    }  }</code></pre><h3 id="3-3-2-设置logImpl"><a href="#3-3-2-设置logImpl" class="headerlink" title="3.3.2. 设置logImpl"></a>3.3.2. 设置logImpl</h3><pre><code class="java">  private void loadCustomLogImpl(Properties props) {    Class&lt;? extends Log&gt; logImpl = resolveClass(props.getProperty(&quot;logImpl&quot;));    configuration.setLogImpl(logImpl);  }</code></pre><h2 id="3-4-解析-lt-typeAliases-gt-节点"><a href="#3-4-解析-lt-typeAliases-gt-节点" class="headerlink" title="3.4. 解析&lt;typeAliases&gt;节点"></a>3.4. 解析<code>&lt;typeAliases&gt;</code>节点</h2><p><code>XMLConfigBuilder.typeAliasesElement()</code>负责解析<code>&lt;typeAliases&gt;</code>节点及其子节点，然后利用<a href="https://gnehcgnaw.github.io/Mybatis源码分析/基础支持层/类型转换.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a>完成别名的注册，具体实现如下所示：</p><pre><code class="java">private void typeAliasesElement(XNode parent) {    if (parent != null) {      for (XNode child : parent.getChildren()) {        /**         * 指定报名，MyBatis 会在包名下面搜索需要的 Java Bean         * 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。         * 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值 。         */        if (&quot;package&quot;.equals(child.getName())) {          String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);        } else {          String alias = child.getStringAttribute(&quot;alias&quot;);          String type = child.getStringAttribute(&quot;type&quot;);          try {            Class&lt;?&gt; clazz = Resources.classForName(type);            if (alias == null) {              typeAliasRegistry.registerAlias(clazz);            } else {              typeAliasRegistry.registerAlias(alias, clazz);            }          } catch (ClassNotFoundException e) {            throw new BuilderException(&quot;Error registering typeAlias for &#39;&quot; + alias + &quot;&#39;. Cause: &quot; + e, e);          }        }      }    }  }</code></pre><h2 id="3-5-解析-lt-plugins-gt-节点"><a href="#3-5-解析-lt-plugins-gt-节点" class="headerlink" title="3.5. 解析&lt;plugins&gt;节点"></a>3.5. 解析<code>&lt;plugins&gt;</code>节点</h2><p>插件是<code>Mybatis</code>提供的扩展机制之一，用户可以通过添加自定义插件在<code>SQL</code>语句执行过程中的某一点进行拦截。<code>Mybatis</code>中的自定义插件只需要实现<code>Interceptor</code>接口，并通过注解指定想要拦截的方法签名即可。在高级主题模块，将详细介绍插件的使用和原理，这里先来分析<code>Mybatis</code>中如何加载和管理插件。</p><p><code>XMLConfigBuilder.pluginElement()</code>方法负责解析<code>&lt;plugins&gt;</code>节点中定义的插件，并完成实例化和配置操作，具体实现如下所示：</p><pre><code class="java"> private void pluginElement(XNode parent) throws Exception {    if (parent != null) {      //遍历全部的子节点，即遍历&lt;plugins&gt;      for (XNode child : parent.getChildren()) {        //获取&lt;plugin&gt;节点的interceptor属性的值        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);        //获取&lt;plugin&gt;下&lt;properties&gt;配置的信息，并形成Properties对象        Properties properties = child.getChildrenAsProperties();        //通过别名获取对应的Clazz，然后通过反射实例化Interceptor对象        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();        //为当前interceptor设置属性值        interceptorInstance.setProperties(properties);        //记录Interceptor对象        configuration.addInterceptor(interceptorInstance);      }    }  }</code></pre><h2 id="3-6-解析-lt-objectFactory-gt-、-lt-objectWrapperFactory-gt-、-lt-reflectorFactory-gt-节点"><a href="#3-6-解析-lt-objectFactory-gt-、-lt-objectWrapperFactory-gt-、-lt-reflectorFactory-gt-节点" class="headerlink" title="3.6. 解析&lt;objectFactory&gt;、&lt;objectWrapperFactory&gt;、&lt;reflectorFactory&gt;节点"></a>3.6. 解析<code>&lt;objectFactory&gt;</code>、<code>&lt;objectWrapperFactory&gt;</code>、<code>&lt;reflectorFactory&gt;</code>节点</h2><p>我们可以通过自定义添加ObjectFactory、ObjectWarpperFactroy、ReflectorFactory的实现类来扩展<code>Mybatis</code>。</p><p><code>XMLConfigBuilder.objectFactoryElement()</code>方法负责解析并实例化<code>&lt;objectFactory&gt;</code>节点指定的<code>ObjectFactory</code>的实现类，之后将自定义的<code>ObjectFactory</code>对象记录在<code>Configuration.objectFactory</code>字段中，具体实现如下所示：</p><pre><code class="java">  private void objectFactoryElement(XNode context) throws Exception {    if (context != null) {      //获取&lt;objectFactory&gt;中的type属性      String type = context.getStringAttribute(&quot;type&quot;);      //获取&lt;objectFactory&gt;节点下的配置信息，并形成Properties对象      Properties properties = context.getChildrenAsProperties();      //通过别名获取对应的clazz，然后实例化ObjectFactory      ObjectFactory factory = (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();      //为实例化的ObjectFactory对象设置属性      factory.setProperties(properties);      //记录ObjectFactory对象      configuration.setObjectFactory(factory);    }  }</code></pre><p>XMLConfigBuilder对<code>&lt;objectWrapperFactory&gt;</code>和<code>&lt;reflectorFactory&gt;</code>节点的解析，和上述过程类似。</p><h2 id="3-7-将settings值设置到Configuration中"><a href="#3-7-将settings值设置到Configuration中" class="headerlink" title="3.7. 将settings值设置到Configuration中"></a>3.7. 将<code>settings</code>值设置到<code>Configuration</code>中</h2><p><code>XMLConfigBuilder.settingsElement()</code>这个就是最简单的赋值操作，如下所示：</p><pre><code class="java">  private void settingsElement(Properties props) {    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(&quot;autoMappingUnknownColumnBehavior&quot;, &quot;NONE&quot;)));    configuration.setCacheEnabled(booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;), true));    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(&quot;proxyFactory&quot;)));    configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(&quot;lazyLoadingEnabled&quot;), false));    configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(&quot;aggressiveLazyLoading&quot;), false));    configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(&quot;multipleResultSetsEnabled&quot;), true));    configuration.setUseColumnLabel(booleanValueOf(props.getProperty(&quot;useColumnLabel&quot;), true));    configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(&quot;useGeneratedKeys&quot;), false));    configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(&quot;defaultExecutorType&quot;, &quot;SIMPLE&quot;)));    configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(&quot;defaultStatementTimeout&quot;), null));    configuration.setDefaultFetchSize(integerValueOf(props.getProperty(&quot;defaultFetchSize&quot;), null));    configuration.setDefaultResultSetType(resolveResultSetType(props.getProperty(&quot;defaultResultSetType&quot;)));    configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(&quot;mapUnderscoreToCamelCase&quot;), false));    configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(&quot;safeRowBoundsEnabled&quot;), false));    configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(&quot;localCacheScope&quot;, &quot;SESSION&quot;)));    configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(&quot;jdbcTypeForNull&quot;, &quot;OTHER&quot;)));    configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(&quot;lazyLoadTriggerMethods&quot;), &quot;equals,clone,hashCode,toString&quot;));    configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(&quot;safeResultHandlerEnabled&quot;), true));    configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(&quot;defaultScriptingLanguage&quot;)));    configuration.setDefaultEnumTypeHandler(resolveClass(props.getProperty(&quot;defaultEnumTypeHandler&quot;)));    configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(&quot;callSettersOnNulls&quot;), false));    configuration.setUseActualParamName(booleanValueOf(props.getProperty(&quot;useActualParamName&quot;), true));    configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(&quot;returnInstanceForEmptyRow&quot;), false));    configuration.setLogPrefix(props.getProperty(&quot;logPrefix&quot;));    configuration.setConfigurationFactory(resolveClass(props.getProperty(&quot;configurationFactory&quot;)));  }</code></pre><h2 id="3-8-解析-lt-environments-gt-节点"><a href="#3-8-解析-lt-environments-gt-节点" class="headerlink" title="3.8. 解析&lt;environments&gt;节点"></a>3.8. 解析<code>&lt;environments&gt;</code>节点</h2><h2 id="3-9-解析-lt-databaseIdProvider-gt-节点"><a href="#3-9-解析-lt-databaseIdProvider-gt-节点" class="headerlink" title="3.9.  解析&lt;databaseIdProvider&gt;节点"></a>3.9.  解析<code>&lt;databaseIdProvider&gt;</code>节点</h2><h2 id="3-10-解析-lt-typeHandlers-gt-节点"><a href="#3-10-解析-lt-typeHandlers-gt-节点" class="headerlink" title="3.10. 解析&lt;typeHandlers&gt;节点"></a>3.10. 解析<code>&lt;typeHandlers&gt;</code>节点</h2><h2 id="3-11-解析-lt-mappers-gt-节点"><a href="#3-11-解析-lt-mappers-gt-节点" class="headerlink" title="3.11. 解析&lt;mappers&gt;节点"></a>3.11. 解析<code>&lt;mappers&gt;</code>节点</h2>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>​        JDBC数据类型与Java语言中的数据类型并不是完全对应的，所以在<code>PreparedStatement</code>为<code>SQL</code>语句绑定参数是，需要从<code>Java</code>类型转换成<code>JDBC</code>类型，而从<code>ResultSet</code>中获取数据时，则需要从<code>JDBC</code>类型转换成<code>Java</code>类型。<code>Mybatis</code>使用类型转换器完成上述两种转换。据图如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127092014-iVyREJ.png" srcset="undefined" alt=""></p><p>​        在<code>Mybatis</code>中使用<code>JdbcType</code>这种枚举类型代表<code>JDBC</code>中的数据类型，该枚举类型中定义了<code>TYPE_CODE</code>字段，记录了<code>JDBC</code>类中在<code>java.sql.Types</code>中相应的常量编码，并通过一个静态集合<code>codeLookUp（HashMap&lt;Integer,JdbcType&gt;类型）</code>维护了常量编码与<code>JdbcType</code>之间的对应关系。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127093418-Gzcley.png" srcset="undefined" alt=""></p><h1 id="2-TypeHandler"><a href="#2-TypeHandler" class="headerlink" title="2. TypeHandler"></a>2. TypeHandler</h1><p>​        Mybatis中所有的类型转换器都继承了<code>TypeHandler</code>接口，在<code>TypeHandler</code>接口中定义了如下四种方法，这四种方法分为两类：</p><ul><li><code>setParameter()</code>方法<ul><li>负责将数据由<code>Java</code>类型转换成<code>JdbcType</code>类型</li></ul></li><li><code>getResultSet()</code>方法<ul><li>负责将数据由<code>JdbcType</code>类型转换成<code>Java</code>类型</li></ul></li></ul><pre><code class="java">package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 类型处理器 * 说白了typeHandlers就是用来完成javaType和jdbcType之间的转换 * @author Clinton Begin */public interface TypeHandler&lt;T&gt; {  /**   * 通过PreparedStatement为Sql语句绑定参数是，会将数据从Java类型转换成JdbcType类型   * @param ps   * @param i 转换第几个参数   * @param parameter 参数   * @param jdbcType  要转换的jdbcType的类型   * @throws SQLException   */  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;  /**   * 从ResultSet中获取数据时会调用此方法，将数据有JdbcType类型转换为Java类型   * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;   */  T getResult(ResultSet rs, String columnName) throws SQLException;  T getResult(ResultSet rs, int columnIndex) throws SQLException;  T getResult(CallableStatement cs, int columnIndex) throws SQLException;}</code></pre><p>​        为了方便用户自定义<code>TypeHandler</code>实现，<code>Mybatis</code>提供了<code>BaseTypeHandler</code>这个抽象类，它实现了<code>TypeHandler</code>几口，并继承了<code>TypeReference</code>抽象类，其继承结构如下所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127095043-dUqC8a.png" srcset="undefined" style="zoom:50%;" /><p>在<code>BaseTypeHandler</code>中实现了<code>setParameter()</code>和<code>getResult()</code>方法，具体如下所示。</p><pre><code class="java">/**   * 在设置参数的时候，只处理为null的数据，不为空的数据都交给了子类实现   * @param ps   * @param i 转换第几个参数   * @param parameter 参数   * @param jdbcType  要转换的jdbcType的类型   * @throws SQLException   */  @Override  public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {    if (parameter == null) {      if (jdbcType == null) {        throw new TypeException(&quot;JDBC requires that the JdbcType must be specified for all nullable parameters.&quot;);      }      try {        ps.setNull(i, jdbcType.TYPE_CODE);      } catch (SQLException e) {        throw new TypeException(&quot;Error setting null for parameter #&quot; + i + &quot; with JdbcType &quot; + jdbcType + &quot; . &quot;              + &quot;Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. &quot;              + &quot;Cause: &quot; + e, e);      }    } else {      try {        //参数不为空，交给子类处理        setNonNullParameter(ps, i, parameter, jdbcType);      } catch (Exception e) {        throw new TypeException(&quot;Error setting non null for parameter #&quot; + i + &quot; with JdbcType &quot; + jdbcType + &quot; . &quot;              + &quot;Try setting a different JdbcType for this parameter or a different configuration property. &quot;              + &quot;Cause: &quot; + e, e);      }    }  }public abstract void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;</code></pre><pre><code class="java">  @Override  public T getResult(ResultSet rs, String columnName) throws SQLException {    try {      return getNullableResult(rs, columnName);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column &#39;&quot; + columnName + &quot;&#39; from result set.  Cause: &quot; + e, e);    }  }  @Override  public T getResult(ResultSet rs, int columnIndex) throws SQLException {    try {      return getNullableResult(rs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column #&quot; + columnIndex + &quot; from result set.  Cause: &quot; + e, e);    }  }  @Override  public T getResult(CallableStatement cs, int columnIndex) throws SQLException {    try {      return getNullableResult(cs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column #&quot; + columnIndex + &quot; from callable statement.  Cause: &quot; + e, e);    }  }  /**   * 3.5.0版本之后getResult方法，不管是空还是非空数据都要交给子类去处理   * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;   */  public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException;  public abstract T getNullableResult(ResultSet rs, int columnIndex) throws SQLException;  public abstract T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException;</code></pre><p>​        <strong>需要注意的是：</strong>在<code>Mybatis3.5</code>及其之后版本，<code>BaseTypeHandler.setParemeter()</code>只处理空参，非空参数交于子类处理，<code>BaseTypeHandler.getResult()</code>不管是空值还是非空都交于子类处理，而<code>Mybatis3.5</code>版本之前，<code>BaseTypeHandler.setParemeter()</code>和<code>BaseTypeHandler.getResult()</code>都是只对空参进行处理的。</p><p>​        <code>BaseTypeHandler</code>的实现类是比较多的，但是实现比较简单。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127101750-TJLaJn.png" srcset="undefined" style="zoom:67%;" /><p>这里以<code>IntergerTypeHandler</code>为例简单介绍：</p><pre><code class="java">package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @author Clinton Begin */public class IntegerTypeHandler extends BaseTypeHandler&lt;Integer&gt; {  @Override  public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType)      throws SQLException {    //调用PreparedStatement.setInt()实现参数绑定    ps.setInt(i, parameter);  }  @Override  public Integer getNullableResult(ResultSet rs, String columnName)      throws SQLException {    //调用ResultSet.getInt获取指定列值    int result = rs.getInt(columnName);    return result == 0 &amp;&amp; rs.wasNull() ? null : result;  }  @Override  public Integer getNullableResult(ResultSet rs, int columnIndex)      throws SQLException {    //调用ResultSet.getInt获取指定列值    int result = rs.getInt(columnIndex);    return result == 0 &amp;&amp; rs.wasNull() ? null : result;  }  @Override  public Integer getNullableResult(CallableStatement cs, int columnIndex)    //调用ResultSet.getInt获取指定列值      throws SQLException {    int result = cs.getInt(columnIndex);    return result == 0 &amp;&amp; cs.wasNull() ? null : result;  }}</code></pre><p>​        一般情况下，<code>TypeHandler</code>用于完成单个参数及其单个列值的类型转换，如果存在多列值转换成一个<code>Java</code>对象的需求，应该优先考虑使用在映射文件中定义合适的映射规则（<code>&lt;resultMap&gt;</code>节点）完成映射。</p><h1 id="3-TypeHandlerRegistry"><a href="#3-TypeHandlerRegistry" class="headerlink" title="3. TypeHandlerRegistry"></a>3. TypeHandlerRegistry</h1><p>​        介绍完<code>TypeHandler</code>接口及其功能之后，<code>Mybatis</code>如何管理众多的<code>TypeHandler</code>接口实现，如何知道何时使用哪个<code>TypeHandler</code>接口实现完成转换呢？这是有本小节介绍的<code>TypeHandlerRegistry</code>完成的，在<code>Mybatis</code>初始化过程中，会为所有已知的<code>TypeHandler</code>创建对象，并实现注册到<code>TypeHandlerRegistry</code>中，有<code>TypeHandlerRegistry</code>负责管理这些<code>TypeHandler</code>对象。<br>​        下面先来看看<code>TypeHandlerRegistry</code>中的核心字段的含义：</p><pre><code class="java">  /**   * 记录jdbcType与TypeHandler之间的对应关系，其中JdbcType是一个枚举类型，它定义对应了的JDBC类型   * 该集合主要用于从结果集读取数据是，将数据从jdbc类型转换成Java类型   */  private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap = new EnumMap&lt;&gt;(JdbcType.class);  /**   * 记录了Java类型向指定的jdbcType转换时，需要使用的TypeHandler对象。   * 例如：Java类型中的String 可能转换为数据库的char、varchar等多种类型，所以存在一对多关系   */  private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;();  /**   * 未知类型TypeHandler   */  private final TypeHandler&lt;Object&gt; unknownTypeHandler;  /**   * 记录了全部的TypeHandler的类型以及该类型相应的TypeHandler对象   */  private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = new HashMap&lt;&gt;();  /**   * 空TypeHandler集合的标识   */  private static final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap();  /**   * 默认枚举类型处理器   */  private Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;</code></pre><h2 id="3-1-TypeHandlerRegistry构造方法"><a href="#3-1-TypeHandlerRegistry构造方法" class="headerlink" title="3.1. TypeHandlerRegistry构造方法"></a>3.1. TypeHandlerRegistry构造方法</h2><p><code>TypeHandlerRegistry</code>构造中综合起来做了三步操作：</p><ol><li>创建了一个<code>Configuration</code>，或者通过<code>mybatis-config.xml</code>的初始化传入一个<code>Configuration</code>到<code>TypeHandlerRegistry</code>构造中；</li><li>利用传入的<code>configuration</code>对象，创建一个<code>UnknownTpyeHandler</code>，以备后续使用；</li><li>注册一堆<code>Mybatis</code>为我们提供的默认的<code>TypeHandler</code>。</li></ol><h2 id="3-2-注册TypeHandler对象"><a href="#3-2-注册TypeHandler对象" class="headerlink" title="3.2. 注册TypeHandler对象"></a>3.2. 注册TypeHandler对象</h2><p>TypeHandlerRegistry.register()方法实现了注册TypeHandler对象的功能，register()方法有多个重载，这些重载之间的调用关系如下图所示。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127172443-pn2dhu.png" srcset="undefined" alt=""></p><p>由上图可以看出，多数的register()方法最终会调用重载7完成注册功能，所以先分析重载7，该方法有三个参数分别是：</p><ul><li><code>Type javaType</code></li><li><code>JdbcType jdbcType</code></li><li><code>TypeHandler&lt;T&gt; handler</code></li></ul><pre><code class="java"> /**   * 最终调用到的重载方法   * @param javaType  能够处理的Java类型   * @param jdbcType   * @param handler   */  // 7  private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) {    //检测是否明确指定了TypeHandler能够处理的Java类型    if (javaType != null) {      //获取指定Java类型在typeHandlerMap集合中对应的TypeHandler集合      Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);      //如果map为空或者等于NULL_TYPE_HANDLER_MAP，创建新的TypeHandler集合，并添加到typeHandlerMap中      if (map == null || map == NULL_TYPE_HANDLER_MAP) {        map = new HashMap&lt;&gt;();        typeHandlerMap.put(javaType, map);      }      //将TypeHandler对象注册到typeHandlerMap集合中      map.put(jdbcType, handler);    }    //向allTypeHandlersMap集合注册TypeHandler类型和对应的TypeHandler对象    allTypeHandlersMap.put(handler.getClass(), handler);  }</code></pre><h2 id="3-3-查找TypeHandler"><a href="#3-3-查找TypeHandler" class="headerlink" title="3.3. 查找TypeHandler"></a>3.3. 查找TypeHandler</h2><p>介绍完注册<code>TypeHandler</code>对象的功能之后，再来介绍<code>TypeHandlerRegistry</code>提供的查找<code>TypeHandler</code>对象的功能。</p><h1 id="4-TypeAliasRegistry"><a href="#4-TypeAliasRegistry" class="headerlink" title="4. TypeAliasRegistry"></a>4. TypeAliasRegistry</h1><p>在编写<code>SQL</code>语句时，使用别名可以方便理解以及维护，例如表名或列名很长时，我们一般会为其设计易懂易维护的别名。<code>Mybatis</code>将<code>SQL</code>语句中的别名的概念进行了延伸和扩展，<code>Mybatis</code>可以为一个类添加一个别名，之后就可以通过别名引用该类。</p><p><code>Mybati</code>通过<code>TypeAliasRegistry</code>类完成别名的注册和管理功能，<code>TypeAliasRegistry</code>的结构比较简单，它通过<code>typeAliases</code>字段（<code>Map&lt;String, Class&lt;?&gt;&gt;</code>类型）管理别名与Java类型之间的对应关系，通过<code>TypeAliasRegistry.registerAlias()</code>方法完成注册别名，该方法的实现如下所示：</p><pre><code class="java">  /**   * 注册类型别名   * @param alias 被注册类的别名   * @param value  被注册的类   */  public void registerAlias(String alias, Class&lt;?&gt; value) {    if (alias == null) {      throw new TypeException(&quot;The parameter alias cannot be null&quot;);    }    // issue #748    //所有的类型最终都被转换为了小写，所以之前不管你是大写还是小写，最后都不转化了，不要因为大小写是不一样的。    String key = alias.toLowerCase(Locale.ENGLISH);    if (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != null &amp;&amp; !typeAliases.get(key).equals(value)) {      throw new TypeException(&quot;The alias &#39;&quot; + alias + &quot;&#39; is already mapped to the value &#39;&quot; + typeAliases.get(key).getName() + &quot;&#39;.&quot;);    }    typeAliases.put(key, value);  }</code></pre><p><code>TypeAliasRegistry</code>还有很多<code>registerAlias()</code>的重载，如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129164654-qjl9So.png" srcset="undefined" alt=""></p><p>其中还有两个重载需要我们注意：</p><ul><li><p>扫描包的</p><pre><code class="java">  /**   * 扫描指定包下面所有的类，并为其类的子类添加别名   * @param packageName   * @param superType   */  public void registerAliases(String packageName, Class&lt;?&gt; superType) {    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();    for (Class&lt;?&gt; type : typeSet) {      // Ignore inner classes and interfaces (including package-info.java)      // Skip also inner classes. See issue #6      if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) {        registerAlias(type);      }    }  }</code></pre></li><li><p>尝试读取<code>@Alias</code>注解的</p><pre><code class="java">  public void registerAlias(Class&lt;?&gt; type) {    //获取类的简单名称，不包括包名    String alias = type.getSimpleName();    //读取Alias注解    Alias aliasAnnotation = type.getAnnotation(Alias.class);    if (aliasAnnotation != null) {      alias = aliasAnnotation.value();    }    registerAlias(alias, type);  }</code></pre></li></ul><p>在<code>TypeAliasRegistry</code>的构造方法中，默认为Java的基本类型及其数组类型、基本类型的包装类型以及数组类型、<code>Data</code>、<code>BigDecimal</code>、<code>ResultSet</code>等类型添加了别名，可以参考<code>Mybatis</code>官网文档（<a href="https://mybatis.org/mybatis-3/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases模块</a>）。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射工具箱</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html</url>
    
    <content type="html"><![CDATA[<h1 id="反射工具箱"><a href="#反射工具箱" class="headerlink" title="反射工具箱"></a>反射工具箱</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​        Mybatis在进行参数处理、结果集映射等操作时，会涉及大量的反射操作。Java中的反射虽然功能强大，但是代码编写起来比较复杂容易出错，为了简化反射操作的相关代码，Mybatis提供了专门的反射模块，该模块位于<code>org.apache.ibatis.reflection</code>包中，它对常见的反射操作做了封装，提供了更加简洁方便的反射API。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126092626-rve1an.png" srcset="undefined" style="zoom:67%;" /><h1 id="2-Reflector-amp-ReflectorFactory"><a href="#2-Reflector-amp-ReflectorFactory" class="headerlink" title="2. Reflector&amp;ReflectorFactory"></a>2. Reflector&amp;ReflectorFactory</h1><h2 id="2-1-Reflector"><a href="#2-1-Reflector" class="headerlink" title="2.1. Reflector"></a>2.1. Reflector</h2><p>​         <code>Reflector</code>是<code>Mybatis</code>中反射模块的基础，每个<code>Reflector</code>对象都对应一个类，在Reflector中缓存了反射操作需要使用的类的元信息。Reflector中各个字段的含义如下所示：</p><pre><code class="java">/**   * 对应类的类型   */  private final Class&lt;?&gt; type;  /**   * 可读属性的名称集合，可读属性就是存在相应的getter方法的属性，初始值为空数组   */  private final String[] readablePropertyNames;  /**   * 可写属性的名称集合，可写属性就是存在相应setter方法的属性，初始值为空数组   */  private final String[] writablePropertyNames;  /**   * 记录了属性相应的setter方法，key是属性名称，value是Invoke对象，它是对setter方法对应Method对象的封装，后面会详细介绍   */  private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法集合，key是属性名称，value是Invoke对象，   */  private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法的返回值类型，key是属性名称，value是getter方法的返回值类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;();  /**   * 记录了默认的构造方法   */  private Constructor&lt;?&gt; defaultConstructor;  /**   * 记录了所有属性名称的集合   */  private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;();</code></pre><p>​        在<code>Reflector</code>的构造方法中会解析指定的<code>Class</code>对象，并填充上述集合，具体实现如下所示：</p><pre><code class="java">/**   * 此构造方法中会解析指定的Class对象，并填充上述集合   * @param clazz 需要解析的Class对象   */  public Reflector(Class&lt;?&gt; clazz) {    //初始化type字段    type = clazz;    //查找clazz的默认构造方法（无参构造方法），具体实现是通过反射遍历所有构造方法    addDefaultConstructor(clazz);    //处理clazz中的getter方法，填充getMethods集合和getTypes集合    addGetMethods(clazz);    //处理clazz中的setter方法，填充setMethods集合和setTypes集合    addSetMethods(clazz);    //处理没有getter/setter方法的字段    addFields(clazz);    //根据getMethods和setMethods集合，初始化可读、可写属性的名称集合    readablePropertyNames = getMethods.keySet().toArray(new String[0]);    writablePropertyNames = setMethods.keySet().toArray(new String[0]);    //初始化caseInsensitivePropertyMap，其中记录了所有大写格式的属性名称    for (String propName : readablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }    for (String propName : writablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }  }</code></pre><p>​        以上代码中<code>addDefaultConstructor(clazz);</code>很是简单，所以没有必要去分析这个方法，其次就是<code>addGetMethods(clazz);</code>和<code>addSetMethods(clazz);</code>方法，<code>Reflector.addGetMethods()</code>方法主要腹泻解析类中定义的<code>getter</code>方法，<code>Reflector.addSetMethods()</code>方法负责解析类中的<code>setter</code>方法，两者的逻辑类似，这里以<code>addSetMethods(clazz);</code>方法为例进行介绍，<code>addSetMethods()</code>方法不做详细介绍，<code>Reflector.addGetMethods()</code>主要有如下三个核心步骤：</p><pre><code class="java">/**   * 负责解析类中的get方法   * @param clazz   */  private void addGetMethods(Class&lt;?&gt; clazz) {    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;&gt;();    /**     * 1. 调用{@link Reflector#getClassMethods(Class)} 方法获取当前类以及其父类中定义的所有方法的唯一签名以及相应的Method对象。     */    Method[] methods = getClassMethods(clazz);    /**     * 2. 按照JavaBean的规范，从Reflector#getClassMethods(Class)方法返回的Methods数组中查找该类中定义的getter方法，     *    将其记录在conflictingGetters集合中，conflictingGetters集合（ Map&lt;String, List&lt;Method&gt;&gt;类型）的key为属性名称，value是该属性对应的getter方法集合。     *     *    2.1. 具体步骤     *      2.1.1. 得到所有的get方法，（参数类别为空，标志是get的方法）；     *      2.1.2. 将得到的get方法添加到方法冲突集合中；     *          例如：父类 public List&lt;User&gt; getUserList(); 子类 public ArrayList&lt;User&gt; getUserList();     *               在进行{@link Reflector#getClassMethods(Class)}中的{@link Reflector#getSignature(Method)}返回结果是：     *               java.util.List#getUserList和java.util.ArrayList#getUserList，即得到两个方法签名，在{@link Reflector#addUniqueMethods(Map, Method[])}     *               方法中会被认为是两个不同的方法添加到 uniqueMethods集合中，这显然不是我们想要的结果。     *     *  所以后续步骤3 会去解决这种Getter方法的冲突。     *     *  (lambda表达式 :filter forEach )     */    Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));    /**     * 3. 解决Getter冲突     *   1. 为什么会产生冲突呢？     *      步骤2已经解释过为什么会产生冲突了。     *   2. 解决方式是什么？     */    resolveGetterConflicts(conflictingGetters);  }</code></pre><ul><li><p>首先，调用<code>Reflector.getClassMethods()</code>方法获取当前类及其父类中定义的所以方法的唯一签名以及相应的<code>Methods</code>对象。</p><pre><code class="java">private Method[] getClassMethods(Class&lt;?&gt; clazz) {    Map&lt;String, Method&gt; uniqueMethods = new HashMap&lt;&gt;();    Class&lt;?&gt; currentClass = clazz;    while (currentClass != null &amp;&amp; currentClass != Object.class) {      //记录currentClass这个类中定义的全部方法      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());      // we also need to look for interface methods -      // because the class may be abstract      // 记录接口中定义的方法      Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();      for (Class&lt;?&gt; anInterface : interfaces) {        addUniqueMethods(uniqueMethods, anInterface.getMethods());      }      //获取父类，继续while循环      currentClass = currentClass.getSuperclass();    }    Collection&lt;Method&gt; methods = uniqueMethods.values();    //转换成Methods方法数组返回    return methods.toArray(new Method[0]);  }</code></pre><p>在<code>Reflector.addUniqueMethods()</code>方法中会为每个方法生成唯一签名，并记录到<code>uniqueMethods</code>集合中，具体实现如下所示：</p><pre><code class="java"> /**   * 为每个方法生成一个唯一签名，并记录到uniqueMethods集合中   * @param uniqueMethods   * @param methods   */  private void addUniqueMethods(Map&lt;String, Method&gt; uniqueMethods, Method[] methods) {    for (Method currentMethod : methods) {      if (!currentMethod.isBridge()) {        /**         * 通过{@link Reflector#getSignature(Method)}方法得到方法的签名是：返回值类型#方法名称：参数类型列表。         * 例如： Reflector.getSignature(Method)的方法签名是：java.lang.String#getSignature:java.lang.reflect.Method         * 通过Reflector.getSignature(Method)方法得到的方法签名是全局唯一的，可以作为该方法的唯一标识         */        String signature = getSignature(currentMethod);        // check to see if the method is already known        // if it is known, then an extended class must have        // overridden a method        /**         * 检查是否添加过该方法，如果添加过，就无须在向uniqueMethods中添加该方法了。         * 其实这个段代码，如果细品有另一种意思：         *    因为addUniqueMethods方法在{@link Reflector#getClassMethods(Class)}中的while循环被调用了，一次循环被调用两次，         *    这两次调用：先是子类调用，然后是父类接口调用，         * 所以这里检查是否添加过该方法的另一层含义是：         *    检测是否在子类中已经添加过该方法，如果在子类中添加过，则表示子类覆盖了该方法，无须再向uniqueMethods集合中添加该方法了。         *         */        if (!uniqueMethods.containsKey(signature)) {          //记录该签名和方法的对应关系          uniqueMethods.put(signature, currentMethod);        }      }    }  }</code></pre></li><li><p>然后，按照<code>JavaBean</code>的规范，从<code>Reflector.getClassMethods()</code>返回的Method数组中查找该类中定义的<code>getter</code>方法（具体哪些方法算是<code>getter</code>方法，后面会详细介绍），将其记录到<code>conflictingGetters</code>集合中。<code>conflictingGetters</code>集合（<code>Map&lt;String, List&lt;Method&gt;&gt;</code>类型）的<code>key</code>是属性名称，<code>value</code>是该属性对应的<code>getter</code>方法集合。</p><pre><code class="java">//Reflector.javaArrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));</code></pre><pre><code class="java">//Reflector.java/**   * 添加方法冲突   * @param conflictingMethods   * @param name   * @param method   *   */  private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) {    if (isValidPropertyName(name)) {      /**       * {@link Map#computeIfAbsent(Object, Function)}       * @see red.reksai.reflection.ComputeIfAbsentTest   map jdk1.8新特性       */      List&lt;Method&gt; list = conflictingMethods.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;());      list.add(method);    }  }</code></pre><pre><code class="java">//PropertyNamer.java/**   * 根据Javabean的规范，获取对应的属性名称   * @param name   * @return   */  public static String methodToProperty(String name) {    if (name.startsWith(&quot;is&quot;)) {      name = name.substring(2);    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {      name = name.substring(3);    } else {      throw new ReflectionException(&quot;Error parsing property name &#39;&quot; + name + &quot;&#39;.  Didn&#39;t start with &#39;is&#39;, &#39;get&#39; or &#39;set&#39;.&quot;);    }    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {      name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);    }    return name;  }</code></pre></li><li><p>当子类覆盖了父类的getter方法且返回值发生变化时，在步骤1中就会产生两个签名不用的方法。</p><ul><li>例如：</li></ul><pre><code class="java">import org.apache.ibatis.reflection.Reflector;import java.util.ArrayList;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/26 10:19 */public class ReflectorTest {  public static void main(String[] args) {    Reflector reflector = new Reflector(User.class);    System.out.println(reflector);  }}class  User extends Person{  public User() {  }  public User(String userName, String passWord) {    this.userName = userName;    this.passWord = passWord;  }  private String userName ;  private String passWord ;  public String getUserName() {    return userName;  }  public void setUserName(String userName) {    this.userName = userName;  }  public String getPassWord() {    return passWord;  }  public void setPassWord(String passWord) {    this.passWord = passWord;  }  public boolean isStatus() {    return super.getStatus() ;  }  @Override  public void setStatus(boolean status) {    super.setStatus(status);  }  @Override  public ArrayList&lt;Items&gt; getList() {    return (ArrayList&lt;Items&gt;) super.getList();  }  @Override  public void setList(List&lt;Items&gt; list) {    super.setList(list);  }}class Person {  private List&lt;Items&gt; list;  private boolean status ;  public boolean getStatus() {    return status;  }  public void setStatus(boolean status) {    this.status = status;  }  public List&lt;Items&gt; getList() {    return list;  }  public void setList(List&lt;Items&gt; list) {    this.list = list;  }  public Person() {  }  public Person(List&lt;Items&gt; list) {    this.list = list;  }}class Items{  private String itmeId;  private String itmeName ;}</code></pre><ul><li>在以下位置打断点</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233022-6FOt8I.png" srcset="undefined" alt=""></p><ul><li>观察conflictingGetters集合中的值，如下所示：</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233326-2wTK6y.png" srcset="undefined" alt=""></p><p>其中属性名称为<code>list</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，这就是因为<code>User</code>在覆盖<code>Person</code>中的<code>getList()</code>方法是返回值从<code>List</code>变成了<code>ArrayList</code>，又因为生成方法签名的规则如下所示，所以就造成了有两个不同方法签名的方法被添加到了<code>uniqueMethods</code>集合中，这不是我们想要的结果。</p><pre><code class="java">// Reflector.java/**   * 生成方法签名   * @param method   * @return   */  private String getSignature(Method method) {    StringBuilder sb = new StringBuilder();    Class&lt;?&gt; returnType = method.getReturnType();    if (returnType != null) {      sb.append(returnType.getName()).append(&#39;#&#39;);    }    sb.append(method.getName());    Class&lt;?&gt;[] parameters = method.getParameterTypes();    for (int i = 0; i &lt; parameters.length; i++) {      sb.append(i == 0 ? &#39;:&#39; : &#39;,&#39;).append(parameters[i].getName());    }    return sb.toString();  }</code></pre><p>其中属性为<code>status</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，一个是父类中的<code>boolean getStatus()</code>，另一个是子类中的 <code>boolean isStatus()</code>（涉及到JavaBean规范），说白了此时<code>uniqueMethods</code>集合中也有两个，这也不是我们想要的结果。</p></li><li><p>所以步骤3会调用<code>Reflector.resolveGetterConflicts(conflictingGetters)</code>方法对步骤2中这种覆写的情况进行处理，同时会将处理得到的<code>getter</code>方法记录到<code>getMethods</code>集合中，并将其返回值类型填充到<code>getTypes</code>集合中，<code>Reflector.resolveGetterConflicts()</code>方法的具体实现如下所示：</p></li></ul><pre><code class="Java"> //Reflector.java /**   * 解决get方法的冲突，同时会将处理得到的getter方法记录到getMethods集合中，并将其返回值类型填充到getTypes集合中   * @param conflictingGetters   */  private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) {    //遍历conflictingGetters集合    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) {      //优胜Method对象      Method winner = null;      //方法名称      String propName = entry.getKey();      boolean isAmbiguous = false;      // candidate 候选Method对象      for (Method candidate : entry.getValue()) {        //如果优胜对象为空，这时候将候选对象复制给优胜对象        if (winner == null) {          winner = candidate;          // continue是跳过当次循环中剩下的语句，执行下一次循环          continue;        }        //获取优胜者返回值类型        Class&lt;?&gt; winnerType = winner.getReturnType();        //获取候选者返回值类型        Class&lt;?&gt; candidateType = candidate.getReturnType();        /**         * 如果返回值类型相同，就要判断返回值是不是boolean？为什么要判断是不是boolean呢？         */        if (candidateType.equals(winnerType)) {          //如果返回值不是boolean直接          if (!boolean.class.equals(candidateType)) {            isAmbiguous = true;            //break只能跳出1层循环            break;          } else if (candidate.getName().startsWith(&quot;is&quot;)) {            winner = candidate;          }        }        /**         * @see red.reksai.javabase.IsAssignableFromTest         * 判断返回值类型有三种情况：         *  1. 候选者是优胜者的父类，不做任何操作，最终返回子类就行         *  2. 优胜者是候选者的父类，这时候先要将候选者赋值给优胜者，然后返回         *  3. 返回值相同，二义性，         */        else if (candidateType.isAssignableFrom(winnerType)) {          // OK getter type is descendant        } else if (winnerType.isAssignableFrom(candidateType)) {          winner = candidate;        } else {          isAmbiguous = true;          break;        }      }      //该字段只有一个getter方法，直接添加到getMethods集合并填充getTypes集合      addGetMethod(propName, winner, isAmbiguous);    }  }</code></pre><p>正如上面描述的那样，在<code>Reflector.addGetMethod(propName, winner, isAmbiguous);</code>方法中完成了对<code>getMethods</code>集合和<code>getType</code>集合的填充，具体实现如下所示：</p><pre><code class="java">  private void addGetMethod(String name, Method method, boolean isAmbiguous) {    /**     * 验证：     *    1. 如果有含糊不清的直接报错，     *    2. 如果验证通过，则进行方法的封装     */    MethodInvoker invoker = isAmbiguous        ? new AmbiguousMethodInvoker(method, MessageFormat.format(            &quot;Illegal overloaded getter method with ambiguous type for property &#39;&#39;{0}&#39;&#39; in class &#39;&#39;{1}&#39;&#39;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;,            name, method.getDeclaringClass().getName()))        : new MethodInvoker(method);    getMethods.put(name, invoker);    /**     * 获取返回值的Type ，{@link TypeParameterResolver}     */    Type returnType = TypeParameterResolver.resolveReturnType(method, type);    getTypes.put(name, typeToClass(returnType));  }</code></pre><h2 id="2-2-TypeParameterResolver"><a href="#2-2-TypeParameterResolver" class="headerlink" title="2.2. TypeParameterResolver"></a>2.2. TypeParameterResolver</h2><h2 id="2-3-ObjectFactory"><a href="#2-3-ObjectFactory" class="headerlink" title="2.3. ObjectFactory"></a>2.3. ObjectFactory</h2><h2 id="2-4-Property工具集"><a href="#2-4-Property工具集" class="headerlink" title="2.4. Property工具集"></a>2.4. Property工具集</h2><p>本小节主要介绍反射模块中使用到的三个属性工具类，分别是<code>PropertyTokenizer</code>、<code>PropertyNamer</code>和<code>PropertyCopier</code>。</p><hr><p><strong>此段我暂时也不知道怎么去解释，也许是后续学习能解释这个问题吧。</strong></p><p>在使用<code>Mybatis</code>的过程中，我们会经常碰到一些属性表达式，例如，在查询某用户（<code>User</code>）的订单（<code>Order</code>）的结果集如下表所示：</p><table><thead><tr><th align="center">user_name</th><th align="center">order</th><th align="center">item1</th><th align="center">item2</th><th align="center">. . .</th></tr></thead><tbody><tr><td align="center">Mary</td><td align="center">12460</td><td align="center">IPhone</td><td align="center">Computer</td><td align="center"></td></tr><tr><td align="center">Lisa</td><td align="center">36546</td><td align="center">MX</td><td align="center">Wather</td><td align="center"></td></tr><tr><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td></tr></tbody></table><hr><h3 id="2-4-1-PropertyTokenizer"><a href="#2-4-1-PropertyTokenizer" class="headerlink" title="2.4.1. PropertyTokenizer"></a>2.4.1. PropertyTokenizer</h3><p><code>PropertyTokenizer</code>是一个属性分词器工具，它继承了<code>Iterator</code>接口，它可以迭代处理嵌套的多层表达式。</p><p>由“<code>*</code>”和“<code>[]</code>”组成的表达式是由<code>PropertyTokenizer</code>进行解析的，<code>PropertyTokenizer</code>中各个字段的含义如下所示：</p><pre><code class="java">// fullName = &quot;order[0].items[0].name&quot;  // String[] split = {&quot;order[0]&quot; ,&quot;item[0]&quot; ,&quot;name&quot;}  /**   * 当前表达式的名称:   * e.g. order   *      items   *      name   */  private String name;  /**   * 当前表达式的索引名   * e.g. order[0]   *      items[0]   *      name   */  private final String indexedName;  /**   * 索引下标   * e.g. [0]   *      [0]   *      null   */  private String index;  /**   * 子表达式   * e.g. items[0].name   *      name   *      null   */  private final String children;</code></pre><p>核心方法有三个分别是：</p><ul><li><code>PropertyTokenizer()</code></li></ul><pre><code class="java">/**   * 解析表达式   * @param fullname  要解析的表达式   *                  e.g. order[0].items[0].name   */  public PropertyTokenizer(String fullname) {    //查找&quot;.&quot;的位置    int delim = fullname.indexOf(&#39;.&#39;);    if (delim &gt; -1) {      //初始化name      name = fullname.substring(0, delim);      //初始化children      children = fullname.substring(delim + 1);    } else {      name = fullname;      children = null;    }    //初始化indexName    indexedName = name;    //查找&quot;[&quot;的位置，如果存在，最后要把上面步骤赋值给name中的&quot;[]&quot;去掉    delim = name.indexOf(&#39;[&#39;);    if (delim &gt; -1) {      //初始化index      index = name.substring(delim + 1, name.length() - 1);      //重新赋值给name      name = name.substring(0, delim);    }  }</code></pre><ul><li><code>hasNext()</code></li></ul><pre><code class="java">  /**   * 判断是否还有children   * @return   */  @Override  public boolean hasNext() {    return children != null;  }</code></pre><ul><li><code>next()</code></li></ul><pre><code class="java">  /**   * 继续解析孩子节点   * @return   */  @Override  public PropertyTokenizer next() {    return new PropertyTokenizer(children);  }</code></pre><p>例子：</p><pre><code class="java">import org.apache.ibatis.reflection.property.PropertyTokenizer;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/29 11:12 */public class PropertyTokenizerTest {  public static void main(String[] args) {    String fullName = &quot;orders[0.items[0].name&quot; ;    doTokenizer(fullName);  }  private static void doTokenizer(String name){    PropertyTokenizer propertyTokenizer = new PropertyTokenizer(name);    System.out.println(propertyTokenizer.getIndexedName());    System.out.println(propertyTokenizer.getName());    System.out.println(propertyTokenizer.getIndex());    System.out.println(propertyTokenizer.getChildren());    System.out.println(&quot;.................&quot;);    String children = propertyTokenizer.getChildren();    if (propertyTokenizer.hasNext()){      doTokenizer(children);    }  }}</code></pre><p>运行结果：</p><pre><code>orders[0ordersitems[0].name.................items[0]items0name.................namenamenullnull.................</code></pre><h3 id="2-4-2-PropertyNamer"><a href="#2-4-2-PropertyNamer" class="headerlink" title="2.4.2. PropertyNamer"></a>2.4.2. PropertyNamer</h3><h3 id="2-4-3-PropertyCopier"><a href="#2-4-3-PropertyCopier" class="headerlink" title="2.4.3. PropertyCopier"></a>2.4.3. PropertyCopier</h3><h2 id="2-5-MetaClass"><a href="#2-5-MetaClass" class="headerlink" title="2.5. MetaClass"></a>2.5. MetaClass</h2><h3 id="2-5-1-主要方法详解"><a href="#2-5-1-主要方法详解" class="headerlink" title="2.5.1. 主要方法详解"></a>2.5.1. 主要方法详解</h3><p><code>MetaClass</code>通过<code>Reflector</code>和<code>PropertyTokenizer</code>组合使用，实现了对复杂的属性表达式的解析，并实现了获取指定属性描述信息的功能。<code>MetaClass</code>中各个字段的含义如下：</p><pre><code class="java">  /**   * ReflectorFactory对象，用于缓存Reflector对象   */  private final ReflectorFactory reflectorFactory;  /**   *   在创建MetaClass时会指定一个类，该Reflector对象会用于记录该类相关信息   */  private final Reflector reflector;</code></pre><p><code>MetaClass</code>的构造函数中会为指定的<code>Class</code>创建相应的<code>Reflector</code>对象，并用其初始化<code>MetaClass.reflector</code>字段，具体代码如下所示：</p><pre><code class="java">  /**   * 此构造方法是一个private   * @param type   * @param reflectorFactory     */  private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {    this.reflectorFactory = reflectorFactory;    //创建reflector对象，默认使用的是DefaultReflectorFactory.findForClass()方法    this.reflector = reflectorFactory.findForClass(type);  }  /**   * 使用静态方法创建MetaClass对象   * @param type   * @param reflectorFactory   * @return   */  public static MetaClass forClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {    return new MetaClass(type, reflectorFactory);  }</code></pre><p><code>MetaClass</code>中比较重要的是<code>findProperty()</code>方法，它是通过调用<code>MetaClass.buildProperty()</code>方法实现的：</p><pre><code class="Java">//MetaClass.java    /**   * 只查找&quot;.&quot;导航的属性，并且没有检测下标   * @param name 要查找的属性名称   * @return   */  public String findProperty(String name) {    //委托给buildProperty()方法实现    StringBuilder prop = buildProperty(name, new StringBuilder());    return prop.length() &gt; 0 ? prop.toString() : null;  }</code></pre><pre><code class="java"> private StringBuilder buildProperty(String name, StringBuilder builder) {    //解析表达式    PropertyTokenizer prop = new PropertyTokenizer(name);    //判断是否还有子表达式    if (prop.hasNext()) {      String propertyName = reflector.findPropertyName(prop.getName());      if (propertyName != null) {        builder.append(propertyName);        builder.append(&quot;.&quot;);        //查找属性所对应的MetaClass        MetaClass metaProp = metaClassForProperty(propertyName);        metaProp.buildProperty(prop.getChildren(), builder);      }    } else {      String propertyName = reflector.findPropertyName(name);      if (propertyName != null) {        builder.append(propertyName);      }    }    return builder;  }</code></pre><p>有上述代码可以看出：findPropertory()方法值查找“.”导航的属性，并没有检测下标。</p><p>这里以解析User类中的tele.contry这个属性表达式为例解释上述过程：</p><ol><li><p>首先使用findPropertory(“tele.contry”)；</p></li><li><p>MetaClass.buildPropertry(“tele.country”,stringBuilder)；</p></li><li><p>接着使用PropertryTokenizer解析数据，发现还有子表达式：country，说明此属性表达式所属的类不是当前了，需要查找此属性属于的类；</p></li><li><p>所以要通过MetaClass.metaClassForPropertry(“tele”)，获取到对应的实体类，其中使用到了Reflector.getGetterType()得到了返回值的类型，然后使用MetaClass.forClass()返回返回值对应的元类。</p></li><li><p>递归调用2。</p></li></ol><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129152716-h9Os7u.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153239-L5s0UA.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153351-r3eIeh.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153624-PBw7Sr.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153949-KaKXgI.png" srcset="undefined" alt=""></p><h3 id="2-5-2-测试用例"><a href="#2-5-2-测试用例" class="headerlink" title="2.5.2. 测试用例"></a>2.5.2. 测试用例</h3><pre><code class="java">package red.reksai.reflection;import org.apache.ibatis.reflection.DefaultReflectorFactory;import org.apache.ibatis.reflection.MetaClass;import org.junit.jupiter.api.Test;import red.reksai.reflection.entity.User;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/29 10:07 */public class MetaClassTest {  @Test  public  void test() {    MetaClass metaClass = MetaClass.forClass(User.class, new DefaultReflectorFactory());    System.out.println(metaClass.findProperty(&quot;tele.country&quot;));     //tele.country    System.out.println(metaClass.getGetterType(&quot;tele.country&quot;));    // class java.lang.String    System.out.println(metaClass.hasGetter(&quot;tete.country&quot;));    //true    System.out.println(metaClass.getGetterType(&quot;orders[0].items[0]&quot;));    // class red.reksai.reflection.entity.Item  }}</code></pre><h2 id="2-6-ObjectWrapper"><a href="#2-6-ObjectWrapper" class="headerlink" title="2.6. ObjectWrapper"></a>2.6. ObjectWrapper</h2><h2 id="2-7-MetaObject"><a href="#2-7-MetaObject" class="headerlink" title="2.7. MetaObject"></a>2.7. MetaObject</h2>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析器模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​    解析器模块，对应的包是<code>parsing，</code>如下图所示：</p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191126003045-GKXnIt.png" srcset="undefined" style="zoom:50%;" /><p>解析器模块，主要提供了两个功能：</p><ul><li>对XPath进行封装，为Mybatis初始化时解析<code>mybatis-config.xml</code>配置文件以及<code>mapper</code>映射配置文件提供支持。</li><li>为处理动态SQL语句中的占位符提供支持。</li></ul><h1 id="2-XML解析方式"><a href="#2-XML解析方式" class="headerlink" title="2. XML解析方式"></a>2. XML解析方式</h1><p>在mybatis中涉及到多个XML配置文件，因此我们首先要介绍XML解析的相关内容。XML解析的常见的方式有三种：</p><ul><li>DOM（document object model）解析方式</li><li>SAX（simple api for xml）解析方式</li><li>Java6版本开始，JDK致辞的StAX（streaming api for xml）解析方式。</li></ul><p>DOM是基于树形结构的XML解析方式，它将整个XML文档读入内存并构建成一个DOM树,基于这棵树形结构对各个节点（node）进行操作。XML文档中的每一个成分都是一个节点：整个文档是一个文档节点，每个XML标签对应一个元素节点，包含在XML标签中的文本是文本节点，每一个XML属性是一个属性节点，注释属于注释节点。</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>解析后得到的树形结构为：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125100550-l1ZKVS.png" srcset="undefined" alt=""></p><h1 id="3-XPath"><a href="#3-XPath" class="headerlink" title="3. XPath"></a>3. XPath</h1><p>​        mybatis在初始化过程中处理mybatis-config.xml配置文件以及映射文件时，使用的是DOM解析方式，并结合XPath解析xml配置文件，正如前文所述，DOM会对整个XML文档加载到内存中形成树形数据结构，而xpth是一种为查询XML文档而设计的语言，它可以与DOM解析方式配合使用，实现对XML文档的解析。xpath之于XML就好比SQL语言之于数据库。</p><p>​        代码示例：</p><pre><code class="java">import org.apache.ibatis.io.Resources;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.ErrorHandler;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.xpath.*;import java.io.IOException;import java.io.InputStream;/** * XPath解析测试 {@link javax.xml.xpath.XPath} * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 10:11 */public class XPathTest {  public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {    //创建DOM解析器工厂    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();    //开启验证    documentBuilderFactory.setValidating(true);    documentBuilderFactory.setNamespaceAware(false);    documentBuilderFactory.setIgnoringComments(true);    documentBuilderFactory.setIgnoringElementContentWhitespace(false);    documentBuilderFactory.setCoalescing(false);    documentBuilderFactory.setExpandEntityReferences(true);    //得到一个DOM解析器对象    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();    documentBuilder.setErrorHandler(new ErrorHandler() {      @Override      public void warning(SAXParseException exception) throws SAXException {        System.out.println(&quot;warning&quot; + exception.getMessage());      }      @Override      public void error(SAXParseException exception) throws SAXException {        System.out.println(&quot;error&quot; + exception.getMessage());      }      @Override      public void fatalError(SAXParseException exception) throws SAXException {        System.out.println(&quot;fatalError&quot; + exception.getMessage());      }    });    String resource = &quot;resources/xpath-demo.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    //解析xml    Document document = documentBuilder.parse(inputStream);    XPathFactory xPathFactory = XPathFactory.newInstance();    XPath xPath = xPathFactory.newXPath();    XPathExpression xPathExpression = xPath.compile(&quot;/configuration/mappers/mapper&quot;);    NodeList evaluate = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);    for (int i = 0; i &lt; evaluate.getLength() ; i++) {      Node node = evaluate.item(i);      String nodeName = node.getNodeName();      if ((&quot;mapper&quot;).equals(node.getNodeName())){        Node attributeNode = node.getAttributes().getNamedItem(&quot;resource&quot;);        String nodeValue1 = attributeNode.getNodeValue();        System.out.println(nodeName +&quot;......&quot;+nodeValue1);      }    }  }}</code></pre><p>运行结果：</p><pre><code class="java">mapper......org/mybatis/example/BlogMapper.xmlmapper......org/mybatis/example/UserMapper.xml</code></pre><h1 id="4-XPathParser"><a href="#4-XPathParser" class="headerlink" title="4. XPathParser"></a>4. XPathParser</h1><p>Mybatis提供的<code>org.apache.ibatis.parsing.XPathParser</code>类封装了前面涉及到的<code>XPath</code>、<code>Document</code>和<code>EntityResolver</code>，如图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125223756-R177Lc.png" srcset="undefined" alt=""></p><p>XPathParser中各个字段的含义和功能如下所示：</p><pre><code class="java">  /**   * xml document 对象   */  private final Document document;  /**   * 是否开启校验xml   */  private boolean validation;  /**   * 用于加载本地DTD文件   *   * xml实体解析器，默认情况下，对XML校验是，会基于xml文档开始位置定义的DTD文件或者XSD文件，   * 例如：   *    解析mybatis-config.xml配置文件时，会加载http://mybatis.org/dtd/mybatis-3-config.dtd这个DTD文件。   *    但是，如果如果每个应用启动都从网络加载该DTD文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，   *    还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，MyBatis自定义了EntityResolver   *    的实现，达到使用本地DTD文件，从而避免下载网络 DTD 文件的效果。   *   * @see org.apache.ibatis.builder.xml.XMLMapperEntityResolver   */  private EntityResolver entityResolver;  /**   * 变量 Properties对象   */  private Properties variables;  /**   * java XPath对象   *    用于查询xml中的节点和元素   */  private XPath xpath;</code></pre><p>默认情况下，对XML文档进行验证时，会根据XML文档开始位置指定的网址加载对应的<code>DTD</code>文件或者<code>XSD</code>文件。如果是解析<code>mybatis-config.xml</code>配置文件时，默认会加载<code>http://mybatis.org/dtd/mybatis-3-config.dtd</code>这个<code>DTD</code>文件。但是，如果如果每个应用启动都从网络加载该<code>DTD</code>文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，<code>MyBatis</code>自定义了<code>EntityResolver</code>的实现，达到使用本地<code>DTD</code>文件，从而避免下载网络 <code>DTD</code> 文件的效果。<code>XMLMapperEntityResolver</code>是<code>mybatis</code>提供的<code>EntityResolver</code>接口的实现类，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125224446-8JnIIz.png" srcset="undefined" alt=""></p><p><code>EntityResolver</code>接口的核心是<code>resolveEntity()</code>方法，<code>XMLMapperEntityResolver</code>是实现如下所示：</p><pre><code class="java">package org.apache.ibatis.builder.xml;import java.io.IOException;import java.io.InputStream;import java.util.Locale;import org.apache.ibatis.io.Resources;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.SAXException;/** * XML映射器实体解析器 * Offline entity resolver for the MyBatis DTDs. * * @author Clinton Begin * @author Eduardo Macarron */public class XMLMapperEntityResolver implements EntityResolver {  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD的SystemId   */  private static final String IBATIS_CONFIG_SYSTEM = &quot;ibatis-3-config.dtd&quot;;  private static final String IBATIS_MAPPER_SYSTEM = &quot;ibatis-3-mapper.dtd&quot;;  private static final String MYBATIS_CONFIG_SYSTEM = &quot;mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_SYSTEM = &quot;mybatis-3-mapper.dtd&quot;;  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD文件的具体位置   */  private static final String MYBATIS_CONFIG_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;;  /**   * {@link #resolveEntity(String, String)}是{@link EntityResolver} 接口中定义的方法，具体实现如下所示：   *   * Converts a public DTD into a local one.   *   * @param publicId The public id that is what comes after &quot;PUBLIC&quot;   * @param systemId The system id that is what comes after the public id.   * @return The InputSource for the DTD   *   * @throws org.xml.sax.SAXException If anything goes wrong   */  @Override  public InputSource resolveEntity(String publicId, String systemId) throws SAXException {    try {      if (systemId != null) {        String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);        /**         *  查找systemId指定的DTD文档，并调用{@link #getInputSource(String, String, String)}方法读取DTD文档         */        if (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) {          return getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);        } else if (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) {          return getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);        }      }      return null;    } catch (Exception e) {      throw new SAXException(e.toString());    }  }  /**   * 读取DTD文档并形成InputSource对象   * @param path  文件所在路径   * @param publicId    公共标志符   * @param systemId    systemId   * @return InputSource   */  private InputSource getInputSource(String path, String publicId, String systemId) {    InputSource source = null;    if (path != null) {      try {        InputStream in = Resources.getResourceAsStream(path);        source = new InputSource(in);        source.setPublicId(publicId);        source.setSystemId(systemId);      } catch (IOException e) {        // ignore, null is ok      }    }    return source;  }}</code></pre><p>介绍完<code>XMLMapperEntityResolver</code>之后，回到<code>XPathParser</code>的分析。在<code>XPathParser.createDocument()</code>方法中封装了前面介绍的创建<code>Document</code>对象的过程并触发了加载XML文档的过程，具体实现如下：</p><pre><code class="java">/**   * 调用这个方法之前一定要先调用{@link #commonConstructor(boolean, Properties, EntityResolver)}方法完成初始化。   * 将xml解析为Document对象   * @param inputSource   * @return   */  private Document createDocument(InputSource inputSource) {    // important: this must only be called AFTER common constructor    try {      //创建DocumentBuilderFactory对象      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();      //对DocumentBuilderFactory进行一系列的配置      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);      factory.setValidating(validation);      factory.setNamespaceAware(false);      factory.setIgnoringComments(true);      factory.setIgnoringElementContentWhitespace(false);      factory.setCoalescing(false);      factory.setExpandEntityReferences(true);      //创建DocumentBuilder对象并进行配置      DocumentBuilder builder = factory.newDocumentBuilder();      //设置EntityResolver接口对象      builder.setEntityResolver(entityResolver);      builder.setErrorHandler(new ErrorHandler() {        //其中实现的ErrorHandler接口的方法都是空实现        @Override        public void error(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void warning(SAXParseException exception) throws SAXException {          // NOP        }      });      //加载xml文件      return builder.parse(inputSource);    } catch (Exception e) {      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);    }  }/**   * 通用构造：   *    就是通用的赋值操作，主要是的得到一个xpath解析器对document对象进行解析   * @param validation   * @param variables   * @param entityResolver   */  private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) {    this.validation = validation;    this.entityResolver = entityResolver;    this.variables = variables;    XPathFactory factory = XPathFactory.newInstance();    this.xpath = factory.newXPath();  }</code></pre><p><code>XPathParser</code>中提供了一系列的<code>eval*()</code>方法用于解析<code>boolean</code>、<code>short</code>、<code>long</code>、<code>int</code>、<code>String</code>、<code>Node</code>等类型的信息，它通过前面介绍代码中介绍的<code>XPath.evaluate()</code>方法查找指定路径的节点或属性，并进行相应的类型转换。具体的代码比较简单，就不贴出来了，这里需要注意的是<code>XPathParser.evalString()</code><br />方法，其中会调用<code>PropertyParser.parse()</code>方法处理节点中相应的默认值，具体实现如下所示：</p><pre><code class="java"> public String evalString(Object root, String expression) {    String result = (String) evaluate(expression, root, XPathConstants.STRING);    //处理节点中相应的默认值    result = PropertyParser.parse(result, variables);    return result;  }</code></pre><p>在<code>PropertyParser</code>中指定了是否开启默认值的功能以及默认的分隔符，相应字段如下所示：</p><pre><code class="java"> private static final String KEY_PREFIX = &quot;org.apache.ibatis.parsing.PropertyParser.&quot;;  /**   * 在mybatis-config.xml中的&lt;properties&gt;&lt;/properties&gt;节点下配置是否开启默认值功能的对应配置项   * The special property key that indicate whether enable a default value on placeholder.   * &lt;p&gt;   *   The default value is {@code false} (indicate disable a default value on placeholder)   *   If you specify the {@code true}, you can specify key and default value on placeholder (e.g. {@code ${db.username:postgres}}).   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_ENABLE_DEFAULT_VALUE = KEY_PREFIX + &quot;enable-default-value&quot;;  /**   * 配置占位符与默认值之间的默认分隔符的对应配置项   * The special property key that specify a separator for key and default value on placeholder.   * &lt;p&gt;   *   The default separator is {@code &quot;:&quot;}.   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_DEFAULT_VALUE_SEPARATOR = KEY_PREFIX + &quot;default-value-separator&quot;;  /**   * 默认情况下，关闭默认值选项   */  private static final String ENABLE_DEFAULT_VALUE = &quot;false&quot;;  /**   * 默认分隔符是冒号   */  private static final String DEFAULT_VALUE_SEPARATOR = &quot;:&quot;;</code></pre><p><code>PropertyParser.parse()</code>方法中会创建<code>GenericTokenParser解析器，</code>并将默认值的处理委托给<code>GenericTokenParser.parse()</code>方法，实现如下：</p><pre><code class="java">/**   * 当前方法中会创建{@link GenericTokenParser}解析器，并将默认值的处理委托给{@link GenericTokenParser#parse(String)}   * @param string   * @param variables   * @return   */  public static String parse(String string, Properties variables) {    VariableTokenHandler handler = new VariableTokenHandler(variables);    //创建GenericTokenParser对象，并指定其处理的占位符格式为&quot;${}&quot;    GenericTokenParser parser = new GenericTokenParser(&quot;${&quot;, &quot;}&quot;, handler);    return parser.parse(string);  }</code></pre><p><code>GenericTokenParser</code>是一个通用的占位符解析器，其字段的含义如下：</p><pre><code class="java">/**   * 占位符的开始标记   */  private final String openToken;  /**   * 占位符的结束标记   */  private final String closeToken;  /**   * {@link TokenHandler}接口的实现会按照一定的逻辑解析占位符   */  private final TokenHandler handler;</code></pre><p><code>GenericTokenParser.parse()</code>方法的逻辑并不复杂，它会顺序查找<code>openToken</code>和<code>closeToken</code>，解析得到的占位符的字面值，并将其交给<code>TokenHandler</code>处理，然后将解析结果重新拼装成字符串并返回。该方法的实现如下：</p><pre><code class="java">/**   * 此方法的逻辑并不复杂，它会顺序查找{@link #openToken}和{@link #closeToken} ，解析得到占位符的字面值，   * 将将其交给{@link TokenHandler}进行处理，然后将解析结果重新拼装成字符串并返回。   * @param text  拼装之前的字符串   * @return 拼装之后后字符串   */  public String parse(String text) {    //检测text是否为空    if (text == null || text.isEmpty()) {      return &quot;&quot;;    }    // search open token    // 查找开始标记    int start = text.indexOf(openToken);    // 检测start是否为-1    if (start == -1) {      return text;    }    char[] src = text.toCharArray();    int offset = 0;    // builder是用来记录解析后的字符串    final StringBuilder builder = new StringBuilder();    StringBuilder expression = null;    while (start &gt; -1) {      if (start &gt; 0 &amp;&amp; src[start - 1] == &#39;\\&#39;) {        // this open token is escaped. remove the backslash and continue.        // 遇到转移的开始标记，则直接将前面的字符串以及开始标记追加到builder中        builder.append(src, offset, start - offset - 1).append(openToken);        offset = start + openToken.length();      } else {        // found open token. let&#39;s search close token.        // 查找到开始标记，且未转义        if (expression == null) {          expression = new StringBuilder();        } else {          expression.setLength(0);        }        // 将前面的字符串追加到builder中        builder.append(src, offset, start - offset);        offset = start + openToken.length();        // 从offset向后继续查找结束标记        int end = text.indexOf(closeToken, offset);        while (end &gt; -1) {          // 处理转义的结束标记          if (end &gt; offset &amp;&amp; src[end - 1] == &#39;\\&#39;) {            // this close token is escaped. remove the backslash and continue.            expression.append(src, offset, end - offset - 1).append(closeToken);            offset = end + closeToken.length();            end = text.indexOf(closeToken, offset);          } else {            // 将开始标记和结束标记之间的字符串追加到expression中保存            expression.append(src, offset, end - offset);            break;          }        }        //未找到结束标记        if (end == -1) {          // close token was not found.          builder.append(src, start, src.length - start);          offset = src.length;        } else {          //将占位符的字面值交给TokenHandler处理，并将处理结果追加到builder中保存          //最终拼凑出解析后的完整内容          builder.append(handler.handleToken(expression.toString()));          offset = end + closeToken.length();        }      }      //移动start      start = text.indexOf(openToken, offset);    }    if (offset &lt; src.length) {      builder.append(src, offset, src.length - offset);    }    return builder.toString();  }</code></pre><p>占位符有<code>TokenHandler</code>接口的实现进行解析，<code>TokenHandler</code>接口总共有四个实现，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125231024-cKlwtn.png" srcset="undefined" alt=""></p><p>通过对<code>PropertyParser.parse()</code>方法的介绍，我们知道了<code>PropertyParser</code>是使用<code>VariableTokenHandler</code>与<code>GenericTokenParser</code>配合完成占位符解析的，<code>VariableTokenHandler</code>是<code>PropertyReslover</code>中的一个私有静态内部类，其字段的含义如下所示：</p><pre><code class="java"> /**     * &lt;properties&gt;&lt;properties/&gt;节点下定义的键值对，用于替换占位符     */    private final Properties variables;    /**     * 是否支持占位符中使用默认值的功能     */    private final boolean enableDefaultValue;    /**     * 指定占位符和默认值之间的分隔符     */    private final String defaultValueSeparator;</code></pre><p><code>VariableTokenHandler</code>实现了<code>TokenHandler</code>接口中的<code>handlerToken()</code>方法，该实现首先会按照<code>defaultValueSeparator</code>字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值，然后按照切分得到的占位符名称查找对应的值，如果在<code>&lt;properties&gt;</code>节点下未定义相应的键值对，则将切分得到的默认值作为解析结果返回。</p><pre><code class="java">/**     * 实现了{@link TokenHandler}接口中的{@link TokenHandler#handleToken(String)}方法，该实现：     *  1. 首先会按照{@link #defaultValueSeparator}字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值；     *  2. 然后按照切分得到的占位符名称查找对应的值，如果在&lt;properties&gt;&lt;properties/&gt;节点中未定义对应的键值对，     *     则将切分得到的默认值作为解析结果返回。     * @param content     * @return     */    @Override    public String handleToken(String content) {      // 检测variable集合是否为空      if (variables != null) {        String key = content;        //检测是否支持占位符中使用默认值的功能        if (enableDefaultValue) {          // 查找分隔符          final int separatorIndex = content.indexOf(defaultValueSeparator);          String defaultValue = null;          if (separatorIndex &gt;= 0) {            //获取分隔符名称            key = content.substring(0, separatorIndex);            //获取默认值            defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());          }          if (defaultValue != null) {            //在variables集合中查找指定的占位符            return variables.getProperty(key, defaultValue);          }        }        // 不支持默认值的功能，则直接查找variables集合        if (variables.containsKey(key)) {          return variables.getProperty(key);        }      }      //variables集合为空，直接返回      return &quot;${&quot; + content + &quot;}&quot;;    }  }</code></pre><p><code>GenericTokenParser</code>此类不仅用于默认值解析<code>PropertyParser#parse(String, Properties)</code>，还会在动态<code>SQL</code>语句的解析中用到。很明显，<code>GenericTokenParser</code>只是查找到指定的占位符，而具体的解析行为会根据持有的TokenHandler实现的不同而不同，这有点策略模式的意思。<br />回到对<code>XPathParser</code>的分析，<code>XPathParser.evalNode()</code>方法返回值类型是XNode，它对<code>org.w3c.dom.Node</code>对象做了封装和解析，其各个字段的含义如下：</p><pre><code class="java">  /**   * org.w3c.dom.Node对象   */  private final Node node;  /**   * Node节点名称   */  private final String name;  /**   * Node节点内容   */  private final String body;  /**   * 节点属性集合   */  private final Properties attributes;  /**   * mybatis-config.xml配置文件中&lt;properties&gt;&lt;properties/&gt;节点下定义的键值对   */  private final Properties variables;  /**   * XPathParser对象，该Node对象由此XPathParser对象生成   */  private final XPathParser xpathParser;</code></pre><p><code>XNode</code>的构造函数中会调用其<code>parseAttributes()</code>方法和<code>parseBody()</code>方法解析<code>org.w3c.dom.Node</code>对象中的信息，初始化<code>attributes</code>集合和<code>body</code>字段，具体初始化过程如下：</p><pre><code class="java">/**   * 解析Node对象中的Attributes属性集合   * @param n 节点对象   * @return   */  private Properties parseAttributes(Node n) {    Properties attributes = new Properties();    //获取节点的属性结合    NamedNodeMap attributeNodes = n.getAttributes();    if (attributeNodes != null) {      for (int i = 0; i &lt; attributeNodes.getLength(); i++) {        Node attribute = attributeNodes.item(i);        //使用PropertyParser处理每一个属性中的占位符        String value = PropertyParser.parse(attribute.getNodeValue(), variables);        attributes.put(attribute.getNodeName(), value);      }    }    return attributes;  }/**   * 解析Node对象中的信息body字段   * @param node   * @return   */  private String parseBody(Node node) {    String data = getBodyData(node);    //当前节点不是文本节点    if (data == null) {       //处理子节点      NodeList children = node.getChildNodes();      for (int i = 0; i &lt; children.getLength(); i++) {        Node child = children.item(i);        data = getBodyData(child);        if (data != null) {          break;        }      }    }    return data;  }  private String getBodyData(Node child) {    //只处理文本内容    if (child.getNodeType() == Node.CDATA_SECTION_NODE        || child.getNodeType() == Node.TEXT_NODE) {      String data = ((CharacterData) child).getData();      //使用PropertyParser处理文本节点中的占位符      data = PropertyParser.parse(data, variables);      return data;    }    return null;  }</code></pre><p>XPathParser测试用例</p><pre><code class="java">import org.apache.ibatis.builder.xml.XMLMapperEntityResolver;import org.apache.ibatis.io.Resources;import org.apache.ibatis.parsing.XNode;import org.apache.ibatis.parsing.XPathParser;import java.io.IOException;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 16:11 */public class XPathParserTest {  public static void main(String[] args) throws IOException {    String resource = &quot;resources/xpath-demo.xml&quot;;    XPathParser xPathParser = new XPathParser(Resources.getResourceAsReader(resource),true,null,new XMLMapperEntityResolver());    XNode xNode = xPathParser.evalNode(&quot;/configuration&quot;);    List&lt;XNode&gt; children = xNode.getChildren();    for (int i = 0; i &lt; children.size(); i++) {      System.out.println(children.get(i).getName());    }  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2保存密码登录</title>
    <link href="undefinedMac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html"/>
    <url>Mac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html</url>
    
    <content type="html"><![CDATA[<h1 id="iterm2保存密码登录"><a href="#iterm2保存密码登录" class="headerlink" title="iterm2保存密码登录"></a>iterm2保存密码登录</h1><h2 id="1-编写item2login-sh脚本文件"><a href="#1-编写item2login-sh脚本文件" class="headerlink" title="1. 编写item2login.sh脚本文件"></a>1. 编写<code>item2login.sh</code>脚本文件</h2><pre><code class="shell">#!/usr/bin/expect  set timeout 30  spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]  expect {         &quot;(yes/no)?&quot;         {send &quot;yes\n&quot;;exp_continue}         &quot;password:&quot;         {send &quot;[lindex $argv 3]\n&quot;}  }  interact </code></pre><ul><li><p>lindex $argv 0 : port</p></li><li><p>lindex $argv 1：username</p></li><li><p>lindex $argv 2：IP</p></li><li><p>lindex $argv 3：password</p></li></ul><h2 id="2-修改item2login-sh权限"><a href="#2-修改item2login-sh权限" class="headerlink" title="2. 修改item2login.sh权限"></a>2. 修改<code>item2login.sh</code>权限</h2><p>将<code>item2login.sh</code>移动到<code>/usr/local/bin</code>目录下，然后使用<code>chmod 777 item2login.sh</code>修改脚本权限；</p><h2 id="3-在iterm2中添加信息"><a href="#3-在iterm2中添加信息" class="headerlink" title="3. 在iterm2中添加信息"></a>3. 在iterm2中添加信息</h2><p>打开iterm2的<code>Profiles</code>–&gt;<code>Open Profiles...</code>–&gt;<code>Edit Profiles...</code>–&gt;<code>+</code></p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204208-mTkAoN.png" srcset="undefined" alt=""></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>然后就可以选取要登录的服务器了，效果如下所示（因为是测试服务所以没有连接）：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204211-HHVeUW.png" srcset="undefined" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Mac技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>