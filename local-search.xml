<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>反射工具箱</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html</url>
    
    <content type="html"><![CDATA[<h1 id="反射工具箱"><a href="#反射工具箱" class="headerlink" title="反射工具箱"></a>反射工具箱</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​        Mybatis在进行参数处理、结果集映射等操作时，会涉及大量的反射操作。Java中的反射虽然功能强大，但是代码编写起来比较复杂容易出错，为了简化反射操作的相关代码，Mybatis提供了专门的反射模块，该模块位于<code>org.apache.ibatis.reflection</code>包中，它对常见的反射操作做了封装，提供了更加简洁方便的反射API。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126092626-rve1an.png" srcset="undefined" style="zoom:67%;" /><h1 id="2-Reflector-amp-ReflectorFactory"><a href="#2-Reflector-amp-ReflectorFactory" class="headerlink" title="2. Reflector&amp;ReflectorFactory"></a>2. Reflector&amp;ReflectorFactory</h1><h2 id="2-1-Reflector"><a href="#2-1-Reflector" class="headerlink" title="2.1. Reflector"></a>2.1. Reflector</h2><p>​         <code>Reflector</code>是<code>Mybatis</code>中反射模块的基础，每个<code>Reflector</code>对象都对应一个类，在Reflector中缓存了反射操作需要使用的类的元信息。Reflector中各个字段的含义如下所示：</p><pre><code class="java">/**   * 对应类的类型   */  private final Class&lt;?&gt; type;  /**   * 可读属性的名称集合，可读属性就是存在相应的getter方法的属性，初始值为空数组   */  private final String[] readablePropertyNames;  /**   * 可写属性的名称集合，可写属性就是存在相应setter方法的属性，初始值为空数组   */  private final String[] writablePropertyNames;  /**   * 记录了属性相应的setter方法，key是属性名称，value是Invoke对象，它是对setter方法对应Method对象的封装，后面会详细介绍   */  private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法集合，key是属性名称，value是Invoke对象，   */  private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法的返回值类型，key是属性名称，value是getter方法的返回值类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;();  /**   * 记录了默认的构造方法   */  private Constructor&lt;?&gt; defaultConstructor;  /**   * 记录了所有属性名称的集合   */  private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;();</code></pre><p>​        在<code>Reflector</code>的构造方法中会解析指定的<code>Class</code>对象，并填充上述集合，具体实现如下所示：</p><pre><code class="java">/**   * 此构造方法中会解析指定的Class对象，并填充上述集合   * @param clazz 需要解析的Class对象   */  public Reflector(Class&lt;?&gt; clazz) {    //初始化type字段    type = clazz;    //查找clazz的默认构造方法（无参构造方法），具体实现是通过反射遍历所有构造方法    addDefaultConstructor(clazz);    //处理clazz中的getter方法，填充getMethods集合和getTypes集合    addGetMethods(clazz);    //处理clazz中的setter方法，填充setMethods集合和setTypes集合    addSetMethods(clazz);    //处理没有getter/setter方法的字段    addFields(clazz);    //根据getMethods和setMethods集合，初始化可读、可写属性的名称集合    readablePropertyNames = getMethods.keySet().toArray(new String[0]);    writablePropertyNames = setMethods.keySet().toArray(new String[0]);    //初始化caseInsensitivePropertyMap，其中记录了所有大写格式的属性名称    for (String propName : readablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }    for (String propName : writablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }  }</code></pre><p>​        以上代码中<code>addDefaultConstructor(clazz);</code>很是简单，所以没有必要去分析这个方法，其次就是<code>addGetMethods(clazz);</code>和<code>addSetMethods(clazz);</code>方法，<code>Reflector.addGetMethods()</code>方法主要腹泻解析类中定义的<code>getter</code>方法，<code>Reflector.addSetMethods()</code>方法负责解析类中的<code>setter</code>方法，两者的逻辑类似，这里以<code>addSetMethods(clazz);</code>方法为例进行介绍，<code>addSetMethods()</code>方法不做详细介绍，<code>Reflector.addGetMethods()</code>主要有如下三个核心步骤：</p><pre><code class="java">/**   * 负责解析类中的get方法   * @param clazz   */  private void addGetMethods(Class&lt;?&gt; clazz) {    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;&gt;();    /**     * 1. 调用{@link Reflector#getClassMethods(Class)} 方法获取当前类以及其父类中定义的所有方法的唯一签名以及相应的Method对象。     */    Method[] methods = getClassMethods(clazz);    /**     * 2. 按照JavaBean的规范，从Reflector#getClassMethods(Class)方法返回的Methods数组中查找该类中定义的getter方法，     *    将其记录在conflictingGetters集合中，conflictingGetters集合（ Map&lt;String, List&lt;Method&gt;&gt;类型）的key为属性名称，value是该属性对应的getter方法集合。     *     *    2.1. 具体步骤     *      2.1.1. 得到所有的get方法，（参数类别为空，标志是get的方法）；     *      2.1.2. 将得到的get方法添加到方法冲突集合中；     *          例如：父类 public List&lt;User&gt; getUserList(); 子类 public ArrayList&lt;User&gt; getUserList();     *               在进行{@link Reflector#getClassMethods(Class)}中的{@link Reflector#getSignature(Method)}返回结果是：     *               java.util.List#getUserList和java.util.ArrayList#getUserList，即得到两个方法签名，在{@link Reflector#addUniqueMethods(Map, Method[])}     *               方法中会被认为是两个不同的方法添加到 uniqueMethods集合中，这显然不是我们想要的结果。     *     *  所以后续步骤3 会去解决这种Getter方法的冲突。     *     *  (lambda表达式 :filter forEach )     */    Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));    /**     * 3. 解决Getter冲突     *   1. 为什么会产生冲突呢？     *      步骤2已经解释过为什么会产生冲突了。     *   2. 解决方式是什么？     */    resolveGetterConflicts(conflictingGetters);  }</code></pre><ul><li><p>首先，调用<code>Reflector.getClassMethods()</code>方法获取当前类及其父类中定义的所以方法的唯一签名以及相应的<code>Methods</code>对象。</p><pre><code class="java">private Method[] getClassMethods(Class&lt;?&gt; clazz) {    Map&lt;String, Method&gt; uniqueMethods = new HashMap&lt;&gt;();    Class&lt;?&gt; currentClass = clazz;    while (currentClass != null &amp;&amp; currentClass != Object.class) {      //记录currentClass这个类中定义的全部方法      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());      // we also need to look for interface methods -      // because the class may be abstract      // 记录接口中定义的方法      Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();      for (Class&lt;?&gt; anInterface : interfaces) {        addUniqueMethods(uniqueMethods, anInterface.getMethods());      }      //获取父类，继续while循环      currentClass = currentClass.getSuperclass();    }    Collection&lt;Method&gt; methods = uniqueMethods.values();    //转换成Methods方法数组返回    return methods.toArray(new Method[0]);  }</code></pre><p>在<code>Reflector.addUniqueMethods()</code>方法中会为每个方法生成唯一签名，并记录到<code>uniqueMethods</code>集合中，具体实现如下所示：</p><pre><code class="java"> /**   * 为每个方法生成一个唯一签名，并记录到uniqueMethods集合中   * @param uniqueMethods   * @param methods   */  private void addUniqueMethods(Map&lt;String, Method&gt; uniqueMethods, Method[] methods) {    for (Method currentMethod : methods) {      if (!currentMethod.isBridge()) {        /**         * 通过{@link Reflector#getSignature(Method)}方法得到方法的签名是：返回值类型#方法名称：参数类型列表。         * 例如： Reflector.getSignature(Method)的方法签名是：java.lang.String#getSignature:java.lang.reflect.Method         * 通过Reflector.getSignature(Method)方法得到的方法签名是全局唯一的，可以作为该方法的唯一标识         */        String signature = getSignature(currentMethod);        // check to see if the method is already known        // if it is known, then an extended class must have        // overridden a method        /**         * 检查是否添加过该方法，如果添加过，就无须在向uniqueMethods中添加该方法了。         * 其实这个段代码，如果细品有另一种意思：         *    因为addUniqueMethods方法在{@link Reflector#getClassMethods(Class)}中的while循环被调用了，一次循环被调用两次，         *    这两次调用：先是子类调用，然后是父类接口调用，         * 所以这里检查是否添加过该方法的另一层含义是：         *    检测是否在子类中已经添加过该方法，如果在子类中添加过，则表示子类覆盖了该方法，无须再向uniqueMethods集合中添加该方法了。         *         */        if (!uniqueMethods.containsKey(signature)) {          //记录该签名和方法的对应关系          uniqueMethods.put(signature, currentMethod);        }      }    }  }</code></pre></li><li><p>然后，按照<code>JavaBean</code>的规范，从<code>Reflector.getClassMethods()</code>返回的Method数组中查找该类中定义的<code>getter</code>方法（具体哪些方法算是<code>getter</code>方法，后面会详细介绍），将其记录到<code>conflictingGetters</code>集合中。<code>conflictingGetters</code>集合（<code>Map&lt;String, List&lt;Method&gt;&gt;</code>类型）的<code>key</code>是属性名称，<code>value</code>是该属性对应的<code>getter</code>方法集合。</p><pre><code class="java">//Reflector.javaArrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));</code></pre><pre><code class="java">//Reflector.java/**   * 添加方法冲突   * @param conflictingMethods   * @param name   * @param method   *   */  private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) {    if (isValidPropertyName(name)) {      /**       * {@link Map#computeIfAbsent(Object, Function)}       * @see red.reksai.reflection.ComputeIfAbsentTest   map jdk1.8新特性       */      List&lt;Method&gt; list = conflictingMethods.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;());      list.add(method);    }  }</code></pre><pre><code class="java">//PropertyNamer.java/**   * 根据Javabean的规范，获取对应的属性名称   * @param name   * @return   */  public static String methodToProperty(String name) {    if (name.startsWith(&quot;is&quot;)) {      name = name.substring(2);    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {      name = name.substring(3);    } else {      throw new ReflectionException(&quot;Error parsing property name &#39;&quot; + name + &quot;&#39;.  Didn&#39;t start with &#39;is&#39;, &#39;get&#39; or &#39;set&#39;.&quot;);    }    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {      name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);    }    return name;  }</code></pre></li><li><p>当子类覆盖了父类的getter方法且返回值发生变化时，在步骤1中就会产生两个签名不用的方法。</p><ul><li>例如：</li></ul><pre><code class="java">import org.apache.ibatis.reflection.Reflector;import java.util.ArrayList;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/26 10:19 */public class ReflectorTest {  public static void main(String[] args) {    Reflector reflector = new Reflector(User.class);    System.out.println(reflector);  }}class  User extends Person{  public User() {  }  public User(String userName, String passWord) {    this.userName = userName;    this.passWord = passWord;  }  private String userName ;  private String passWord ;  public String getUserName() {    return userName;  }  public void setUserName(String userName) {    this.userName = userName;  }  public String getPassWord() {    return passWord;  }  public void setPassWord(String passWord) {    this.passWord = passWord;  }  public boolean isStatus() {    return super.getStatus() ;  }  @Override  public void setStatus(boolean status) {    super.setStatus(status);  }  @Override  public ArrayList&lt;Items&gt; getList() {    return (ArrayList&lt;Items&gt;) super.getList();  }  @Override  public void setList(List&lt;Items&gt; list) {    super.setList(list);  }}class Person {  private List&lt;Items&gt; list;  private boolean status ;  public boolean getStatus() {    return status;  }  public void setStatus(boolean status) {    this.status = status;  }  public List&lt;Items&gt; getList() {    return list;  }  public void setList(List&lt;Items&gt; list) {    this.list = list;  }  public Person() {  }  public Person(List&lt;Items&gt; list) {    this.list = list;  }}class Items{  private String itmeId;  private String itmeName ;}</code></pre><ul><li>在以下位置打断点</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233022-6FOt8I.png" srcset="undefined" alt=""></p><ul><li>观察conflictingGetters集合中的值，如下所示：</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233326-2wTK6y.png" srcset="undefined" alt=""></p><p>其中属性名称为<code>list</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，这就是因为<code>User</code>在覆盖<code>Person</code>中的<code>getList()</code>方法是返回值从<code>List</code>变成了<code>ArrayList</code>，又因为生成方法签名的规则如下所示，所以就造成了有两个不同方法签名的方法被添加到了<code>uniqueMethods</code>集合中，这不是我们想要的结果。</p><pre><code class="java">// Reflector.java/**   * 生成方法签名   * @param method   * @return   */  private String getSignature(Method method) {    StringBuilder sb = new StringBuilder();    Class&lt;?&gt; returnType = method.getReturnType();    if (returnType != null) {      sb.append(returnType.getName()).append(&#39;#&#39;);    }    sb.append(method.getName());    Class&lt;?&gt;[] parameters = method.getParameterTypes();    for (int i = 0; i &lt; parameters.length; i++) {      sb.append(i == 0 ? &#39;:&#39; : &#39;,&#39;).append(parameters[i].getName());    }    return sb.toString();  }</code></pre><p>其中属性为<code>status</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，一个是父类中的<code>boolean getStatus()</code>，另一个是子类中的 <code>boolean isStatus()</code>（涉及到JavaBean规范），说白了此时<code>uniqueMethods</code>集合中也有两个，这也不是我们想要的结果。</p></li><li><p>所以步骤3会调用<code>Reflector.resolveGetterConflicts(conflictingGetters)</code>方法对步骤2中这种覆写的情况进行处理，同时会将处理得到的<code>getter</code>方法记录到<code>getMethods</code>集合中，并将其返回值类型填充到<code>getTypes</code>集合中，<code>Reflector.resolveGetterConflicts()</code>方法的具体实现如下所示：</p></li></ul><pre><code class="Java"> //Reflector.java /**   * 解决get方法的冲突，同时会将处理得到的getter方法记录到getMethods集合中，并将其返回值类型填充到getTypes集合中   * @param conflictingGetters   */  private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) {    //遍历conflictingGetters集合    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) {      //优胜Method对象      Method winner = null;      //方法名称      String propName = entry.getKey();      boolean isAmbiguous = false;      // candidate 候选Method对象      for (Method candidate : entry.getValue()) {        //如果优胜对象为空，这时候将候选对象复制给优胜对象        if (winner == null) {          winner = candidate;          // continue是跳过当次循环中剩下的语句，执行下一次循环          continue;        }        //获取优胜者返回值类型        Class&lt;?&gt; winnerType = winner.getReturnType();        //获取候选者返回值类型        Class&lt;?&gt; candidateType = candidate.getReturnType();        /**         * 如果返回值类型相同，就要判断返回值是不是boolean？为什么要判断是不是boolean呢？         */        if (candidateType.equals(winnerType)) {          //如果返回值不是boolean直接          if (!boolean.class.equals(candidateType)) {            isAmbiguous = true;            //break只能跳出1层循环            break;          } else if (candidate.getName().startsWith(&quot;is&quot;)) {            winner = candidate;          }        }        /**         * @see red.reksai.javabase.IsAssignableFromTest         * 判断返回值类型有三种情况：         *  1. 候选者是优胜者的父类，不做任何操作，最终返回子类就行         *  2. 优胜者是候选者的父类，这时候先要将候选者赋值给优胜者，然后返回         *  3. 返回值相同，二义性，         */        else if (candidateType.isAssignableFrom(winnerType)) {          // OK getter type is descendant        } else if (winnerType.isAssignableFrom(candidateType)) {          winner = candidate;        } else {          isAmbiguous = true;          break;        }      }      //该字段只有一个getter方法，直接添加到getMethods集合并填充getTypes集合      addGetMethod(propName, winner, isAmbiguous);    }  }</code></pre><p>正如上面描述的那样，在<code>Reflector.addGetMethod(propName, winner, isAmbiguous);</code>方法中完成了对<code>getMethods</code>集合和<code>getType</code>集合的填充，具体实现如下所示：</p><pre><code class="java">  private void addGetMethod(String name, Method method, boolean isAmbiguous) {    /**     * 验证：     *    1. 如果有含糊不清的直接报错，     *    2. 如果验证通过，则进行方法的封装     */    MethodInvoker invoker = isAmbiguous        ? new AmbiguousMethodInvoker(method, MessageFormat.format(            &quot;Illegal overloaded getter method with ambiguous type for property &#39;&#39;{0}&#39;&#39; in class &#39;&#39;{1}&#39;&#39;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;,            name, method.getDeclaringClass().getName()))        : new MethodInvoker(method);    getMethods.put(name, invoker);    /**     * 获取返回值的Type ，{@link TypeParameterResolver}     */    Type returnType = TypeParameterResolver.resolveReturnType(method, type);    getTypes.put(name, typeToClass(returnType));  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析器模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​    解析器模块，对应的包是<code>parsing，</code>如下图所示：</p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191126003045-GKXnIt.png" srcset="undefined" style="zoom:50%;" /><p>解析器模块，主要提供了两个功能：</p><ul><li>对XPath进行封装，为Mybatis初始化时解析<code>mybatis-config.xml</code>配置文件以及<code>mapper</code>映射配置文件提供支持。</li><li>为处理动态SQL语句中的占位符提供支持。</li></ul><h1 id="2-XML解析方式"><a href="#2-XML解析方式" class="headerlink" title="2. XML解析方式"></a>2. XML解析方式</h1><p>在mybatis中涉及到多个XML配置文件，因此我们首先要介绍XML解析的相关内容。XML解析的常见的方式有三种：</p><ul><li>DOM（document object model）解析方式</li><li>SAX（simple api for xml）解析方式</li><li>Java6版本开始，JDK致辞的StAX（streaming api for xml）解析方式。</li></ul><p>DOM是基于树形结构的XML解析方式，它将整个XML文档读入内存并构建成一个DOM树,基于这棵树形结构对各个节点（node）进行操作。XML文档中的每一个成分都是一个节点：整个文档是一个文档节点，每个XML标签对应一个元素节点，包含在XML标签中的文本是文本节点，每一个XML属性是一个属性节点，注释属于注释节点。</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>解析后得到的树形结构为：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125100550-l1ZKVS.png" srcset="undefined" alt=""></p><h1 id="3-XPath"><a href="#3-XPath" class="headerlink" title="3. XPath"></a>3. XPath</h1><p>​        mybatis在初始化过程中处理mybatis-config.xml配置文件以及映射文件时，使用的是DOM解析方式，并结合XPath解析xml配置文件，正如前文所述，DOM会对整个XML文档加载到内存中形成树形数据结构，而xpth是一种为查询XML文档而设计的语言，它可以与DOM解析方式配合使用，实现对XML文档的解析。xpath之于XML就好比SQL语言之于数据库。</p><p>​        代码示例：</p><pre><code class="java">import org.apache.ibatis.io.Resources;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.ErrorHandler;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.xpath.*;import java.io.IOException;import java.io.InputStream;/** * XPath解析测试 {@link javax.xml.xpath.XPath} * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 10:11 */public class XPathTest {  public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {    //创建DOM解析器工厂    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();    //开启验证    documentBuilderFactory.setValidating(true);    documentBuilderFactory.setNamespaceAware(false);    documentBuilderFactory.setIgnoringComments(true);    documentBuilderFactory.setIgnoringElementContentWhitespace(false);    documentBuilderFactory.setCoalescing(false);    documentBuilderFactory.setExpandEntityReferences(true);    //得到一个DOM解析器对象    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();    documentBuilder.setErrorHandler(new ErrorHandler() {      @Override      public void warning(SAXParseException exception) throws SAXException {        System.out.println(&quot;warning&quot; + exception.getMessage());      }      @Override      public void error(SAXParseException exception) throws SAXException {        System.out.println(&quot;error&quot; + exception.getMessage());      }      @Override      public void fatalError(SAXParseException exception) throws SAXException {        System.out.println(&quot;fatalError&quot; + exception.getMessage());      }    });    String resource = &quot;resources/xpath-demo.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    //解析xml    Document document = documentBuilder.parse(inputStream);    XPathFactory xPathFactory = XPathFactory.newInstance();    XPath xPath = xPathFactory.newXPath();    XPathExpression xPathExpression = xPath.compile(&quot;/configuration/mappers/mapper&quot;);    NodeList evaluate = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);    for (int i = 0; i &lt; evaluate.getLength() ; i++) {      Node node = evaluate.item(i);      String nodeName = node.getNodeName();      if ((&quot;mapper&quot;).equals(node.getNodeName())){        Node attributeNode = node.getAttributes().getNamedItem(&quot;resource&quot;);        String nodeValue1 = attributeNode.getNodeValue();        System.out.println(nodeName +&quot;......&quot;+nodeValue1);      }    }  }}</code></pre><p>运行结果：</p><pre><code class="java">mapper......org/mybatis/example/BlogMapper.xmlmapper......org/mybatis/example/UserMapper.xml</code></pre><h1 id="4-XPathParser"><a href="#4-XPathParser" class="headerlink" title="4. XPathParser"></a>4. XPathParser</h1><p>Mybatis提供的<code>org.apache.ibatis.parsing.XPathParser</code>类封装了前面涉及到的<code>XPath</code>、<code>Document</code>和<code>EntityResolver</code>，如图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125223756-R177Lc.png" srcset="undefined" alt=""></p><p>XPathParser中各个字段的含义和功能如下所示：</p><pre><code class="java">  /**   * xml document 对象   */  private final Document document;  /**   * 是否开启校验xml   */  private boolean validation;  /**   * 用于加载本地DTD文件   *   * xml实体解析器，默认情况下，对XML校验是，会基于xml文档开始位置定义的DTD文件或者XSD文件，   * 例如：   *    解析mybatis-config.xml配置文件时，会加载http://mybatis.org/dtd/mybatis-3-config.dtd这个DTD文件。   *    但是，如果如果每个应用启动都从网络加载该DTD文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，   *    还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，MyBatis自定义了EntityResolver   *    的实现，达到使用本地DTD文件，从而避免下载网络 DTD 文件的效果。   *   * @see org.apache.ibatis.builder.xml.XMLMapperEntityResolver   */  private EntityResolver entityResolver;  /**   * 变量 Properties对象   */  private Properties variables;  /**   * java XPath对象   *    用于查询xml中的节点和元素   */  private XPath xpath;</code></pre><p>默认情况下，对XML文档进行验证时，会根据XML文档开始位置指定的网址加载对应的<code>DTD</code>文件或者<code>XSD</code>文件。如果是解析<code>mybatis-config.xml</code>配置文件时，默认会加载<code>http://mybatis.org/dtd/mybatis-3-config.dtd</code>这个<code>DTD</code>文件。但是，如果如果每个应用启动都从网络加载该<code>DTD</code>文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，<code>MyBatis</code>自定义了<code>EntityResolver</code>的实现，达到使用本地<code>DTD</code>文件，从而避免下载网络 <code>DTD</code> 文件的效果。<code>XMLMapperEntityResolver</code>是<code>mybatis</code>提供的<code>EntityResolver</code>接口的实现类，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125224446-8JnIIz.png" srcset="undefined" alt=""></p><p><code>EntityResolver</code>接口的核心是<code>resolveEntity()</code>方法，<code>XMLMapperEntityResolver</code>是实现如下所示：</p><pre><code class="java">package org.apache.ibatis.builder.xml;import java.io.IOException;import java.io.InputStream;import java.util.Locale;import org.apache.ibatis.io.Resources;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.SAXException;/** * XML映射器实体解析器 * Offline entity resolver for the MyBatis DTDs. * * @author Clinton Begin * @author Eduardo Macarron */public class XMLMapperEntityResolver implements EntityResolver {  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD的SystemId   */  private static final String IBATIS_CONFIG_SYSTEM = &quot;ibatis-3-config.dtd&quot;;  private static final String IBATIS_MAPPER_SYSTEM = &quot;ibatis-3-mapper.dtd&quot;;  private static final String MYBATIS_CONFIG_SYSTEM = &quot;mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_SYSTEM = &quot;mybatis-3-mapper.dtd&quot;;  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD文件的具体位置   */  private static final String MYBATIS_CONFIG_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;;  /**   * {@link #resolveEntity(String, String)}是{@link EntityResolver} 接口中定义的方法，具体实现如下所示：   *   * Converts a public DTD into a local one.   *   * @param publicId The public id that is what comes after &quot;PUBLIC&quot;   * @param systemId The system id that is what comes after the public id.   * @return The InputSource for the DTD   *   * @throws org.xml.sax.SAXException If anything goes wrong   */  @Override  public InputSource resolveEntity(String publicId, String systemId) throws SAXException {    try {      if (systemId != null) {        String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);        /**         *  查找systemId指定的DTD文档，并调用{@link #getInputSource(String, String, String)}方法读取DTD文档         */        if (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) {          return getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);        } else if (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) {          return getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);        }      }      return null;    } catch (Exception e) {      throw new SAXException(e.toString());    }  }  /**   * 读取DTD文档并形成InputSource对象   * @param path  文件所在路径   * @param publicId    公共标志符   * @param systemId    systemId   * @return InputSource   */  private InputSource getInputSource(String path, String publicId, String systemId) {    InputSource source = null;    if (path != null) {      try {        InputStream in = Resources.getResourceAsStream(path);        source = new InputSource(in);        source.setPublicId(publicId);        source.setSystemId(systemId);      } catch (IOException e) {        // ignore, null is ok      }    }    return source;  }}</code></pre><p>介绍完<code>XMLMapperEntityResolver</code>之后，回到<code>XPathParser</code>的分析。在<code>XPathParser.createDocument()</code>方法中封装了前面介绍的创建<code>Document</code>对象的过程并触发了加载XML文档的过程，具体实现如下：</p><pre><code class="java">/**   * 调用这个方法之前一定要先调用{@link #commonConstructor(boolean, Properties, EntityResolver)}方法完成初始化。   * 将xml解析为Document对象   * @param inputSource   * @return   */  private Document createDocument(InputSource inputSource) {    // important: this must only be called AFTER common constructor    try {      //创建DocumentBuilderFactory对象      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();      //对DocumentBuilderFactory进行一系列的配置      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);      factory.setValidating(validation);      factory.setNamespaceAware(false);      factory.setIgnoringComments(true);      factory.setIgnoringElementContentWhitespace(false);      factory.setCoalescing(false);      factory.setExpandEntityReferences(true);      //创建DocumentBuilder对象并进行配置      DocumentBuilder builder = factory.newDocumentBuilder();      //设置EntityResolver接口对象      builder.setEntityResolver(entityResolver);      builder.setErrorHandler(new ErrorHandler() {        //其中实现的ErrorHandler接口的方法都是空实现        @Override        public void error(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void warning(SAXParseException exception) throws SAXException {          // NOP        }      });      //加载xml文件      return builder.parse(inputSource);    } catch (Exception e) {      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);    }  }/**   * 通用构造：   *    就是通用的赋值操作，主要是的得到一个xpath解析器对document对象进行解析   * @param validation   * @param variables   * @param entityResolver   */  private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) {    this.validation = validation;    this.entityResolver = entityResolver;    this.variables = variables;    XPathFactory factory = XPathFactory.newInstance();    this.xpath = factory.newXPath();  }</code></pre><p><code>XPathParser</code>中提供了一系列的<code>eval*()</code>方法用于解析<code>boolean</code>、<code>short</code>、<code>long</code>、<code>int</code>、<code>String</code>、<code>Node</code>等类型的信息，它通过前面介绍代码中介绍的<code>XPath.evaluate()</code>方法查找指定路径的节点或属性，并进行相应的类型转换。具体的代码比较简单，就不贴出来了，这里需要注意的是<code>XPathParser.evalString()</code><br />方法，其中会调用<code>PropertyParser.parse()</code>方法处理节点中相应的默认值，具体实现如下所示：</p><pre><code class="java"> public String evalString(Object root, String expression) {    String result = (String) evaluate(expression, root, XPathConstants.STRING);    //处理节点中相应的默认值    result = PropertyParser.parse(result, variables);    return result;  }</code></pre><p>在<code>PropertyParser</code>中指定了是否开启默认值的功能以及默认的分隔符，相应字段如下所示：</p><pre><code class="java"> private static final String KEY_PREFIX = &quot;org.apache.ibatis.parsing.PropertyParser.&quot;;  /**   * 在mybatis-config.xml中的&lt;properties&gt;&lt;/properties&gt;节点下配置是否开启默认值功能的对应配置项   * The special property key that indicate whether enable a default value on placeholder.   * &lt;p&gt;   *   The default value is {@code false} (indicate disable a default value on placeholder)   *   If you specify the {@code true}, you can specify key and default value on placeholder (e.g. {@code ${db.username:postgres}}).   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_ENABLE_DEFAULT_VALUE = KEY_PREFIX + &quot;enable-default-value&quot;;  /**   * 配置占位符与默认值之间的默认分隔符的对应配置项   * The special property key that specify a separator for key and default value on placeholder.   * &lt;p&gt;   *   The default separator is {@code &quot;:&quot;}.   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_DEFAULT_VALUE_SEPARATOR = KEY_PREFIX + &quot;default-value-separator&quot;;  /**   * 默认情况下，关闭默认值选项   */  private static final String ENABLE_DEFAULT_VALUE = &quot;false&quot;;  /**   * 默认分隔符是冒号   */  private static final String DEFAULT_VALUE_SEPARATOR = &quot;:&quot;;</code></pre><p><code>PropertyParser.parse()</code>方法中会创建<code>GenericTokenParser解析器，</code>并将默认值的处理委托给<code>GenericTokenParser.parse()</code>方法，实现如下：</p><pre><code class="java">/**   * 当前方法中会创建{@link GenericTokenParser}解析器，并将默认值的处理委托给{@link GenericTokenParser#parse(String)}   * @param string   * @param variables   * @return   */  public static String parse(String string, Properties variables) {    VariableTokenHandler handler = new VariableTokenHandler(variables);    //创建GenericTokenParser对象，并指定其处理的占位符格式为&quot;${}&quot;    GenericTokenParser parser = new GenericTokenParser(&quot;${&quot;, &quot;}&quot;, handler);    return parser.parse(string);  }</code></pre><p><code>GenericTokenParser</code>是一个通用的占位符解析器，其字段的含义如下：</p><pre><code class="java">/**   * 占位符的开始标记   */  private final String openToken;  /**   * 占位符的结束标记   */  private final String closeToken;  /**   * {@link TokenHandler}接口的实现会按照一定的逻辑解析占位符   */  private final TokenHandler handler;</code></pre><p><code>GenericTokenParser.parse()</code>方法的逻辑并不复杂，它会顺序查找<code>openToken</code>和<code>closeToken</code>，解析得到的占位符的字面值，并将其交给<code>TokenHandler</code>处理，然后将解析结果重新拼装成字符串并返回。该方法的实现如下：</p><pre><code class="java">/**   * 此方法的逻辑并不复杂，它会顺序查找{@link #openToken}和{@link #closeToken} ，解析得到占位符的字面值，   * 将将其交给{@link TokenHandler}进行处理，然后将解析结果重新拼装成字符串并返回。   * @param text  拼装之前的字符串   * @return 拼装之后后字符串   */  public String parse(String text) {    //检测text是否为空    if (text == null || text.isEmpty()) {      return &quot;&quot;;    }    // search open token    // 查找开始标记    int start = text.indexOf(openToken);    // 检测start是否为-1    if (start == -1) {      return text;    }    char[] src = text.toCharArray();    int offset = 0;    // builder是用来记录解析后的字符串    final StringBuilder builder = new StringBuilder();    StringBuilder expression = null;    while (start &gt; -1) {      if (start &gt; 0 &amp;&amp; src[start - 1] == &#39;\\&#39;) {        // this open token is escaped. remove the backslash and continue.        // 遇到转移的开始标记，则直接将前面的字符串以及开始标记追加到builder中        builder.append(src, offset, start - offset - 1).append(openToken);        offset = start + openToken.length();      } else {        // found open token. let&#39;s search close token.        // 查找到开始标记，且未转义        if (expression == null) {          expression = new StringBuilder();        } else {          expression.setLength(0);        }        // 将前面的字符串追加到builder中        builder.append(src, offset, start - offset);        offset = start + openToken.length();        // 从offset向后继续查找结束标记        int end = text.indexOf(closeToken, offset);        while (end &gt; -1) {          // 处理转义的结束标记          if (end &gt; offset &amp;&amp; src[end - 1] == &#39;\\&#39;) {            // this close token is escaped. remove the backslash and continue.            expression.append(src, offset, end - offset - 1).append(closeToken);            offset = end + closeToken.length();            end = text.indexOf(closeToken, offset);          } else {            // 将开始标记和结束标记之间的字符串追加到expression中保存            expression.append(src, offset, end - offset);            break;          }        }        //未找到结束标记        if (end == -1) {          // close token was not found.          builder.append(src, start, src.length - start);          offset = src.length;        } else {          //将占位符的字面值交给TokenHandler处理，并将处理结果追加到builder中保存          //最终拼凑出解析后的完整内容          builder.append(handler.handleToken(expression.toString()));          offset = end + closeToken.length();        }      }      //移动start      start = text.indexOf(openToken, offset);    }    if (offset &lt; src.length) {      builder.append(src, offset, src.length - offset);    }    return builder.toString();  }</code></pre><p>占位符有<code>TokenHandler</code>接口的实现进行解析，<code>TokenHandler</code>接口总共有四个实现，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125231024-cKlwtn.png" srcset="undefined" alt=""></p><p>通过对<code>PropertyParser.parse()</code>方法的介绍，我们知道了<code>PropertyParser</code>是使用<code>VariableTokenHandler</code>与<code>GenericTokenParser</code>配合完成占位符解析的，<code>VariableTokenHandler</code>是<code>PropertyReslover</code>中的一个私有静态内部类，其字段的含义如下所示：</p><pre><code class="java"> /**     * &lt;properties&gt;&lt;properties/&gt;节点下定义的键值对，用于替换占位符     */    private final Properties variables;    /**     * 是否支持占位符中使用默认值的功能     */    private final boolean enableDefaultValue;    /**     * 指定占位符和默认值之间的分隔符     */    private final String defaultValueSeparator;</code></pre><p><code>VariableTokenHandler</code>实现了<code>TokenHandler</code>接口中的<code>handlerToken()</code>方法，该实现首先会按照<code>defaultValueSeparator</code>字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值，然后按照切分得到的占位符名称查找对应的值，如果在<code>&lt;properties&gt;</code>节点下未定义相应的键值对，则将切分得到的默认值作为解析结果返回。</p><pre><code class="java">/**     * 实现了{@link TokenHandler}接口中的{@link TokenHandler#handleToken(String)}方法，该实现：     *  1. 首先会按照{@link #defaultValueSeparator}字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值；     *  2. 然后按照切分得到的占位符名称查找对应的值，如果在&lt;properties&gt;&lt;properties/&gt;节点中未定义对应的键值对，     *     则将切分得到的默认值作为解析结果返回。     * @param content     * @return     */    @Override    public String handleToken(String content) {      // 检测variable集合是否为空      if (variables != null) {        String key = content;        //检测是否支持占位符中使用默认值的功能        if (enableDefaultValue) {          // 查找分隔符          final int separatorIndex = content.indexOf(defaultValueSeparator);          String defaultValue = null;          if (separatorIndex &gt;= 0) {            //获取分隔符名称            key = content.substring(0, separatorIndex);            //获取默认值            defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());          }          if (defaultValue != null) {            //在variables集合中查找指定的占位符            return variables.getProperty(key, defaultValue);          }        }        // 不支持默认值的功能，则直接查找variables集合        if (variables.containsKey(key)) {          return variables.getProperty(key);        }      }      //variables集合为空，直接返回      return &quot;${&quot; + content + &quot;}&quot;;    }  }</code></pre><p><code>GenericTokenParser</code>此类不仅用于默认值解析<code>PropertyParser#parse(String, Properties)</code>，还会在动态<code>SQL</code>语句的解析中用到。很明显，<code>GenericTokenParser</code>只是查找到指定的占位符，而具体的解析行为会根据持有的TokenHandler实现的不同而不同，这有点策略模式的意思。<br />回到对<code>XPathParser</code>的分析，<code>XPathParser.evalNode()</code>方法返回值类型是XNode，它对<code>org.w3c.dom.Node</code>对象做了封装和解析，其各个字段的含义如下：</p><pre><code class="java">  /**   * org.w3c.dom.Node对象   */  private final Node node;  /**   * Node节点名称   */  private final String name;  /**   * Node节点内容   */  private final String body;  /**   * 节点属性集合   */  private final Properties attributes;  /**   * mybatis-config.xml配置文件中&lt;properties&gt;&lt;properties/&gt;节点下定义的键值对   */  private final Properties variables;  /**   * XPathParser对象，该Node对象由此XPathParser对象生成   */  private final XPathParser xpathParser;</code></pre><p><code>XNode</code>的构造函数中会调用其<code>parseAttributes()</code>方法和<code>parseBody()</code>方法解析<code>org.w3c.dom.Node</code>对象中的信息，初始化<code>attributes</code>集合和<code>body</code>字段，具体初始化过程如下：</p><pre><code class="java">/**   * 解析Node对象中的Attributes属性集合   * @param n 节点对象   * @return   */  private Properties parseAttributes(Node n) {    Properties attributes = new Properties();    //获取节点的属性结合    NamedNodeMap attributeNodes = n.getAttributes();    if (attributeNodes != null) {      for (int i = 0; i &lt; attributeNodes.getLength(); i++) {        Node attribute = attributeNodes.item(i);        //使用PropertyParser处理每一个属性中的占位符        String value = PropertyParser.parse(attribute.getNodeValue(), variables);        attributes.put(attribute.getNodeName(), value);      }    }    return attributes;  }/**   * 解析Node对象中的信息body字段   * @param node   * @return   */  private String parseBody(Node node) {    String data = getBodyData(node);    //当前节点不是文本节点    if (data == null) {       //处理子节点      NodeList children = node.getChildNodes();      for (int i = 0; i &lt; children.getLength(); i++) {        Node child = children.item(i);        data = getBodyData(child);        if (data != null) {          break;        }      }    }    return data;  }  private String getBodyData(Node child) {    //只处理文本内容    if (child.getNodeType() == Node.CDATA_SECTION_NODE        || child.getNodeType() == Node.TEXT_NODE) {      String data = ((CharacterData) child).getData();      //使用PropertyParser处理文本节点中的占位符      data = PropertyParser.parse(data, variables);      return data;    }    return null;  }</code></pre><p>XPathParser测试用例</p><pre><code class="java">import org.apache.ibatis.builder.xml.XMLMapperEntityResolver;import org.apache.ibatis.io.Resources;import org.apache.ibatis.parsing.XNode;import org.apache.ibatis.parsing.XPathParser;import java.io.IOException;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 16:11 */public class XPathParserTest {  public static void main(String[] args) throws IOException {    String resource = &quot;resources/xpath-demo.xml&quot;;    XPathParser xPathParser = new XPathParser(Resources.getResourceAsReader(resource),true,null,new XMLMapperEntityResolver());    XNode xNode = xPathParser.evalNode(&quot;/configuration&quot;);    List&lt;XNode&gt; children = xNode.getChildren();    for (int i = 0; i &lt; children.size(); i++) {      System.out.println(children.get(i).getName());    }  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2保存密码登录</title>
    <link href="undefinedMac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html"/>
    <url>Mac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html</url>
    
    <content type="html"><![CDATA[<h1 id="iterm2保存密码登录"><a href="#iterm2保存密码登录" class="headerlink" title="iterm2保存密码登录"></a>iterm2保存密码登录</h1><h2 id="1-编写item2login-sh脚本文件"><a href="#1-编写item2login-sh脚本文件" class="headerlink" title="1. 编写item2login.sh脚本文件"></a>1. 编写<code>item2login.sh</code>脚本文件</h2><pre><code class="shell">#!/usr/bin/expect  set timeout 30  spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]  expect {         &quot;(yes/no)?&quot;         {send &quot;yes\n&quot;;exp_continue}         &quot;password:&quot;         {send &quot;[lindex $argv 3]\n&quot;}  }  interact </code></pre><ul><li><p>lindex $argv 0 : port</p></li><li><p>lindex $argv 1：username</p></li><li><p>lindex $argv 2：IP</p></li><li><p>lindex $argv 3：password</p></li></ul><h2 id="2-修改item2login-sh权限"><a href="#2-修改item2login-sh权限" class="headerlink" title="2. 修改item2login.sh权限"></a>2. 修改<code>item2login.sh</code>权限</h2><p>将<code>item2login.sh</code>移动到<code>/usr/local/bin</code>目录下，然后使用<code>chmod 777 item2login.sh</code>修改脚本权限；</p><h2 id="3-在iterm2中添加信息"><a href="#3-在iterm2中添加信息" class="headerlink" title="3. 在iterm2中添加信息"></a>3. 在iterm2中添加信息</h2><p>打开iterm2的<code>Profiles</code>–&gt;<code>Open Profiles...</code>–&gt;<code>Edit Profiles...</code>–&gt;<code>+</code></p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204208-mTkAoN.png" srcset="undefined" alt=""></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>然后就可以选取要登录的服务器了，效果如下所示（因为是测试服务所以没有连接）：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204211-HHVeUW.png" srcset="undefined" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Mac技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>