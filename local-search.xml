<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>缓存模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binding模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/binding%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/binding%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="binding模块"><a href="#binding模块" class="headerlink" title="binding模块"></a>binding模块</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transaction</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/Transaction.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/Transaction.html</url>
    
    <content type="html"><![CDATA[<h1 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataSource</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/DataSource.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/DataSource.html</url>
    
    <content type="html"><![CDATA[<h1 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h1><h1 id="1-工厂方法模式"><a href="#1-工厂方法模式" class="headerlink" title="1. 工厂方法模式"></a>1. 工厂方法模式</h1><h1 id="2-DataSourceFactory"><a href="#2-DataSourceFactory" class="headerlink" title="2. DataSourceFactory"></a>2. DataSourceFactory</h1><p>在数据源模块中，<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%B8%80).html#3-8-%E8%A7%A3%E6%9E%90-lt-environments-gt-%E8%8A%82%E7%82%B9" target="_blank" rel="noopener">DataSourceFactory</a>接口扮演工厂接口的角色。<code>UnpooledDataSourceFactory</code>和<code>PooledDataSourceFactory</code>则扮演着具体工厂类的角色。</p><p>我们从<code>DataSourceFactory</code>接口开始分析，其定义如下：</p><pre><code class="java">  /**   * 设置DataSource相关属性，   * 一切紧跟在初始化完成之后，证明：   *  {@link org.apache.ibatis.builder.xml.XMLConfigBuilder#dataSourceElement(XNode)}   * @param props   */  void setProperties(Properties props);  /**   * 获取DataSource对象   * @return   */  DataSource getDataSource();</code></pre><h2 id="2-1-UnpooledDataSourceFactory"><a href="#2-1-UnpooledDataSourceFactory" class="headerlink" title="2.1. UnpooledDataSourceFactory"></a>2.1. UnpooledDataSourceFactory</h2><p>在<code>UnpooledDataSourceFactory</code>的构造方法中会直接创建<code>UnpooledDataSource</code>对象，并初始化<code>UnpooledDatasourceFactory.dataSource</code>字段。</p><pre><code class="java">  protected DataSource dataSource;  /**   * 直接创建一个{@link UnpooledDataSource}   */  public UnpooledDataSourceFactory() {    this.dataSource = new UnpooledDataSource();  }</code></pre><p><code>UnpooledDataSourceFactory.setProperties()</code>方法会完成对<code>UnpooledDataSourceFactory</code>对象的配置，代码如下：</p><pre><code class="java">@Override  public void setProperties(Properties properties) {    Properties driverProperties = new Properties();    //创建DataSource对应的MetaObject    MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);    //遍历properties集合，该集合中配置了数据源需要的信息    for (Object key : properties.keySet()) {      String propertyName = (String) key;      //以&quot;diver.&quot;开头的配置项是对DataSource的配置，记录到diverProperties中保存      if (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) {        String value = properties.getProperty(propertyName);        driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);      }      //是否有该属性对应的setter方法      else if (metaDataSource.hasSetter(propertyName)) {        String value = (String) properties.get(propertyName);        //根据属性类型将value的类型进行类型转换，主要是Integer、Long、Boolean三种类型转换        Object convertedValue = convertValue(metaDataSource, propertyName, value);        //设置DataSource的相关属性        metaDataSource.setValue(propertyName, convertedValue);      } else {        throw new DataSourceException(&quot;Unknown DataSource property: &quot; + propertyName);      }    }    //设置DataSource的driverProperties属性    if (driverProperties.size() &gt; 0) {      metaDataSource.setValue(&quot;driverProperties&quot;, driverProperties);    }  }</code></pre><h2 id="2-2-PooledDataSourceFactory"><a href="#2-2-PooledDataSourceFactory" class="headerlink" title="2.2. PooledDataSourceFactory"></a>2.2. PooledDataSourceFactory</h2><p><code>PooledDataSourceFactory</code>继承了<code>UnpooledDataSourceFactory</code>，但是并没有覆盖<code>setProperties()</code>和<code>getDataSource()</code>方法。两者唯一不同的是<code>PoolDataSoueceFactory</code>的构造函数会将其<code>dataSource</code>字段初始化为<code>PooledDataSource</code>对象。</p><pre><code class="java">/** * 继承了{@link UnpooledDataSourceFactory},但是并没有覆盖{@link UnpooledDataSourceFactory#setProperties(Properties)}和{@link UnpooledDataSourceFactory#getDataSource()}方法， * 唯一不同的是初始化的dataSource是不同的： *      {@link UnpooledDataSourceFactory} 初始化了{@link org.apache.ibatis.datasource.unpooled.UnpooledDataSource} *      {@link PooledDataSourceFactory} 初始化了{@link PooledDataSource} * @author Clinton Begin */public class PooledDataSourceFactory extends UnpooledDataSourceFactory {  public PooledDataSourceFactory() {    this.dataSource = new PooledDataSource();  }}</code></pre><h2 id="2-3-JndiDataSourceFactory"><a href="#2-3-JndiDataSourceFactory" class="headerlink" title="2.3. JndiDataSourceFactory"></a>2.3. JndiDataSourceFactory</h2><p><code>JndiDataSourceFactory</code>是依赖<a href="https://baike.baidu.com/item/JNDI/3792442?fr=aladdin" target="_blank" rel="noopener">JNDI</a>服务从容器中获取用户配置的<code>DataSource</code>，其逻辑并不复杂，可以参看<a href="https://tomcat.apache.org/tomcat-8.5-doc/jndi-resources-howto.html" target="_blank" rel="noopener">Tomcat的JNDI</a>相关文档。</p><h1 id="3-DataSource"><a href="#3-DataSource" class="headerlink" title="3. DataSource"></a>3. DataSource</h1><p><code>javax.sql.DataSource</code>接口在数据源模块中扮演了产品接口的角色，<code>Mybatis</code>提供了两个<code>DataSource</code>接口的实现类，分别是<code>UnpooledDataSource</code>和<code>PooledDataSource</code>，他们扮演着具体产品类的角色。</p><h2 id="3-1-UnpooledDataSource"><a href="#3-1-UnpooledDataSource" class="headerlink" title="3.1. UnpooledDataSource"></a>3.1. UnpooledDataSource</h2><p><code>UnpooledDataSource</code>实现了<code>javax.sql.DataSource</code>接口中定义的<code>getConnection()</code>方法及其重载方法，用于获取数据库连接。每次通过<code>UnpooledDataSource.getConnection()</code>方法获取数据库连接时都会创建一个新连接。<code>UnpooledDataSource</code>中的字段如下，每个字段都有对应的<code>getter</code>和<code>setter</code>方法：</p><pre><code class="java">  /**   * 加载Driver类的类加载器   */  private ClassLoader driverClassLoader;  /**   * 数据库连接驱动的相关配置   */  private Properties driverProperties;  /**   * 缓存所有已注册的数据库连接驱动   */  private static Map&lt;String, Driver&gt; registeredDrivers = new ConcurrentHashMap&lt;&gt;();  /**   * 数据库连接驱动的名称   */  private String driver;  /**   * 数据库Url   */  private String url;  /**   * 用户名   */  private String username;  /**   * 密码   */  private String password;  /**   * 是否自动提交   */  private Boolean autoCommit;  /**   * 事务隔离级别   */  private Integer defaultTransactionIsolationLevel;  /**   * 默认连接网络超时（3.5.2）   */  private Integer defaultNetworkTimeout;</code></pre><h3 id="3-1-1-向DriverManager注册驱动"><a href="#3-1-1-向DriverManager注册驱动" class="headerlink" title="3.1.1. 向DriverManager注册驱动"></a>3.1.1. 向<code>DriverManager</code>注册驱动</h3><p>以<code>JDBC</code>为例，我们知道创建数据库连接之前，首先要向<code>DriverManager</code>注册<code>JDBC</code>驱动类，<code>com.mysql.jdbc.Driver</code>中有如下静态代码块：</p><pre><code class="java">//com.mysql.jdbc.Driver.javastatic {        try {//#ifdef JAVA8            DriverManager.registerDriver(driverInstance, new EmptyDiverAction());//#else/*            DriverManager.registerDriver(driverInstance);*///#endif JAVA8        } catch (Exception e) {        }    }  public static final JDBCDriver driverInstance = new JDBCDriver();</code></pre><p><code>DriverManager</code>中定义了<code>registerDrivers</code>字段用于记录注册的<code>JDBC</code>驱动，定义如下：</p><pre><code class="java">//java.sql.DriverManager.java// List of registered JDBC drivers    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();  public static synchronized void registerDriver(java.sql.Driver driver,            DriverAction da)        throws SQLException {        /* Register the driver if it has not already been added to our list */        if(driver != null) {            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));        } else {            // This is for compatibility with the original DriverManager            throw new NullPointerException();        }        println(&quot;registerDriver: &quot; + driver);    }</code></pre><p>下面我们回到<code>Mybatis</code>中的<code>UnpooledDataSource</code>的分析，<code>UnpooledDataSource</code>中定义了如下静态代码块，在<code>UnpooledDataSource</code>加载时会通过静态代码块将已在<code>DriverManager</code>中注册的<code>JDBC Driver</code>复制一份到<code>UnpooledDataSource.registeredDriver</code>集合中。</p><pre><code class="java">/**   * 此静态代码块，在当前类加载时将已经在DriverManager中注册的JDBC Driver复制一份到{@link UnpooledDataSource#registeredDrivers}中。   */  static {    //获取到能加载到的所有的JDBC的驱动    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();    while (drivers.hasMoreElements()) {      Driver driver = drivers.nextElement();      //添加JDBC驱动      registeredDrivers.put(driver.getClass().getName(), driver);    }  }</code></pre><h3 id="3-1-2-getConnection"><a href="#3-1-2-getConnection" class="headerlink" title="3.1.2. getConnection()"></a>3.1.2. <code>getConnection()</code></h3><p><code>UnpooledDataSource.getConnection()</code>方法：</p><pre><code class="java"> /**   * 获取连接   * @return   * @throws SQLException   */  @Override  public Connection getConnection() throws SQLException {    return doGetConnection(username, password);  }  /**   * 获取连接   * @return   * @throws SQLException   */  @Override  public Connection getConnection(String username, String password) throws SQLException {    return doGetConnection(username, password);  }</code></pre><h3 id="3-1-2-doGetConnection"><a href="#3-1-2-doGetConnection" class="headerlink" title="3.1.2. doGetConnection()"></a>3.1.2. <code>doGetConnection()</code></h3><p><code>UnpooledDataSource.getConnection()</code>方法的所有重载最终会调用<code>UnpooledDataSource.doGetConnection()</code>方法获取数据库连接，具体实现如下：</p><pre><code class="java">  private Connection doGetConnection(String username, String password) throws SQLException {    Properties props = new Properties();    //添加驱动配置    if (driverProperties != null) {      props.putAll(driverProperties);    }    //添加连接用户名的key和value    if (username != null) {      props.setProperty(&quot;user&quot;, username);    }    //添加连接密码的key和value    if (password != null) {      props.setProperty(&quot;password&quot;, password);    }    //利用封装好的配置获取连接    return doGetConnection(props);  }</code></pre><pre><code class="java">  private Connection doGetConnection(Properties properties) throws SQLException {    //初始化数据库驱动    initializeDriver();    //创建真正的数据库连接    Connection connection = DriverManager.getConnection(url, properties);    //配置数据库连接的autoCommit和隔离级别    configureConnection(connection);    return connection;  }</code></pre><h3 id="3-1-3-initializeDriver"><a href="#3-1-3-initializeDriver" class="headerlink" title="3.1.3. initializeDriver()"></a>3.1.3. <code>initializeDriver()</code></h3><p><code>UnpooledDataSource.initializeDriver()</code>方法主要负责数据驱动的初始化，该方法会创建配置中指定的Driver对象，并将其注册到<code>DriverManger</code>以及上面介绍的<code>UnpooledDataSource.registerDriver</code>集合中保存。</p><pre><code class="java">/**   * 初始化数据库驱动   * @throws SQLException   */  private synchronized void initializeDriver() throws SQLException {    //判断驱动注册列表中是否包含我们要连接的数据库驱动，即检测驱动是否已注册    if (!registeredDrivers.containsKey(driver)) {      Class&lt;?&gt; driverType;      try {        //判断是否指定了驱动类的加载器，如果指定了初始化驱动后续操作使用指定的ClassLoader，然后返回不同的驱动类型（ClassLoader不同，就算是同一个java文件，生成的class类型也是不同的。）        if (driverClassLoader != null) {          driverType = Class.forName(driver, true, driverClassLoader);        } else {          //如果没有指定加载器，那么使用默认的驱动类型          driverType = Resources.classForName(driver);        }        // DriverManager requires the driver to be loaded via the system ClassLoader.        // http://www.kfu.com/~nsayer/Java/dyn-jdbc.html        //创建Driver对象        Driver driverInstance = (Driver)driverType.getDeclaredConstructor().newInstance();        //注册驱动，DriverProxy是UnpooledDataSource中的内部类，是Driver的静态代理类        DriverManager.registerDriver(new DriverProxy(driverInstance));        registeredDrivers.put(driver, driverInstance);      } catch (Exception e) {        throw new SQLException(&quot;Error setting driver on UnpooledDataSource. Cause: &quot; + e);      }    }  }</code></pre><h3 id="3-1-4-configureConnection"><a href="#3-1-4-configureConnection" class="headerlink" title="3.1.4. configureConnection()"></a>3.1.4. <code>configureConnection()</code></h3><p><code>UnpooledDataSource.configureConnection()</code>方法会完成数据连接的一系列配置，具体代码如下所示（<code>defaultNetworkTimeout</code>这个属性是<code>Mybatis3.5.2</code>版本加入的）：</p><pre><code class="java">  /**   * 完成数据库连接的一系列配置   * @param conn   * @throws SQLException   */  private void configureConnection(Connection conn) throws SQLException {    //设置网络超时时间，这是3.5.2之后添加的属性    if (defaultNetworkTimeout != null) {      conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout);    }    //设置事务是否自动提交    if (autoCommit != null &amp;&amp; autoCommit != conn.getAutoCommit()) {      conn.setAutoCommit(autoCommit);    }    //设置事务的隔离界别    if (defaultTransactionIsolationLevel != null) {      conn.setTransactionIsolation(defaultTransactionIsolationLevel);    }  }</code></pre><h2 id="3-2-PooledDataSource"><a href="#3-2-PooledDataSource" class="headerlink" title="3.2. PooledDataSource"></a>3.2. PooledDataSource</h2><p>数据库连接的创建时一个非常耗时的，数据库能够建立的连接数也非常有限，所以在绝大多数系统中，数据库连接是非常珍贵的资源，使用数据库连接池就显得尤为必要了。使用数据库连接池会带来很多的好处，例如，可以实现数据库连接的重用、提高响应速度、防止数据库连接过多造成数据库假死、避免数据库连接泄露等。</p><p>数据库连接池在初始化是，一般会创建一定数量的数据库连接并添加到连接池中备用。当程序需要使用数据库连接时，从池中请求连接；当程序不再使用该连接时，会将其返回到池中缓存，等待下次使用，而不是直接关闭。当然，数据库连接线会控制连接总数的上限以及空闲连接数的上限，如果连接池创建的总连接数已达到上限，且都已被占用，则后续请求连接的线程会进入阻塞队列等待，知道有线程释放出可用连接。如果连接池中空闲连接数较多，达到其上限，则后续返回的空闲连接不会放入池中，而是直接关闭，这样可以减少系统维护多余数据库连接的开销。</p><p>如果将总连接数的上线设置得过大，可能会因为连接数过多而导致数据库僵死，系统整体性能下降；如果总连接数上线过小，则无法完全发挥数据库的性能，浪费数据库资源。如果将空闲连接的上线设置得过大，则会浪费系统资源来维护这些空闲连接；如果空闲连接上线过小，当出现瞬间的峰值请求时，系统的快速响应能力就比较弱。<strong>所以在设置数据库连接池的这两个值时，需要进行性能测试、权衡以及一些经验。</strong></p><p><code>PooledDataSource</code>实现了简易数据库连接池的功能，它依赖的组件如下图所指示，其中需要注意的是，<code>PooledDataSource</code>创建新数据库连接的功能是依赖其中封装的<code>UnpooledDataSource</code>对象实现的。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191130164424-ZdSnNd.png" srcset="undefined" style="zoom:67%;" /><p>在研究<code>PooledDataSource</code>的时候从一个简单的例子出发，不然不知道怎么研究<code>PooledDataSource</code>、<code>PooledConnection</code>、<code>PoolState</code>、<code>UnpooledDataSource</code>、<code>DataSource</code>五者之间的调用关系：</p><pre><code class="java">package red.reksai.datasource;import org.apache.ibatis.datasource.pooled.PooledDataSourceFactory;import org.apache.ibatis.io.Resources;import org.junit.jupiter.api.Test;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/12/1 01:15 */public class PooledDataSourceFactoryTest {  @Test  public void test1() throws IOException, SQLException {    String resources = &quot;resources/config.properties&quot;;    InputStream inputStream = Resources.getResourceAsStream(resources);    Properties properties = new Properties();    properties.load(inputStream);    PooledDataSourceFactory pooledDataSourceFactory = new PooledDataSourceFactory();    pooledDataSourceFactory.setProperties(properties);    Connection connection = pooledDataSourceFactory.getDataSource().getConnection();    PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from blog where blog_id = 1&quot;);    ResultSet resultSet = preparedStatement.executeQuery();    while (resultSet.next()){      System.out.println(resultSet.getString(1));    }  }}</code></pre><p>有上述代码可以发现程序执行的第一步是：new PooledDataSourceFactory()，而在PooledDataSourceFactory构造中new 了一个PooledDataSource，所以我们需要先解析PooledDataSource。</p><p>PooledDataSource中的核心字段如下所示：</p><pre><code class="java">/**   * 通过PoolState管理连接池的转台并记录统计信息   */  private final PoolState state = new PoolState(this);  /**   * 创建一个PooledDataSource需要一个UnpooledDataSource   */  private final UnpooledDataSource dataSource;  // OPTIONAL CONFIGURATION FIELDS  // 可选配置字段  /**   * 最大活跃连接数   */  protected int poolMaximumActiveConnections = 10;  /**   * 最大空闲连接数   */  protected int poolMaximumIdleConnections = 5;  /**   * 最大CheckoutTime时间（最大连接时间）   */  protected int poolMaximumCheckoutTime = 20000;  /**   * 在无法获取连接时，线程需要等待的时间   */  protected int poolTimeToWait = 20000;  protected int poolMaximumLocalBadConnectionTolerance = 3;  /**   * 在检测一个数据库连接是否可用时，会给数据库发送一个测试SQL语句   */  protected String poolPingQuery = &quot;NO PING QUERY SET&quot;;  /**   * 是否允许发送测试SQL   */  protected boolean poolPingEnabled;  /**   * 当poolPingConnectionsNotUsedFor毫秒未使用时，会发送一次测试SQL语句，检测连接是否正常   */  protected int poolPingConnectionsNotUsedFor;  /**   * 该hash用于标志着当前的连接池，在构造函数中初始化   *    生成规则：{@link PooledDataSource#assembleConnectionTypeCode(String, String, String)}   */  private int expectedConnectionTypeCode;</code></pre><p>PooledDataSource中还提供了上述字段的getter和setter方法，代码比较简单。其中有个与众不同的属性赋值<code>private final PoolState state = new PoolState(this);</code>，这使得我先去研究PoolState了，一会回来。</p><hr><p>PoolState是用于管理PooledConnection对象状态的组件。为什么这么说呢？看看它定义的字段：</p><pre><code class="java"> protected PooledDataSource dataSource;  /**   * 空闲的PooledConnection集合   */  protected final List&lt;PooledConnection&gt; idleConnections = new ArrayList&lt;&gt;();  /**   * 活跃的PooledConnection集合   */  protected final List&lt;PooledConnection&gt; activeConnections = new ArrayList&lt;&gt;();  /**   * 请求数据库连接的次数   */  protected long requestCount = 0;  /**   * 获取连接的累计时长   */  protected long accumulatedRequestTime = 0;  /**   * CheckoutTime表示应用从连接池中取出连接，到归还连接这端时长   * accumulatedCheckoutTime记录的是所有连接累计的CheckoutTime时长   */  protected long accumulatedCheckoutTime = 0;  /**   * 当连接长时间未被归还给连接池时，会被认为该连接超时   * claimedOverdueConnectionCount 记录的是超时的连接个数   */  protected long claimedOverdueConnectionCount = 0;  /**   * 累计超时时间   */  protected long accumulatedCheckoutTimeOfOverdueConnections = 0;  /**   * 累计等待时间   */  protected long accumulatedWaitTime = 0;  /**   * 等待次数   */  protected long hadToWaitCount = 0;  /**   * 无效连接数   */  protected long badConnectionCount = 0;</code></pre><p>由以上字段可以看出，PoolState是通过两个Arraylist<PooledConnection>分别管理空闲状态的连接和活跃状态的连接的，当然了PoolState中还定义了一系列用于统计的字段。</p><hr><p>简单介绍完以上，我们再回到PooledDataSource，分析其构造方法，如下所示：</p><pre><code class="java">public PooledDataSource() {    dataSource = new UnpooledDataSource();  }  public PooledDataSource(UnpooledDataSource dataSource) {    this.dataSource = dataSource;  }  public PooledDataSource(String driver, String url, String username, String password) {    dataSource = new UnpooledDataSource(driver, url, username, password);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }  public PooledDataSource(String driver, String url, Properties driverProperties) {    dataSource = new UnpooledDataSource(driver, url, driverProperties);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }  public PooledDataSource(ClassLoader driverClassLoader, String driver, String url, String username, String password) {    dataSource = new UnpooledDataSource(driverClassLoader, driver, url, username, password);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }  public PooledDataSource(ClassLoader driverClassLoader, String driver, String url, Properties driverProperties) {    dataSource = new UnpooledDataSource(driverClassLoader, driver, url, driverProperties);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }</code></pre><p>有PooledDataSource的构造方法可知，PooledDataSource的创建需要一个UnPooledDataSource对象。</p><p>拿到DataSource对象之后，就要通过DataSource.getConnection()去获取数据库连接对象，在PooledDataSource中的getConnection()代码如下所示：</p><pre><code class="java">  /**   * 获取连接：   *    首先通过{@link PooledDataSource#popConnection(String, String)}获取{@link PooledConnection}，   *    因为PooledConnection只实现了{@link InvocationHandler} 接口，并未实现java.sql.Connection，故而这个PooledConnection不能使用，   *    需要使用{@link PooledConnection#getProxyConnection()}获取一个JDK动态代理生成的实现了java.sql.Connection的代理对象。   * @return   * @throws SQLException   */  @Override  public Connection getConnection() throws SQLException {    return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();  }  /**   * 获取连接   * @return   * @throws SQLException   */  @Override  public Connection getConnection(String username, String password) throws SQLException {    return popConnection(username, password).getProxyConnection();  }</code></pre><p>由以上代码可以看出，不管调用的是哪个PooledDataSource.getConnection()方法的重载，最终都调用到了两个方法：</p><ol><li>通过PooledDataSource.popConnection()获取一个PooledConnection，因为PooledConnection只实现了InvocationHandler接口，并未实现java.sql.Connection，故而这个PooledConnection是不能操作数据库的，需要通过它获取一个java.sql.Connection的代理对象，也就有了第二部的操作；</li><li>使用PooledConnection.getProxyConnection()，获取一个JDK动态代理生成的实现了java.sql.Connection的代理对象。（这一步很简单就是一个get值的过程，不去研究。）</li></ol><p>所以我们接下来先分析PooledDataSource.popConnection()方法，此方法具体代码如下所示：</p><pre><code class="java">/**   * pop连接   * @param username   * @param password   * @return   PooledConnection的代理对象   * @throws SQLException   */  private PooledConnection popConnection(String username, String password) throws SQLException {    //等待，默认是不等待    boolean countedWait = false;    PooledConnection conn = null;    //创建或判断连接之前系统时间    long t = System.currentTimeMillis();    //本地错误连接数    int localBadConnectionCount = 0;    //1. 当连接为null的时候，去执行循环    while (conn == null) {      synchronized (state) {        //2. 判断有没有空闲连接        if (!state.idleConnections.isEmpty()) {          // Pool has available connection          //有空闲连接，就获取连接，然后把当前连接从空闲连接中移除          conn = state.idleConnections.remove(0);          if (log.isDebugEnabled()) {            log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;);          }        } else {          // Pool does not have available connection          //如果没有空闲连接          //首先判断活跃连接是不是小于最大活跃数，如果小于可以创建新连接          if (state.activeConnections.size() &lt; poolMaximumActiveConnections) {            // Can create new connection            // 创建一个新连接（这是一个代理对象）            conn = new PooledConnection(dataSource.getConnection(), this);            if (log.isDebugEnabled()) {              log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;);            }          } else {            // Cannot create new connection            // 如果判断活跃连接数等于最大活跃数，获取最老的活跃连接            PooledConnection oldestActiveConnection = state.activeConnections.get(0);            // 获取此连接的连接时长（当前时间—取出连接的时间）            long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();            // 然后判断是否超时（此连接的连接时间  和 运行连接的时间  比较）            if (longestCheckoutTime &gt; poolMaximumCheckoutTime) {              // 当前连接超时              // Can claim overdue connection              //对超时连接进行统计              //超时连接数+1              state.claimedOverdueConnectionCount++;              //总累计超时时间 = 原有总累计超时时间+当前连接时间（因为当前连接已经超时）              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;              //总累计连接时间 = 原有总累计连接时间+ 当前连接时间              state.accumulatedCheckoutTime += longestCheckoutTime;              //从活跃连接中移除最老的这个超时连接              state.activeConnections.remove(oldestActiveConnection);              //获取真正的数据库连接，判断数据库提交模式（自动提交事务还是手动）              if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {                try {                  //如果是不自动提交事务的情况，那么就要回滚本次操作                  oldestActiveConnection.getRealConnection().rollback();                } catch (SQLException e) {                  /*                     Just log a message for debug and continue to execute the following                     statement like nothing happened.                     Wrap the bad connection with a new PooledConnection, this will help                     to not interrupt current executing thread and give current thread a                     chance to join the next competition for another valid/good database                     connection. At the end of this loop, bad {@link @conn} will be set as null.                   */                  log.debug(&quot;Bad connection. Could not roll back&quot;);                }              }              //重新创建连接              conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);              //设置该连接创建的时间戳              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());              //设置该连接的最后使用时间              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());              //然后作废之前的最老的超时连接，因为此前只是从集合中移除，并不表示它不能使用，而这一步就是确保这种情况不会出现。              oldestActiveConnection.invalidate();              if (log.isDebugEnabled()) {                log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;);              }            } else {              // 没有空闲连接、活跃的连接数又等于限定的最大连接数（即：无法创建连接）而且无超时连接、则只能阻塞等待              // Must wait              try {                //如果此前没有等待的                if (!countedWait) {                  //先将等待数+1                  state.hadToWaitCount++;                  //然后将状态设置为等待状态                  countedWait = true;                }                if (log.isDebugEnabled()) {                  log.debug(&quot;Waiting as long as &quot; + poolTimeToWait + &quot; milliseconds for connection.&quot;);                }                //获取当前系统时间                long wt = System.currentTimeMillis();                //获取需要等待的时间，利用Object.wait(需要等待的时间)，让当前线程进行等待                state.wait(poolTimeToWait);                //更新累计等待时间：累计等待时间=当得系统时间+当前时间-等待直接记录的系统时间                state.accumulatedWaitTime += System.currentTimeMillis() - wt;              } catch (InterruptedException e) {                break;              }            }          }        }        // 再次判断连接是否为空        // 如果不为空        if (conn != null) {          // ping to server and check the connection is valid or not          //判断连接是否有效          if (conn.isValid()) {            //如果当前连接不是自动提交事务，那就回滚之前操作            if (!conn.getRealConnection().getAutoCommit()) {              conn.getRealConnection().rollback();            }            //然后重现设置用于标识该连接所在的连接池的标识码            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));            //设置连接时长            conn.setCheckoutTimestamp(System.currentTimeMillis());            //设置最后修改时间            conn.setLastUsedTimestamp(System.currentTimeMillis());            //把当前连接添加到活跃连接集合中            state.activeConnections.add(conn);            //然后把连接次数+1            state.requestCount++;            //累计请求连接时间            state.accumulatedRequestTime += System.currentTimeMillis() - t;          } else {            //如果当前连接不为空，但是是失效的，那么表明此连接是一个坏连接（无效连接）            if (log.isDebugEnabled()) {              log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) was returned from the pool, getting another connection.&quot;);            }            //无效连接数+1            state.badConnectionCount++;            //本地错误连接数+1            localBadConnectionCount++;            //设置连接为空            conn = null;            if (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) {              if (log.isDebugEnabled()) {                log.debug(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);              }              throw new SQLException(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);            }          }        }      }    }    //此时连接为空，表明发生了未知错误    if (conn == null) {      if (log.isDebugEnabled()) {        log.debug(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);      }      throw new SQLException(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);    }    //最后返回连接    return conn;  }</code></pre><p>以上代码的逻辑流程如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191201140942-l8rFwF.png" srcset="undefined" alt=""></p><p>有以上流程，我们发现在在活跃数没有大于最大限定的时候创建了一个新的PooledConnection，这里调用了PooledConnection的构造方法，代码如下所示：</p><pre><code class="java"> public PooledConnection(Connection connection, PooledDataSource dataSource) {    this.hashCode = connection.hashCode();    this.realConnection = connection;    this.dataSource = dataSource;    this.createdTimestamp = System.currentTimeMillis();    this.lastUsedTimestamp = System.currentTimeMillis();    this.valid = true;    /**     * 这里的this 为 {@link PooledConnection#invoke(Object, Method, Object[])}     */    this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);  }</code></pre><p>这里就初始化了一个<code>java.sql.Connection</code>的代理对象（<code>this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);</code>），后续进行的操作就是通过这个代理对象完成的，因为代理对象的执行最终要执行到<code>InvocartionHandler</code>的实现的<code>invoke()</code>方法，而<code>PooledConnection</code>就实现了<code>InvocationHandler</code>方法，故我们执行的<code>java.sql.Connection</code>中的方法最终执行的都是<code>PooledConnection</code>中的<code>invoke()</code>方法，<code>PooledConnection.invoke()</code>方法代码如下所示：</p><pre><code class="java">/**   * Required for InvocationHandler implementation.   *   * @param proxy  - not used   * @param method - the method to be executed   * @param args   - the parameters to be passed to the method   * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])   */  @Override  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    String methodName = method.getName();    //如果调用的是close()方法，则重现将连接放回到连接池，而不是真正的关闭数据库连接    if (CLOSE.equals(methodName)) {      dataSource.pushConnection(this);      return null;    }    try {      if (!Object.class.equals(method.getDeclaringClass())) {        // issue #579 toString() should never fail        // throw an SQLException instead of a Runtime        //通过valid字段检测数据库连接是否有效        checkConnection();      }      //调用真正数据库连接对象的对应方法      return method.invoke(realConnection, args);    } catch (Throwable t) {      throw ExceptionUtil.unwrapThrowable(t);    }  }</code></pre><p>以上代码中重要的方法是<code>PooledDataSource.pushConnection()</code>，<code>PooledDataSource.pushConnection()</code>的代码如下所示：</p><pre><code class="java"> /**   * 放回连接   * @param conn   * @throws SQLException   */  protected void pushConnection(PooledConnection conn) throws SQLException {    synchronized (state) {      //从活跃连接集合中移除此连接      state.activeConnections.remove(conn);      //判断此连接是否有效      if (conn.isValid()) {        //判断空闲连接数是否小于最大空闲连接数  （即：判断空闲连接数是否达到上限） 以及此连接是否是该连接池的连接        if (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) {          //空闲连接数没有达到上限          //累计checkOut时长          state.accumulatedCheckoutTime += conn.getCheckoutTime();          //回滚未提交的事务          if (!conn.getRealConnection().getAutoCommit()) {            conn.getRealConnection().rollback();          }          //为返还连接创造新的PooledConnection对象          PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);          //然后将新对象添加到活跃集合          state.idleConnections.add(newConn);          //设置新连接创建时间戳          newConn.setCreatedTimestamp(conn.getCreatedTimestamp());          //设置新连接最后使用时间戳          newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());          //将老连接对象设置为无效          conn.invalidate();          if (log.isDebugEnabled()) {            log.debug(&quot;Returned connection &quot; + newConn.getRealHashCode() + &quot; to pool.&quot;);          }          //唤醒等待的线程          state.notifyAll();        } else {          //空闲连接数已达到上限   或   PooledConnection对象不属于该连接池          //累计checkOur时长          state.accumulatedCheckoutTime += conn.getCheckoutTime();          //回滚未提交的操作          if (!conn.getRealConnection().getAutoCommit()) {            conn.getRealConnection().rollback();          }          //因为这个PooledConnection对象不属于该连接池，所以直接关闭，而不是放回连接池          conn.getRealConnection().close();          if (log.isDebugEnabled()) {            log.debug(&quot;Closed connection &quot; + conn.getRealHashCode() + &quot;.&quot;);          }          //最后再将对象设置为无效          conn.invalidate();        }      } else {        //如果此连接是无效连接，抛出异常，并且记录先关统计数据        if (log.isDebugEnabled()) {          log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) attempted to return to the pool, discarding connection.&quot;);        }        //统计无效的PooledConnection对象        state.badConnectionCount++;      }    }  }</code></pre><p>以上代码的逻辑流程如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191201152437-0IpAsL.png" srcset="undefined" alt=""></p><hr><p>需要注意的是，<code>PooledDataSouece.pushConnection()</code>方法和<code>PooledDataSouece.popConnection()</code>方法中都调用了<code>PooledDataSource.isValid()</code>方法来检测<code>PooledConnection</code>的有效性，该方法除了检测<code>PooledDataSource.valid</code>字段的值，还会调用<code>PooledDataSource.pingConnection()</code>方法尝试让数据库执行<code>poolPingQuery</code>字段中记录的测试<code>SQL</code>语句，从而检测真正的数据库连接对象是否依然可以正常使用。<code>isValid()</code>方法以及<code>pingConnection()</code>方法的代码如下所示：</p><pre><code class="java">  /**   * 检测PooledConnection的有效性   * Method to see if the connection is usable.   *   * @return True if the connection is usable   */  public boolean isValid() {    //除了检测valid字段外，还要使用PooledDataSource.pingConnection()方法，向数据库发出测试语句来进一步判断    return valid &amp;&amp; realConnection != null &amp;&amp; dataSource.pingConnection(this);  }</code></pre><pre><code class="java">/**   * 用于测试连接   * Method to check to see if a connection is still usable   *   * @param conn - the connection to check   * @return True if the connection is still usable   */  protected boolean pingConnection(PooledConnection conn) {    boolean result = true;    try {      //检测真正的连接是否已关闭      result = !conn.getRealConnection().isClosed();    } catch (SQLException e) {      if (log.isDebugEnabled()) {        log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());      }      result = false;    }    if (result) {      //判断要不要发不出测试语句      if (poolPingEnabled) {        //要        //        if (poolPingConnectionsNotUsedFor &gt;= 0 &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) {          try {            if (log.isDebugEnabled()) {              log.debug(&quot;Testing connection &quot; + conn.getRealHashCode() + &quot; ...&quot;);            }            Connection realConn = conn.getRealConnection();            try (Statement statement = realConn.createStatement()) {              statement.executeQuery(poolPingQuery).close();            }            if (!realConn.getAutoCommit()) {              realConn.rollback();            }            result = true;            if (log.isDebugEnabled()) {              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is GOOD!&quot;);            }          } catch (Exception e) {            log.warn(&quot;Execution of ping query &#39;&quot; + poolPingQuery + &quot;&#39; failed: &quot; + e.getMessage());            try {              conn.getRealConnection().close();            } catch (Exception e2) {              //ignore            }            result = false;            if (log.isDebugEnabled()) {              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());            }          }        }      }    }    return result;  }</code></pre><p>最后需要注意的是<code>PooledDataSource.forceCloseAll()</code>，当修改<code>PooledDataSource</code>的字段是，例如数据库的<code>URL</code>、<code>用户名</code>、<code>密码</code>、<code>autoCommit</code>配置等，都会调用<code>PooledDataSource.forceCloseAll()</code>方法将所有的数据库连接都关掉，同时也会将相应的<code>PooledConnection</code>对象都设置为无效，清空<code>activeConnections</code>集合和<code>idleConnections</code>集合。应用系统之后通过<code>PoolDataSource.getConnection()</code>获取连接时，会按照新的配置重新创建新的数据库连接以及对应的<code>PooledConnection</code>对象。<code>forceCloseAll()</code>方法的具体实现如下所示：</p><pre><code class="java">/**   * `PooledDataSource.forceCloseAll()`，当修改`PooledDataSource`的字段是，例如数据库的`URL`、`用户名`、`密码`、`autoCommit`配置等，   * 都会调用`PooledDataSource.forceCloseAll()`方法将所有的数据库连接都关掉，同时也会将相应的`PooledConnection`对象都设置为无效，   * 清空`activeConnections`集合和`idleConnections`集合。应用系统之后通过`PoolDataSource.getConnection()`获取连接时，   * 会按照新的配置重新创建新的数据库连接以及对应的`PooledConnection`对象.   * Closes all active and idle connections in the pool.   */  public void forceCloseAll() {    synchronized (state) {      expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());      for (int i = state.activeConnections.size(); i &gt; 0; i--) {        try {          PooledConnection conn = state.activeConnections.remove(i - 1);          conn.invalidate();          Connection realConn = conn.getRealConnection();          if (!realConn.getAutoCommit()) {            realConn.rollback();          }          realConn.close();        } catch (Exception e) {          // ignore        }      }      for (int i = state.idleConnections.size(); i &gt; 0; i--) {        try {          PooledConnection conn = state.idleConnections.remove(i - 1);          conn.invalidate();          Connection realConn = conn.getRealConnection();          if (!realConn.getAutoCommit()) {            realConn.rollback();          }          realConn.close();        } catch (Exception e) {          // ignore        }      }    }    if (log.isDebugEnabled()) {      log.debug(&quot;PooledDataSource forcefully closed/removed all connections.&quot;);    }  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
      <tag>工厂方法模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资源加载</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD.html</url>
    
    <content type="html"><![CDATA[<h1 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis初始化(一)</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%B8%80).html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%B8%80).html</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis初始化-一"><a href="#Mybatis初始化-一" class="headerlink" title="Mybatis初始化(一)"></a>Mybatis初始化(一)</h1><hr><p><strong>因为篇幅的原因，此部分只分析mybatis-config.xml配置文件的解析。</strong></p><hr><p>类似于<code>Spring</code>，<code>Mybatis</code>等灵活性和扩展性都很高的开源框架都提供了很多配置项，开发人员需要在使用时提供相应的配置信息，实现相应的需求。<code>Mybatis</code>中的配置文件主要有两个，分别是<code>mybatis-config.xml</code>配置文件和映射配置文件。</p><p>现在主流的配置方式除了使用XML配置文件，还会配合注解进行配置。在<code>Mybatis</code>初始化过程中，除了会读取<code>mybatis-config.xml</code>配置文件以及映射配置文件，还会加载配置文件指定的类，处理类中的注解，创建一些配置对象，最终完成框架中各个模块的初始化。另外，也可以使用<code>Java API</code>方式对<code>Mybatis</code>进行配置，这种硬编码的配置方式主要用在配置量比较少且配置信息不常变化的场景下。</p><h1 id="1-建造者模式"><a href="#1-建造者模式" class="headerlink" title="1. 建造者模式"></a>1. 建造者模式</h1><h1 id="2-BaseBuidler"><a href="#2-BaseBuidler" class="headerlink" title="2. BaseBuidler"></a>2. BaseBuidler</h1><p><code>BaseBuilder</code>的子类如下所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128141904-lVPgr8.png" srcset="undefined" style="zoom:50%;" /><p>因为<code>VelocitySqlSourceBuilder</code>只是一个测试用例，所以我暂且不把它划为<code>BaseBuilder</code>，包括其静态内部类</p><p><code>ParameterMappingTokenHandler</code>，这样<code>BaseBuilder</code>的子类结构图就如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128142203-inbhpO.png" srcset="undefined" alt=""></p><p>正如签名所示，<code>Mybatis</code>的初始化过程使用了建造者模式，这里的<code>BaseBuilder</code>抽象类就扮演了建造者接口的角色。<code>BaseBuilder</code>中的核心字段的含义如下：</p><ul><li><code>Configuration</code></li><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#3-TypeHandlerRegistry" target="_blank" rel="noopener">TypeHandlerRegistry</a></li><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a></li></ul><pre><code class="java"> /**  * Configuration对象是Mybatis初始化过程中的核心对象，Mybatis中几乎所有配置信息都会保存到Configuration对象中。  *    * Configuration对象是Mybatis初始化过程中创建的且是全局唯一的。   * 也有人称它是一个“All in One” 对象   */  protected final Configuration configuration;  /**   * 在mybatis-config.xml配置文件中可以使用&lt;typeAliases&gt;&lt;/typeAliases&gt;标签定义别名，这些定义的别名都会记录在TypeAliasesRegistry对象中   */  protected final TypeAliasRegistry typeAliasRegistry;  /**   * 在mybatis-config.xml配置文件中可以使用&lt;typeHandler&gt;&lt;/typeHandler&gt;标签定义添加的自定义的TypeHandler，   * 完成指定数据库类型与Java类型的转换，这些TypeHandler都会记录在TypeHandlerRegistry中   */  protected final TypeHandlerRegistry typeHandlerRegistry;</code></pre><p><code>BaseBuilder</code>中记录的<code>TypeAliasRegistry</code>对象和<code>TypeHandlerRegistry</code>对象，其实是全局唯一的，它们都是在<code>Configuration</code>对象初始化时创建的，代码如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128145108-dgZGGY.png" srcset="undefined" alt=""></p><p>在<code>BaseBuilder</code>构造函数中，通过相应的<code>Configuration.get*()</code>方法得到<code>TypeAliasRegistry</code>和<code>TypeHandlerRegistry</code>对象，并赋值给<code>BaseBuilder</code>相应的字段。</p><pre><code class="java">  /**   * 构造方法   * @param configuration   */  public BaseBuilder(Configuration configuration) {    this.configuration = configuration;    this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();    this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();  }</code></pre><p><code>Configuration</code>中还包含了很多配置项，为了便于读者理解，这里不会罗杰出内个字段的含义，而是在后面介绍的过程中，每涉及到一个配置项时，会结合其在<code>Configuration</code>中相应字段进行详细分析。</p><p><code>BaseBuilder.resolveAlias()</code>方法依赖<code>TypeAliasRegistry</code>解析别名，<code>BaseBuilder.resolveTypeHandler()</code>方法依赖<code>TypeHandlerRegistry</code>查找指定的<code>TypeHandler</code>对象。在阅读完<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a>和<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#3-TypeHandlerRegistry" target="_blank" rel="noopener">TypeHandlerRegistry</a>的相关实现的介绍后，<code>BaseBuilder.resolveAlias()</code>和<code>BaseBuilder.resolveTypeHandler()</code>就不难理解了。</p><p>前面提到过，<code>Mybatis</code>使用<code>JdbcType</code>枚举类型表示<code>JDBC</code>类型。<code>Mybatis</code>中常用的枚举类型还有<code>ResultSetType</code>和<code>ParameterMode</code>：</p><ul><li><code>ResultSetType</code>枚举表示结果集类型；</li><li><code>ParameterMode</code>枚举类型表示存储过程中的参数类型。</li></ul><p>在<code>BaseBuilder</code>中提供了相应的<code>resolveJdbcType()</code>、<code>resolveResultSetType()</code>、<code>resolveParameterMode()</code>方法，将<code>String</code>转换成对应的枚举类型，实现比较简单。</p><h1 id="3-XMLConfigBuilder"><a href="#3-XMLConfigBuilder" class="headerlink" title="3. XMLConfigBuilder"></a>3. XMLConfigBuilder</h1><p><code>XMLConfigBuilder</code>是<code>BaseBuilder</code>的众多子类之一，它扮演的是具体建造者的角色。<code>XMLConfigBuilder</code>主要负责解析<code>mybatis-config.xml</code>配置文件，其核心字段如下：</p><ul><li>XPathParser</li><li>ReflectorFactory</li></ul><pre><code class="java">/**   *   标识是否被解析过mybatis-config.xml   */  private boolean parsed;  /**   * 用于解析mybatis-config.xml配置文件的XPathParse对象，   */  private final XPathParser parser;  /**   * 标识&lt;environment&gt;&lt;environment/&gt;配置的名称，默认读取&lt;environment&gt;&lt;environment/&gt;标签的default属性   */  private String environment;  /**   * ReflectorFactory负责创建和缓存Reflector对象   */  private final ReflectorFactory localReflectorFactory = new DefaultReflectorFactory();</code></pre><p><code>XMLConfigBuilder.parse()</code>方法是解析<code>mybatis-config.xml</code>配置文件的入口，它通过调用<code>XMLConfigBuilder.parseConfiguration()</code>方法实现整个解析过程，具体实现如下所示：</p><pre><code class="java">//XMLConfigBuilder.java/**   * 解析配置：   *    这里其实有一个细节，就是{@link #parsed} 字段，这是一个boolbean类型的，也就是默认值是false，   *    根据以下代码，发现只有当parsed = false才回去解析配置，为true的时候不会去解析，直接抛出异常，   *    这么做的原因是：因为在解析mybatis中配置文件的时候是一件很消耗性能的事情，所以只解析一次。   * @return configuration配置 （e.g. &lt;configuration&gt; ....&lt;configuration/&gt;）   */  public Configuration parse() {    if (parsed) {      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);    }    parsed = true;    //在mybatis-config.xml配置文件中查找&lt;configuration&gt;&lt;/configuration&gt;节点，并开始解析    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));    return configuration;  }</code></pre><pre><code class="java">//XMLConfigBuilder.java/**   * 解析Configuration标签中的配置   * @param root   */  private void parseConfiguration(XNode root) {    try {      //issue #117 read properties first      //解析&lt;properties&gt;节点      propertiesElement(root.evalNode(&quot;properties&quot;));      // 解析&lt;settings&gt;节点      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));      //设置vfsImpl字段      loadCustomVfs(settings);      //设置logImpl字段      loadCustomLogImpl(settings);      // 解析&lt;typeAliases&gt;节点      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));      // 解析&lt;plugins&gt;节点      pluginElement(root.evalNode(&quot;plugins&quot;));      // 解析&lt;objectFactory&gt;节点      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));      // 解析&lt;objectWrapperFactory&gt;节点      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));      // 解析&lt;reflectorFactory&gt;节点      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));      //将settings值设置到Configuration中      settingsElement(settings);      // read it after objectFactory and objectWrapperFactory issue #631      // 解析&lt;environments&gt;节点      environmentsElement(root.evalNode(&quot;environments&quot;));      // 解析&lt;databaseIdProvider&gt;节点      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));      // 解析&lt;typeHandlers&gt;节点      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));      // 解析&lt;mappers&gt;节点      mapperElement(root.evalNode(&quot;mappers&quot;));    } catch (Exception e) {      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);    }  }</code></pre><p><code>parseConfiguration()</code>方法的代码还是比较整洁的，我们可以清楚地看到，<code>XMLConfigBuilder</code>将<code>mybatis-config.xml</code>配置文件中每一个节点的解析过程封装成一个相应的方法，本小节的后续内容将逐一分析这些节点的解析过程。</p><h2 id="3-1-解析-lt-properties-gt-节点"><a href="#3-1-解析-lt-properties-gt-节点" class="headerlink" title="3.1. 解析&lt;properties&gt;节点"></a>3.1. 解析<code>&lt;properties&gt;</code>节点</h2><p><code>XMLConfigBuilder.propertiesElement()</code>方法会解析<code>mybatis-config.xml</code>配置文件中的<code>&lt;properties&gt;</code>节点，并信形成<code>java.uitl.Properties</code>对象，之后将该<code>Properties</code>对象设置到<code>XPathParser</code>和<code>Configuration</code>的<code>variable</code>字段中。在后面的解析过程中，会使用该<code>Properties</code>对象中的信息替换占位符。<code>propertiesElement()</code>方法的具体实现如下所示：</p><pre><code class="java">/**   * `XMLConfigBuilder.propertiesElement()`方法会解析`mybatis-config.xml`配置文件中的`&lt;properties&gt;`节点，   * 并信形成`java.uitl.Properties`对象，之后将该`Properties`对象设置到`XPathParser`和`Configuration`的`variable`字段中。   * 在后面的解析过程中，会使用该`Properties`对象中的信息替换占位符。   * @param context  e.g. &lt;properties resource=&quot;resources/config.properties&quot;&gt;   *                         &lt;property name=&quot;username&quot; value=&quot;xxx&quot;/&gt;   *                         &lt;property name=&quot;password&quot; value=&quot;xxx&quot;/&gt;   *                      &lt;/properties&gt;   * @throws Exception   */  private void propertiesElement(XNode context) throws Exception {    if (context != null) {      // username = xxx 和password = xxx 两个      Properties defaults = context.getChildrenAsProperties();      String resource = context.getStringAttribute(&quot;resource&quot;);      String url = context.getStringAttribute(&quot;url&quot;);      //properties元素不能同时指定URL和基于资源的属性文件引用。请指定其中一个。      if (resource != null &amp;&amp; url != null) {        throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);      }      //这个其实就是使用外部化配置覆盖内部值      if (resource != null) {        defaults.putAll(Resources.getResourceAsProperties(resource));      } else if (url != null) {        defaults.putAll(Resources.getUrlAsProperties(url));      }      Properties vars = configuration.getVariables();      if (vars != null) {        defaults.putAll(vars);      }      //更新XPathParser和Configuration的variable字段      parser.setVariables(defaults);      configuration.setVariables(defaults);    }  }</code></pre><h2 id="3-2-解析-lt-settings-gt-节点"><a href="#3-2-解析-lt-settings-gt-节点" class="headerlink" title="3.2. 解析&lt;settings&gt;节点"></a>3.2. 解析<code>&lt;settings&gt;</code>节点</h2><p><code>XMLConfigBuilder.settingsAsProperties()</code>方法负责解析<code>&lt;settings&gt;</code>节点，在<code>&lt;settings&gt;</code>节点下的配置是<strong>Mybatis全局性的配置</strong>，它们会改变<code>Mybatis</code>的运行时行为，具体的配置项的含义请阅读参考<a href="https://mybatis.org/mybatis-3/configuration.html#settings" target="_blank" rel="noopener">Mybatis官方文档</a>。需要注意的是，在<code>Mybatis</code>初始化时，这些全局配置信息都会被记录到<code>Configuration</code>对象的对应属性中。例如，开发人员可以通过设置————————。</p><p>在<code>Configuration</code>中存在一个同名的相应字段，如下：</p><p><code>settingsAsProperties()</code>方法的解析方式和<code>propertiesElement()</code>方法类似，但是多了使用<code>MetaClass</code>检测<code>key</code>指定的属性在<code>Configuration</code>类中是否有对应<code>setter</code>方法的步骤。<code>settingsAsProperties()</code>方法的代码如下所示：</p><pre><code class="java">  private Properties settingsAsProperties(XNode context) {    if (context == null) {      return new Properties();    }    Properties props = context.getChildrenAsProperties();    // Check that all settings are known to the configuration class    MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);    //使用`MetaClass`检测`key`指定的属性在`Configuration`类中是否有对应`setter`方法的步骤    for (Object key : props.keySet()) {      if (!metaConfig.hasSetter(String.valueOf(key))) {        throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);      }    }    return props;  }</code></pre><h2 id="3-3-设置vfsImpl和logImpl"><a href="#3-3-设置vfsImpl和logImpl" class="headerlink" title="3.3. 设置vfsImpl和logImpl"></a>3.3. 设置<code>vfsImpl</code>和<code>logImpl</code></h2><p>这两个参数一般不会去处理，所以我只罗列出来，不去解析：</p><h3 id="3-3-1-设置vfsImpl"><a href="#3-3-1-设置vfsImpl" class="headerlink" title="3.3.1. 设置vfsImpl"></a>3.3.1. 设置vfsImpl</h3><p>参看VFS详解</p><pre><code class="java">  private void loadCustomVfs(Properties props) throws ClassNotFoundException {    String value = props.getProperty(&quot;vfsImpl&quot;);    if (value != null) {      String[] clazzes = value.split(&quot;,&quot;);      for (String clazz : clazzes) {        if (!clazz.isEmpty()) {          @SuppressWarnings(&quot;unchecked&quot;)          Class&lt;? extends VFS&gt; vfsImpl = (Class&lt;? extends VFS&gt;)Resources.classForName(clazz);          configuration.setVfsImpl(vfsImpl);        }      }    }  }</code></pre><h3 id="3-3-2-设置logImpl"><a href="#3-3-2-设置logImpl" class="headerlink" title="3.3.2. 设置logImpl"></a>3.3.2. 设置logImpl</h3><pre><code class="java">  private void loadCustomLogImpl(Properties props) {    Class&lt;? extends Log&gt; logImpl = resolveClass(props.getProperty(&quot;logImpl&quot;));    configuration.setLogImpl(logImpl);  }</code></pre><h2 id="3-4-解析-lt-typeAliases-gt-节点"><a href="#3-4-解析-lt-typeAliases-gt-节点" class="headerlink" title="3.4. 解析&lt;typeAliases&gt;节点"></a>3.4. 解析<code>&lt;typeAliases&gt;</code>节点</h2><p><code>XMLConfigBuilder.typeAliasesElement()</code>负责解析<code>&lt;typeAliases&gt;</code>节点及其子节点，然后利用<a href="https://gnehcgnaw.github.io/Mybatis源码分析/基础支持层/类型转换.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a>完成别名的注册，具体实现如下所示：</p><pre><code class="java">private void typeAliasesElement(XNode parent) {    if (parent != null) {      for (XNode child : parent.getChildren()) {        /**         * 指定报名，MyBatis 会在包名下面搜索需要的 Java Bean         * 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。         * 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值 。         */        if (&quot;package&quot;.equals(child.getName())) {          String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);        } else {          String alias = child.getStringAttribute(&quot;alias&quot;);          String type = child.getStringAttribute(&quot;type&quot;);          try {            Class&lt;?&gt; clazz = Resources.classForName(type);            if (alias == null) {              typeAliasRegistry.registerAlias(clazz);            } else {              typeAliasRegistry.registerAlias(alias, clazz);            }          } catch (ClassNotFoundException e) {            throw new BuilderException(&quot;Error registering typeAlias for &#39;&quot; + alias + &quot;&#39;. Cause: &quot; + e, e);          }        }      }    }  }</code></pre><h2 id="3-5-解析-lt-plugins-gt-节点"><a href="#3-5-解析-lt-plugins-gt-节点" class="headerlink" title="3.5. 解析&lt;plugins&gt;节点"></a>3.5. 解析<code>&lt;plugins&gt;</code>节点</h2><p>插件是<code>Mybatis</code>提供的扩展机制之一，用户可以通过添加自定义插件在<code>SQL</code>语句执行过程中的某一点进行拦截。<code>Mybatis</code>中的自定义插件只需要实现<code>Interceptor</code>接口，并通过注解指定想要拦截的方法签名即可。在高级主题模块，将详细介绍插件的使用和原理，这里先来分析<code>Mybatis</code>中如何加载和管理插件。</p><p><code>XMLConfigBuilder.pluginElement()</code>方法负责解析<code>&lt;plugins&gt;</code>节点中定义的插件，并完成实例化和配置操作，具体实现如下所示：</p><pre><code class="java"> private void pluginElement(XNode parent) throws Exception {    if (parent != null) {      //遍历全部的子节点，即遍历&lt;plugins&gt;      for (XNode child : parent.getChildren()) {        //获取&lt;plugin&gt;节点的interceptor属性的值        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);        //获取&lt;plugin&gt;下&lt;properties&gt;配置的信息，并形成Properties对象        Properties properties = child.getChildrenAsProperties();        //通过别名获取对应的Clazz，然后通过反射实例化Interceptor对象        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();        //为当前interceptor设置属性值        interceptorInstance.setProperties(properties);        //记录Interceptor对象        configuration.addInterceptor(interceptorInstance);      }    }  }</code></pre><h2 id="3-6-解析-lt-objectFactory-gt-、-lt-objectWrapperFactory-gt-、-lt-reflectorFactory-gt-节点"><a href="#3-6-解析-lt-objectFactory-gt-、-lt-objectWrapperFactory-gt-、-lt-reflectorFactory-gt-节点" class="headerlink" title="3.6. 解析&lt;objectFactory&gt;、&lt;objectWrapperFactory&gt;、&lt;reflectorFactory&gt;节点"></a>3.6. 解析<code>&lt;objectFactory&gt;</code>、<code>&lt;objectWrapperFactory&gt;</code>、<code>&lt;reflectorFactory&gt;</code>节点</h2><p>我们可以通过自定义添加ObjectFactory、ObjectWarpperFactroy、ReflectorFactory的实现类来扩展<code>Mybatis</code>。</p><p><code>XMLConfigBuilder.objectFactoryElement()</code>方法负责解析并实例化<code>&lt;objectFactory&gt;</code>节点指定的<code>ObjectFactory</code>的实现类，之后将自定义的<code>ObjectFactory</code>对象记录在<code>Configuration.objectFactory</code>字段中，具体实现如下所示：</p><pre><code class="java">  private void objectFactoryElement(XNode context) throws Exception {    if (context != null) {      //获取&lt;objectFactory&gt;中的type属性      String type = context.getStringAttribute(&quot;type&quot;);      //获取&lt;objectFactory&gt;节点下的配置信息，并形成Properties对象      Properties properties = context.getChildrenAsProperties();      //通过别名获取对应的clazz，然后实例化ObjectFactory      ObjectFactory factory = (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();      //为实例化的ObjectFactory对象设置属性      factory.setProperties(properties);      //记录ObjectFactory对象      configuration.setObjectFactory(factory);    }  }</code></pre><p>XMLConfigBuilder对<code>&lt;objectWrapperFactory&gt;</code>和<code>&lt;reflectorFactory&gt;</code>节点的解析，和上述过程类似。</p><h2 id="3-7-将settings值设置到Configuration中"><a href="#3-7-将settings值设置到Configuration中" class="headerlink" title="3.7. 将settings值设置到Configuration中"></a>3.7. 将<code>settings</code>值设置到<code>Configuration</code>中</h2><p><code>XMLConfigBuilder.settingsElement()</code>这个就是最简单的赋值操作，如下所示：</p><pre><code class="java">  private void settingsElement(Properties props) {    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(&quot;autoMappingUnknownColumnBehavior&quot;, &quot;NONE&quot;)));    configuration.setCacheEnabled(booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;), true));    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(&quot;proxyFactory&quot;)));    configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(&quot;lazyLoadingEnabled&quot;), false));    configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(&quot;aggressiveLazyLoading&quot;), false));    configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(&quot;multipleResultSetsEnabled&quot;), true));    configuration.setUseColumnLabel(booleanValueOf(props.getProperty(&quot;useColumnLabel&quot;), true));    configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(&quot;useGeneratedKeys&quot;), false));    configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(&quot;defaultExecutorType&quot;, &quot;SIMPLE&quot;)));    configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(&quot;defaultStatementTimeout&quot;), null));    configuration.setDefaultFetchSize(integerValueOf(props.getProperty(&quot;defaultFetchSize&quot;), null));    configuration.setDefaultResultSetType(resolveResultSetType(props.getProperty(&quot;defaultResultSetType&quot;)));    configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(&quot;mapUnderscoreToCamelCase&quot;), false));    configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(&quot;safeRowBoundsEnabled&quot;), false));    configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(&quot;localCacheScope&quot;, &quot;SESSION&quot;)));    configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(&quot;jdbcTypeForNull&quot;, &quot;OTHER&quot;)));    configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(&quot;lazyLoadTriggerMethods&quot;), &quot;equals,clone,hashCode,toString&quot;));    configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(&quot;safeResultHandlerEnabled&quot;), true));    configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(&quot;defaultScriptingLanguage&quot;)));    configuration.setDefaultEnumTypeHandler(resolveClass(props.getProperty(&quot;defaultEnumTypeHandler&quot;)));    configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(&quot;callSettersOnNulls&quot;), false));    configuration.setUseActualParamName(booleanValueOf(props.getProperty(&quot;useActualParamName&quot;), true));    configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(&quot;returnInstanceForEmptyRow&quot;), false));    configuration.setLogPrefix(props.getProperty(&quot;logPrefix&quot;));    configuration.setConfigurationFactory(resolveClass(props.getProperty(&quot;configurationFactory&quot;)));  }</code></pre><h2 id="3-8-解析-lt-environments-gt-节点"><a href="#3-8-解析-lt-environments-gt-节点" class="headerlink" title="3.8. 解析&lt;environments&gt;节点"></a>3.8. 解析<code>&lt;environments&gt;</code>节点</h2><p>在实际生产中，同一项目可能分为开发、测试和生产多个不同的环境，每个环境的配置可能不尽相同。Mybatis可以配置多个<code>&lt;environment&gt;</code>节点，每个<code>&lt;environment&gt;</code>节点对应一种环境的配置。但是需要注意的是，尽管可以配置多环境，每个SqlSessionFactory实例只能选择其一。</p><p><code>XMLConfigBuilder.environmentElement()</code>方法负责解析<code>&lt;environment&gt;</code>的相关配置，它会根据<code>XMLConfigBuilder.environmen</code>t字段值确定要使用的<code>&lt;environment&gt;</code>配置，之后创建对应的TransactionFactory和<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/DataSource.html#2-DataSourceFactory" target="_blank" rel="noopener">DataSourceFactroy</a>对象，通过<code>DataSourceFactory.getDataSource()</code>获取DataSource对象，并封装进<code>Environment</code>对象中。<code>environmentElement()</code>方法的具体实现如下：</p><pre><code class="java"> private void environmentsElement(XNode context) throws Exception {    if (context != null) {      //未指定XMLConfigBuilder#environment字段的值，那么使用default属性指定的&lt;environment&gt;&lt;/environment&gt;      if (environment == null) {        environment = context.getStringAttribute(&quot;default&quot;);      }      for (XNode child : context.getChildren()) {        String id = child.getStringAttribute(&quot;id&quot;);        //检测字段与XMLConfigBuilder#environment字段是否匹配        if (isSpecifiedEnvironment(id)) {          //创建TransactionFactory：具体实现是先通过TypeAliasRegistry解析别名之后，实例化TransactionFactory          TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));          //创建DataSourceFactory然后得到DataSource          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));          DataSource dataSource = dsFactory.getDataSource();          //创建Environment对象，Environment中封装了上面创建的TransactionFactory和DataSource对象，这里应用的是建造者模式          Environment.Builder environmentBuilder = new Environment.Builder(id)              .transactionFactory(txFactory)              .dataSource(dataSource);          //将Environment对象，记录在Configuration.environment字段中          configuration.setEnvironment(environmentBuilder.build());        }      }    }  }</code></pre><h2 id="3-9-解析-lt-databaseIdProvider-gt-节点"><a href="#3-9-解析-lt-databaseIdProvider-gt-节点" class="headerlink" title="3.9.  解析&lt;databaseIdProvider&gt;节点"></a>3.9.  解析<code>&lt;databaseIdProvider&gt;</code>节点</h2><p>Mybatis不能像Hibernate那样使用<a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#database-dialect" target="_blank" rel="noopener">hibernate.dialect</a>进行设置，然后直接帮助开发人员屏蔽多种数据库产品在<code>SQL</code>语言支持方言的差异。但是可以在<code>mybatis-config.xml</code>配置文件中，通过<code>&lt;databaseIdProvider&gt;</code>定义所有支持的数据库产品的<code>databaseId</code>，然后在映射文件中定义<code>SQL</code>语句节点中，通过<code>databaseId</code>指定该<code>SQL</code>语句应用的数据库产品，这样也可以实现类似的功能。</p><p>在<code>Mybatis</code>初始化时，会根据前面确定的<code>DataSource</code>确定当前使用的数据库产品，然后在解析映射配置文件时，加载不带<code>databaseId</code>属性和带有匹配当前数据库<code>databaseId</code>属性的所有<code>SQL</code>语句。如果同时找到了带<code>databaseId</code>和不带<code>databaseId</code>的相同语句，则后者会被舍弃，使用前者。</p><p><code>XMLConfigBuilder.databaseIdProviderElement()</code>方法负责解析<code>&lt;databaseIdProvider&gt;</code>节点，并创建指定的DatabaseIdProvider对象。<code>DatabaseIdProvider</code>会返回一个<code>databaseId</code>值，<code>Mybatis</code>会根据<code>databaseId</code>选择合适的<code>SQL</code>去执行。</p><pre><code class="java">private void databaseIdProviderElement(XNode context) throws Exception {    DatabaseIdProvider databaseIdProvider = null;    if (context != null) {      String type = context.getStringAttribute(&quot;type&quot;);      // awful patch to keep backward compatibility      //为了保证兼容性，修改type取值 &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;      if (&quot;VENDOR&quot;.equals(type)) {        type = &quot;DB_VENDOR&quot;;      }      //解析相关配置信息      Properties properties = context.getChildrenAsProperties();      //创建DatabaseIdProvider对象      databaseIdProvider = (DatabaseIdProvider) resolveClass(type).getDeclaredConstructor().newInstance();      //配置DatabaseIdProvider，完成初始化      databaseIdProvider.setProperties(properties);    }    Environment environment = configuration.getEnvironment();    if (environment != null &amp;&amp; databaseIdProvider != null) {      //通过前面确定的DataSource获取databaseId,并记录到Configuration.databaseId字段中      String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());      configuration.setDatabaseId(databaseId);    }  }</code></pre><h2 id="3-10-解析-lt-typeHandlers-gt-节点"><a href="#3-10-解析-lt-typeHandlers-gt-节点" class="headerlink" title="3.10. 解析&lt;typeHandlers&gt;节点"></a>3.10. 解析<code>&lt;typeHandlers&gt;</code>节点</h2><h2 id="3-11-解析-lt-mappers-gt-节点"><a href="#3-11-解析-lt-mappers-gt-节点" class="headerlink" title="3.11. 解析&lt;mappers&gt;节点"></a>3.11. 解析<code>&lt;mappers&gt;</code>节点</h2><p>在Mybatis初始化时，除了加载mybatis-config.xml配置文件，还会加载全部的映射配置文件，mybatis-config.xml配置文件中的<mappers>节点会告诉我Mybatis去哪些位置查找映射配置文件以及使用了配置注解表示的接口。</p><p>XMLConfigBuilder.mapperElement()方法负责解析<mappers>节点，它会创建XMLMapperBuilder对象加载映射文件，如果映射配置文件存在相应的Mapper接口，也会加载相应的Mapper接口，解析其中的注解并完成向MapperRegistry的注册。</p><pre><code class="java">  private void mapperElement(XNode parent) throws Exception {    if (parent != null) {      //处理&lt;mappers&gt;的子节点      for (XNode child : parent.getChildren()) {        //处理&lt;package&gt;节点        if (&quot;package&quot;.equals(child.getName())) {          String mapperPackage = child.getStringAttribute(&quot;name&quot;);          //扫描指定的包，并向MapperRegistry注册Mapper接口          configuration.addMappers(mapperPackage);        } else {          //获取&lt;mapper&gt;节点的resource、url、class属性，这三个属性是互斥的          String resource = child.getStringAttribute(&quot;resource&quot;);          String url = child.getStringAttribute(&quot;url&quot;);          String mapperClass = child.getStringAttribute(&quot;class&quot;);          //如果&lt;mapper&gt;节点指定了resource或者url属性，则创建XMLMapperBuilder对象，并通过该对象解析resource或url属性指定的Mapper配置文件          if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {            ErrorContext.instance().resource(resource);            InputStream inputStream = Resources.getResourceAsStream(resource);            //创建XMLMapperBuilder对象，解析映射配置文件            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());            mapperParser.parse();          } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {            ErrorContext.instance().resource(url);            InputStream inputStream = Resources.getUrlAsStream(url);            //创建XMLMapperBuilder对象，解析映射配置文件            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());            mapperParser.parse();          } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);            //如果&lt;mapper&gt;节点指定了class属性，则向MapperRegistry注册该Mapper接口            configuration.addMapper(mapperInterface);          } else {            throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);          }        }      }    }  }</code></pre><p><code>Mybatis</code>初始化过程中对<code>mybatis-config.xml</code>配置文件的解析过程到这里也就结束了，<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%BA%8C).html" target="_blank" rel="noopener">Mybatis初始化（二）</a>会接续介绍，介绍<code>Mybatis</code>对映射文件的解析过程。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis初始化(二)</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%BA%8C).html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%BA%8C).html</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis初始化-二"><a href="#Mybatis初始化-二" class="headerlink" title="Mybatis初始化(二)"></a>Mybatis初始化(二)</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>​        JDBC数据类型与Java语言中的数据类型并不是完全对应的，所以在<code>PreparedStatement</code>为<code>SQL</code>语句绑定参数是，需要从<code>Java</code>类型转换成<code>JDBC</code>类型，而从<code>ResultSet</code>中获取数据时，则需要从<code>JDBC</code>类型转换成<code>Java</code>类型。<code>Mybatis</code>使用类型转换器完成上述两种转换。据图如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127092014-iVyREJ.png" srcset="undefined" alt=""></p><p>​        在<code>Mybatis</code>中使用<code>JdbcType</code>这种枚举类型代表<code>JDBC</code>中的数据类型，该枚举类型中定义了<code>TYPE_CODE</code>字段，记录了<code>JDBC</code>类中在<code>java.sql.Types</code>中相应的常量编码，并通过一个静态集合<code>codeLookUp（HashMap&lt;Integer,JdbcType&gt;类型）</code>维护了常量编码与<code>JdbcType</code>之间的对应关系。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127093418-Gzcley.png" srcset="undefined" alt=""></p><h1 id="2-TypeHandler"><a href="#2-TypeHandler" class="headerlink" title="2. TypeHandler"></a>2. TypeHandler</h1><p>​        Mybatis中所有的类型转换器都继承了<code>TypeHandler</code>接口，在<code>TypeHandler</code>接口中定义了如下四种方法，这四种方法分为两类：</p><ul><li><code>setParameter()</code>方法<ul><li>负责将数据由<code>Java</code>类型转换成<code>JdbcType</code>类型</li></ul></li><li><code>getResultSet()</code>方法<ul><li>负责将数据由<code>JdbcType</code>类型转换成<code>Java</code>类型</li></ul></li></ul><pre><code class="java">package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 类型处理器 * 说白了typeHandlers就是用来完成javaType和jdbcType之间的转换 * @author Clinton Begin */public interface TypeHandler&lt;T&gt; {  /**   * 通过PreparedStatement为Sql语句绑定参数是，会将数据从Java类型转换成JdbcType类型   * @param ps   * @param i 转换第几个参数   * @param parameter 参数   * @param jdbcType  要转换的jdbcType的类型   * @throws SQLException   */  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;  /**   * 从ResultSet中获取数据时会调用此方法，将数据有JdbcType类型转换为Java类型   * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;   */  T getResult(ResultSet rs, String columnName) throws SQLException;  T getResult(ResultSet rs, int columnIndex) throws SQLException;  T getResult(CallableStatement cs, int columnIndex) throws SQLException;}</code></pre><p>​        为了方便用户自定义<code>TypeHandler</code>实现，<code>Mybatis</code>提供了<code>BaseTypeHandler</code>这个抽象类，它实现了<code>TypeHandler</code>几口，并继承了<code>TypeReference</code>抽象类，其继承结构如下所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127095043-dUqC8a.png" srcset="undefined" style="zoom:50%;" /><p>在<code>BaseTypeHandler</code>中实现了<code>setParameter()</code>和<code>getResult()</code>方法，具体如下所示。</p><pre><code class="java">/**   * 在设置参数的时候，只处理为null的数据，不为空的数据都交给了子类实现   * @param ps   * @param i 转换第几个参数   * @param parameter 参数   * @param jdbcType  要转换的jdbcType的类型   * @throws SQLException   */  @Override  public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {    if (parameter == null) {      if (jdbcType == null) {        throw new TypeException(&quot;JDBC requires that the JdbcType must be specified for all nullable parameters.&quot;);      }      try {        ps.setNull(i, jdbcType.TYPE_CODE);      } catch (SQLException e) {        throw new TypeException(&quot;Error setting null for parameter #&quot; + i + &quot; with JdbcType &quot; + jdbcType + &quot; . &quot;              + &quot;Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. &quot;              + &quot;Cause: &quot; + e, e);      }    } else {      try {        //参数不为空，交给子类处理        setNonNullParameter(ps, i, parameter, jdbcType);      } catch (Exception e) {        throw new TypeException(&quot;Error setting non null for parameter #&quot; + i + &quot; with JdbcType &quot; + jdbcType + &quot; . &quot;              + &quot;Try setting a different JdbcType for this parameter or a different configuration property. &quot;              + &quot;Cause: &quot; + e, e);      }    }  }public abstract void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;</code></pre><pre><code class="java">  @Override  public T getResult(ResultSet rs, String columnName) throws SQLException {    try {      return getNullableResult(rs, columnName);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column &#39;&quot; + columnName + &quot;&#39; from result set.  Cause: &quot; + e, e);    }  }  @Override  public T getResult(ResultSet rs, int columnIndex) throws SQLException {    try {      return getNullableResult(rs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column #&quot; + columnIndex + &quot; from result set.  Cause: &quot; + e, e);    }  }  @Override  public T getResult(CallableStatement cs, int columnIndex) throws SQLException {    try {      return getNullableResult(cs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column #&quot; + columnIndex + &quot; from callable statement.  Cause: &quot; + e, e);    }  }  /**   * 3.5.0版本之后getResult方法，不管是空还是非空数据都要交给子类去处理   * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;   */  public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException;  public abstract T getNullableResult(ResultSet rs, int columnIndex) throws SQLException;  public abstract T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException;</code></pre><p>​        <strong>需要注意的是：</strong>在<code>Mybatis3.5</code>及其之后版本，<code>BaseTypeHandler.setParemeter()</code>只处理空参，非空参数交于子类处理，<code>BaseTypeHandler.getResult()</code>不管是空值还是非空都交于子类处理，而<code>Mybatis3.5</code>版本之前，<code>BaseTypeHandler.setParemeter()</code>和<code>BaseTypeHandler.getResult()</code>都是只对空参进行处理的。</p><p>​        <code>BaseTypeHandler</code>的实现类是比较多的，但是实现比较简单。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127101750-TJLaJn.png" srcset="undefined" style="zoom:67%;" /><p>这里以<code>IntergerTypeHandler</code>为例简单介绍：</p><pre><code class="java">package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @author Clinton Begin */public class IntegerTypeHandler extends BaseTypeHandler&lt;Integer&gt; {  @Override  public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType)      throws SQLException {    //调用PreparedStatement.setInt()实现参数绑定    ps.setInt(i, parameter);  }  @Override  public Integer getNullableResult(ResultSet rs, String columnName)      throws SQLException {    //调用ResultSet.getInt获取指定列值    int result = rs.getInt(columnName);    return result == 0 &amp;&amp; rs.wasNull() ? null : result;  }  @Override  public Integer getNullableResult(ResultSet rs, int columnIndex)      throws SQLException {    //调用ResultSet.getInt获取指定列值    int result = rs.getInt(columnIndex);    return result == 0 &amp;&amp; rs.wasNull() ? null : result;  }  @Override  public Integer getNullableResult(CallableStatement cs, int columnIndex)    //调用ResultSet.getInt获取指定列值      throws SQLException {    int result = cs.getInt(columnIndex);    return result == 0 &amp;&amp; cs.wasNull() ? null : result;  }}</code></pre><p>​        一般情况下，<code>TypeHandler</code>用于完成单个参数及其单个列值的类型转换，如果存在多列值转换成一个<code>Java</code>对象的需求，应该优先考虑使用在映射文件中定义合适的映射规则（<code>&lt;resultMap&gt;</code>节点）完成映射。</p><h1 id="3-TypeHandlerRegistry"><a href="#3-TypeHandlerRegistry" class="headerlink" title="3. TypeHandlerRegistry"></a>3. TypeHandlerRegistry</h1><p>​        介绍完<code>TypeHandler</code>接口及其功能之后，<code>Mybatis</code>如何管理众多的<code>TypeHandler</code>接口实现，如何知道何时使用哪个<code>TypeHandler</code>接口实现完成转换呢？这是有本小节介绍的<code>TypeHandlerRegistry</code>完成的，在<code>Mybatis</code>初始化过程中，会为所有已知的<code>TypeHandler</code>创建对象，并实现注册到<code>TypeHandlerRegistry</code>中，有<code>TypeHandlerRegistry</code>负责管理这些<code>TypeHandler</code>对象。<br>​        下面先来看看<code>TypeHandlerRegistry</code>中的核心字段的含义：</p><pre><code class="java">  /**   * 记录jdbcType与TypeHandler之间的对应关系，其中JdbcType是一个枚举类型，它定义对应了的JDBC类型   * 该集合主要用于从结果集读取数据是，将数据从jdbc类型转换成Java类型   */  private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap = new EnumMap&lt;&gt;(JdbcType.class);  /**   * 记录了Java类型向指定的jdbcType转换时，需要使用的TypeHandler对象。   * 例如：Java类型中的String 可能转换为数据库的char、varchar等多种类型，所以存在一对多关系   */  private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;();  /**   * 未知类型TypeHandler   */  private final TypeHandler&lt;Object&gt; unknownTypeHandler;  /**   * 记录了全部的TypeHandler的类型以及该类型相应的TypeHandler对象   */  private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = new HashMap&lt;&gt;();  /**   * 空TypeHandler集合的标识   */  private static final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap();  /**   * 默认枚举类型处理器   */  private Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;</code></pre><h2 id="3-1-TypeHandlerRegistry构造方法"><a href="#3-1-TypeHandlerRegistry构造方法" class="headerlink" title="3.1. TypeHandlerRegistry构造方法"></a>3.1. TypeHandlerRegistry构造方法</h2><p><code>TypeHandlerRegistry</code>构造中综合起来做了三步操作：</p><ol><li>创建了一个<code>Configuration</code>，或者通过<code>mybatis-config.xml</code>的初始化传入一个<code>Configuration</code>到<code>TypeHandlerRegistry</code>构造中；</li><li>利用传入的<code>configuration</code>对象，创建一个<code>UnknownTpyeHandler</code>，以备后续使用；</li><li>注册一堆<code>Mybatis</code>为我们提供的默认的<code>TypeHandler</code>。</li></ol><h2 id="3-2-注册TypeHandler对象"><a href="#3-2-注册TypeHandler对象" class="headerlink" title="3.2. 注册TypeHandler对象"></a>3.2. 注册TypeHandler对象</h2><p>TypeHandlerRegistry.register()方法实现了注册TypeHandler对象的功能，register()方法有多个重载，这些重载之间的调用关系如下图所示。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127172443-pn2dhu.png" srcset="undefined" alt=""></p><p>由上图可以看出，多数的register()方法最终会调用重载7完成注册功能，所以先分析重载7，该方法有三个参数分别是：</p><ul><li><code>Type javaType</code></li><li><code>JdbcType jdbcType</code></li><li><code>TypeHandler&lt;T&gt; handler</code></li></ul><pre><code class="java"> /**   * 最终调用到的重载方法   * @param javaType  能够处理的Java类型   * @param jdbcType   * @param handler   */  // 7  private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) {    //检测是否明确指定了TypeHandler能够处理的Java类型    if (javaType != null) {      //获取指定Java类型在typeHandlerMap集合中对应的TypeHandler集合      Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);      //如果map为空或者等于NULL_TYPE_HANDLER_MAP，创建新的TypeHandler集合，并添加到typeHandlerMap中      if (map == null || map == NULL_TYPE_HANDLER_MAP) {        map = new HashMap&lt;&gt;();        typeHandlerMap.put(javaType, map);      }      //将TypeHandler对象注册到typeHandlerMap集合中      map.put(jdbcType, handler);    }    //向allTypeHandlersMap集合注册TypeHandler类型和对应的TypeHandler对象    allTypeHandlersMap.put(handler.getClass(), handler);  }</code></pre><h2 id="3-3-查找TypeHandler"><a href="#3-3-查找TypeHandler" class="headerlink" title="3.3. 查找TypeHandler"></a>3.3. 查找TypeHandler</h2><p>介绍完注册<code>TypeHandler</code>对象的功能之后，再来介绍<code>TypeHandlerRegistry</code>提供的查找<code>TypeHandler</code>对象的功能。</p><h1 id="4-TypeAliasRegistry"><a href="#4-TypeAliasRegistry" class="headerlink" title="4. TypeAliasRegistry"></a>4. TypeAliasRegistry</h1><p>在编写<code>SQL</code>语句时，使用别名可以方便理解以及维护，例如表名或列名很长时，我们一般会为其设计易懂易维护的别名。<code>Mybatis</code>将<code>SQL</code>语句中的别名的概念进行了延伸和扩展，<code>Mybatis</code>可以为一个类添加一个别名，之后就可以通过别名引用该类。</p><p><code>Mybati</code>通过<code>TypeAliasRegistry</code>类完成别名的注册和管理功能，<code>TypeAliasRegistry</code>的结构比较简单，它通过<code>typeAliases</code>字段（<code>Map&lt;String, Class&lt;?&gt;&gt;</code>类型）管理别名与Java类型之间的对应关系，通过<code>TypeAliasRegistry.registerAlias()</code>方法完成注册别名，该方法的实现如下所示：</p><pre><code class="java">  /**   * 注册类型别名   * @param alias 被注册类的别名   * @param value  被注册的类   */  public void registerAlias(String alias, Class&lt;?&gt; value) {    if (alias == null) {      throw new TypeException(&quot;The parameter alias cannot be null&quot;);    }    // issue #748    //所有的类型最终都被转换为了小写，所以之前不管你是大写还是小写，最后都不转化了，不要因为大小写是不一样的。    String key = alias.toLowerCase(Locale.ENGLISH);    if (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != null &amp;&amp; !typeAliases.get(key).equals(value)) {      throw new TypeException(&quot;The alias &#39;&quot; + alias + &quot;&#39; is already mapped to the value &#39;&quot; + typeAliases.get(key).getName() + &quot;&#39;.&quot;);    }    typeAliases.put(key, value);  }</code></pre><p><code>TypeAliasRegistry</code>还有很多<code>registerAlias()</code>的重载，如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129164654-qjl9So.png" srcset="undefined" alt=""></p><p>其中还有两个重载需要我们注意：</p><ul><li><p>扫描包的</p><pre><code class="java">  /**   * 扫描指定包下面所有的类，并为其类的子类添加别名   * @param packageName   * @param superType   */  public void registerAliases(String packageName, Class&lt;?&gt; superType) {    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();    for (Class&lt;?&gt; type : typeSet) {      // Ignore inner classes and interfaces (including package-info.java)      // Skip also inner classes. See issue #6      if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) {        registerAlias(type);      }    }  }</code></pre></li><li><p>尝试读取<code>@Alias</code>注解的</p><pre><code class="java">  public void registerAlias(Class&lt;?&gt; type) {    //获取类的简单名称，不包括包名    String alias = type.getSimpleName();    //读取Alias注解    Alias aliasAnnotation = type.getAnnotation(Alias.class);    if (aliasAnnotation != null) {      alias = aliasAnnotation.value();    }    registerAlias(alias, type);  }</code></pre></li></ul><p>在<code>TypeAliasRegistry</code>的构造方法中，默认为Java的基本类型及其数组类型、基本类型的包装类型以及数组类型、<code>Data</code>、<code>BigDecimal</code>、<code>ResultSet</code>等类型添加了别名，可以参考<code>Mybatis</code>官网文档（<a href="https://mybatis.org/mybatis-3/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases模块</a>）。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射工具箱</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html</url>
    
    <content type="html"><![CDATA[<h1 id="反射工具箱"><a href="#反射工具箱" class="headerlink" title="反射工具箱"></a>反射工具箱</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​        Mybatis在进行参数处理、结果集映射等操作时，会涉及大量的反射操作。Java中的反射虽然功能强大，但是代码编写起来比较复杂容易出错，为了简化反射操作的相关代码，Mybatis提供了专门的反射模块，该模块位于<code>org.apache.ibatis.reflection</code>包中，它对常见的反射操作做了封装，提供了更加简洁方便的反射API。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126092626-rve1an.png" srcset="undefined" style="zoom:67%;" /><h1 id="2-Reflector-amp-ReflectorFactory"><a href="#2-Reflector-amp-ReflectorFactory" class="headerlink" title="2. Reflector&amp;ReflectorFactory"></a>2. Reflector&amp;ReflectorFactory</h1><h2 id="2-1-Reflector"><a href="#2-1-Reflector" class="headerlink" title="2.1. Reflector"></a>2.1. Reflector</h2><p>​         <code>Reflector</code>是<code>Mybatis</code>中反射模块的基础，每个<code>Reflector</code>对象都对应一个类，在Reflector中缓存了反射操作需要使用的类的元信息。Reflector中各个字段的含义如下所示：</p><pre><code class="java">/**   * 对应类的类型   */  private final Class&lt;?&gt; type;  /**   * 可读属性的名称集合，可读属性就是存在相应的getter方法的属性，初始值为空数组   */  private final String[] readablePropertyNames;  /**   * 可写属性的名称集合，可写属性就是存在相应setter方法的属性，初始值为空数组   */  private final String[] writablePropertyNames;  /**   * 记录了属性相应的setter方法，key是属性名称，value是Invoke对象，它是对setter方法对应Method对象的封装，后面会详细介绍   */  private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法集合，key是属性名称，value是Invoke对象，   */  private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法的返回值类型，key是属性名称，value是getter方法的返回值类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;();  /**   * 记录了默认的构造方法   */  private Constructor&lt;?&gt; defaultConstructor;  /**   * 记录了所有属性名称的集合   */  private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;();</code></pre><p>​        在<code>Reflector</code>的构造方法中会解析指定的<code>Class</code>对象，并填充上述集合，具体实现如下所示：</p><pre><code class="java">/**   * 此构造方法中会解析指定的Class对象，并填充上述集合   * @param clazz 需要解析的Class对象   */  public Reflector(Class&lt;?&gt; clazz) {    //初始化type字段    type = clazz;    //查找clazz的默认构造方法（无参构造方法），具体实现是通过反射遍历所有构造方法    addDefaultConstructor(clazz);    //处理clazz中的getter方法，填充getMethods集合和getTypes集合    addGetMethods(clazz);    //处理clazz中的setter方法，填充setMethods集合和setTypes集合    addSetMethods(clazz);    //处理没有getter/setter方法的字段    addFields(clazz);    //根据getMethods和setMethods集合，初始化可读、可写属性的名称集合    readablePropertyNames = getMethods.keySet().toArray(new String[0]);    writablePropertyNames = setMethods.keySet().toArray(new String[0]);    //初始化caseInsensitivePropertyMap，其中记录了所有大写格式的属性名称    for (String propName : readablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }    for (String propName : writablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }  }</code></pre><p>​        以上代码中<code>addDefaultConstructor(clazz);</code>很是简单，所以没有必要去分析这个方法，其次就是<code>addGetMethods(clazz);</code>和<code>addSetMethods(clazz);</code>方法，<code>Reflector.addGetMethods()</code>方法主要腹泻解析类中定义的<code>getter</code>方法，<code>Reflector.addSetMethods()</code>方法负责解析类中的<code>setter</code>方法，两者的逻辑类似，这里以<code>addSetMethods(clazz);</code>方法为例进行介绍，<code>addSetMethods()</code>方法不做详细介绍，<code>Reflector.addGetMethods()</code>主要有如下三个核心步骤：</p><pre><code class="java">/**   * 负责解析类中的get方法   * @param clazz   */  private void addGetMethods(Class&lt;?&gt; clazz) {    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;&gt;();    /**     * 1. 调用{@link Reflector#getClassMethods(Class)} 方法获取当前类以及其父类中定义的所有方法的唯一签名以及相应的Method对象。     */    Method[] methods = getClassMethods(clazz);    /**     * 2. 按照JavaBean的规范，从Reflector#getClassMethods(Class)方法返回的Methods数组中查找该类中定义的getter方法，     *    将其记录在conflictingGetters集合中，conflictingGetters集合（ Map&lt;String, List&lt;Method&gt;&gt;类型）的key为属性名称，value是该属性对应的getter方法集合。     *     *    2.1. 具体步骤     *      2.1.1. 得到所有的get方法，（参数类别为空，标志是get的方法）；     *      2.1.2. 将得到的get方法添加到方法冲突集合中；     *          例如：父类 public List&lt;User&gt; getUserList(); 子类 public ArrayList&lt;User&gt; getUserList();     *               在进行{@link Reflector#getClassMethods(Class)}中的{@link Reflector#getSignature(Method)}返回结果是：     *               java.util.List#getUserList和java.util.ArrayList#getUserList，即得到两个方法签名，在{@link Reflector#addUniqueMethods(Map, Method[])}     *               方法中会被认为是两个不同的方法添加到 uniqueMethods集合中，这显然不是我们想要的结果。     *     *  所以后续步骤3 会去解决这种Getter方法的冲突。     *     *  (lambda表达式 :filter forEach )     */    Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));    /**     * 3. 解决Getter冲突     *   1. 为什么会产生冲突呢？     *      步骤2已经解释过为什么会产生冲突了。     *   2. 解决方式是什么？     */    resolveGetterConflicts(conflictingGetters);  }</code></pre><ul><li><p>首先，调用<code>Reflector.getClassMethods()</code>方法获取当前类及其父类中定义的所以方法的唯一签名以及相应的<code>Methods</code>对象。</p><pre><code class="java">private Method[] getClassMethods(Class&lt;?&gt; clazz) {    Map&lt;String, Method&gt; uniqueMethods = new HashMap&lt;&gt;();    Class&lt;?&gt; currentClass = clazz;    while (currentClass != null &amp;&amp; currentClass != Object.class) {      //记录currentClass这个类中定义的全部方法      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());      // we also need to look for interface methods -      // because the class may be abstract      // 记录接口中定义的方法      Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();      for (Class&lt;?&gt; anInterface : interfaces) {        addUniqueMethods(uniqueMethods, anInterface.getMethods());      }      //获取父类，继续while循环      currentClass = currentClass.getSuperclass();    }    Collection&lt;Method&gt; methods = uniqueMethods.values();    //转换成Methods方法数组返回    return methods.toArray(new Method[0]);  }</code></pre><p>在<code>Reflector.addUniqueMethods()</code>方法中会为每个方法生成唯一签名，并记录到<code>uniqueMethods</code>集合中，具体实现如下所示：</p><pre><code class="java"> /**   * 为每个方法生成一个唯一签名，并记录到uniqueMethods集合中   * @param uniqueMethods   * @param methods   */  private void addUniqueMethods(Map&lt;String, Method&gt; uniqueMethods, Method[] methods) {    for (Method currentMethod : methods) {      if (!currentMethod.isBridge()) {        /**         * 通过{@link Reflector#getSignature(Method)}方法得到方法的签名是：返回值类型#方法名称：参数类型列表。         * 例如： Reflector.getSignature(Method)的方法签名是：java.lang.String#getSignature:java.lang.reflect.Method         * 通过Reflector.getSignature(Method)方法得到的方法签名是全局唯一的，可以作为该方法的唯一标识         */        String signature = getSignature(currentMethod);        // check to see if the method is already known        // if it is known, then an extended class must have        // overridden a method        /**         * 检查是否添加过该方法，如果添加过，就无须在向uniqueMethods中添加该方法了。         * 其实这个段代码，如果细品有另一种意思：         *    因为addUniqueMethods方法在{@link Reflector#getClassMethods(Class)}中的while循环被调用了，一次循环被调用两次，         *    这两次调用：先是子类调用，然后是父类接口调用，         * 所以这里检查是否添加过该方法的另一层含义是：         *    检测是否在子类中已经添加过该方法，如果在子类中添加过，则表示子类覆盖了该方法，无须再向uniqueMethods集合中添加该方法了。         *         */        if (!uniqueMethods.containsKey(signature)) {          //记录该签名和方法的对应关系          uniqueMethods.put(signature, currentMethod);        }      }    }  }</code></pre></li><li><p>然后，按照<code>JavaBean</code>的规范，从<code>Reflector.getClassMethods()</code>返回的Method数组中查找该类中定义的<code>getter</code>方法（具体哪些方法算是<code>getter</code>方法，后面会详细介绍），将其记录到<code>conflictingGetters</code>集合中。<code>conflictingGetters</code>集合（<code>Map&lt;String, List&lt;Method&gt;&gt;</code>类型）的<code>key</code>是属性名称，<code>value</code>是该属性对应的<code>getter</code>方法集合。</p><pre><code class="java">//Reflector.javaArrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));</code></pre><pre><code class="java">//Reflector.java/**   * 添加方法冲突   * @param conflictingMethods   * @param name   * @param method   *   */  private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) {    if (isValidPropertyName(name)) {      /**       * {@link Map#computeIfAbsent(Object, Function)}       * @see red.reksai.reflection.ComputeIfAbsentTest   map jdk1.8新特性       */      List&lt;Method&gt; list = conflictingMethods.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;());      list.add(method);    }  }</code></pre><pre><code class="java">//PropertyNamer.java/**   * 根据Javabean的规范，获取对应的属性名称   * @param name   * @return   */  public static String methodToProperty(String name) {    if (name.startsWith(&quot;is&quot;)) {      name = name.substring(2);    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {      name = name.substring(3);    } else {      throw new ReflectionException(&quot;Error parsing property name &#39;&quot; + name + &quot;&#39;.  Didn&#39;t start with &#39;is&#39;, &#39;get&#39; or &#39;set&#39;.&quot;);    }    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {      name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);    }    return name;  }</code></pre></li><li><p>当子类覆盖了父类的getter方法且返回值发生变化时，在步骤1中就会产生两个签名不用的方法。</p><ul><li>例如：</li></ul><pre><code class="java">import org.apache.ibatis.reflection.Reflector;import java.util.ArrayList;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/26 10:19 */public class ReflectorTest {  public static void main(String[] args) {    Reflector reflector = new Reflector(User.class);    System.out.println(reflector);  }}class  User extends Person{  public User() {  }  public User(String userName, String passWord) {    this.userName = userName;    this.passWord = passWord;  }  private String userName ;  private String passWord ;  public String getUserName() {    return userName;  }  public void setUserName(String userName) {    this.userName = userName;  }  public String getPassWord() {    return passWord;  }  public void setPassWord(String passWord) {    this.passWord = passWord;  }  public boolean isStatus() {    return super.getStatus() ;  }  @Override  public void setStatus(boolean status) {    super.setStatus(status);  }  @Override  public ArrayList&lt;Items&gt; getList() {    return (ArrayList&lt;Items&gt;) super.getList();  }  @Override  public void setList(List&lt;Items&gt; list) {    super.setList(list);  }}class Person {  private List&lt;Items&gt; list;  private boolean status ;  public boolean getStatus() {    return status;  }  public void setStatus(boolean status) {    this.status = status;  }  public List&lt;Items&gt; getList() {    return list;  }  public void setList(List&lt;Items&gt; list) {    this.list = list;  }  public Person() {  }  public Person(List&lt;Items&gt; list) {    this.list = list;  }}class Items{  private String itmeId;  private String itmeName ;}</code></pre><ul><li>在以下位置打断点</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233022-6FOt8I.png" srcset="undefined" alt=""></p><ul><li>观察conflictingGetters集合中的值，如下所示：</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233326-2wTK6y.png" srcset="undefined" alt=""></p><p>其中属性名称为<code>list</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，这就是因为<code>User</code>在覆盖<code>Person</code>中的<code>getList()</code>方法是返回值从<code>List</code>变成了<code>ArrayList</code>，又因为生成方法签名的规则如下所示，所以就造成了有两个不同方法签名的方法被添加到了<code>uniqueMethods</code>集合中，这不是我们想要的结果。</p><pre><code class="java">// Reflector.java/**   * 生成方法签名   * @param method   * @return   */  private String getSignature(Method method) {    StringBuilder sb = new StringBuilder();    Class&lt;?&gt; returnType = method.getReturnType();    if (returnType != null) {      sb.append(returnType.getName()).append(&#39;#&#39;);    }    sb.append(method.getName());    Class&lt;?&gt;[] parameters = method.getParameterTypes();    for (int i = 0; i &lt; parameters.length; i++) {      sb.append(i == 0 ? &#39;:&#39; : &#39;,&#39;).append(parameters[i].getName());    }    return sb.toString();  }</code></pre><p>其中属性为<code>status</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，一个是父类中的<code>boolean getStatus()</code>，另一个是子类中的 <code>boolean isStatus()</code>（涉及到JavaBean规范），说白了此时<code>uniqueMethods</code>集合中也有两个，这也不是我们想要的结果。</p></li><li><p>所以步骤3会调用<code>Reflector.resolveGetterConflicts(conflictingGetters)</code>方法对步骤2中这种覆写的情况进行处理，同时会将处理得到的<code>getter</code>方法记录到<code>getMethods</code>集合中，并将其返回值类型填充到<code>getTypes</code>集合中，<code>Reflector.resolveGetterConflicts()</code>方法的具体实现如下所示：</p></li></ul><pre><code class="Java"> //Reflector.java /**   * 解决get方法的冲突，同时会将处理得到的getter方法记录到getMethods集合中，并将其返回值类型填充到getTypes集合中   * @param conflictingGetters   */  private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) {    //遍历conflictingGetters集合    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) {      //优胜Method对象      Method winner = null;      //方法名称      String propName = entry.getKey();      boolean isAmbiguous = false;      // candidate 候选Method对象      for (Method candidate : entry.getValue()) {        //如果优胜对象为空，这时候将候选对象复制给优胜对象        if (winner == null) {          winner = candidate;          // continue是跳过当次循环中剩下的语句，执行下一次循环          continue;        }        //获取优胜者返回值类型        Class&lt;?&gt; winnerType = winner.getReturnType();        //获取候选者返回值类型        Class&lt;?&gt; candidateType = candidate.getReturnType();        /**         * 如果返回值类型相同，就要判断返回值是不是boolean？为什么要判断是不是boolean呢？         */        if (candidateType.equals(winnerType)) {          //如果返回值不是boolean直接          if (!boolean.class.equals(candidateType)) {            isAmbiguous = true;            //break只能跳出1层循环            break;          } else if (candidate.getName().startsWith(&quot;is&quot;)) {            winner = candidate;          }        }        /**         * @see red.reksai.javabase.IsAssignableFromTest         * 判断返回值类型有三种情况：         *  1. 候选者是优胜者的父类，不做任何操作，最终返回子类就行         *  2. 优胜者是候选者的父类，这时候先要将候选者赋值给优胜者，然后返回         *  3. 返回值相同，二义性，         */        else if (candidateType.isAssignableFrom(winnerType)) {          // OK getter type is descendant        } else if (winnerType.isAssignableFrom(candidateType)) {          winner = candidate;        } else {          isAmbiguous = true;          break;        }      }      //该字段只有一个getter方法，直接添加到getMethods集合并填充getTypes集合      addGetMethod(propName, winner, isAmbiguous);    }  }</code></pre><p>正如上面描述的那样，在<code>Reflector.addGetMethod(propName, winner, isAmbiguous);</code>方法中完成了对<code>getMethods</code>集合和<code>getType</code>集合的填充，具体实现如下所示：</p><pre><code class="java">  private void addGetMethod(String name, Method method, boolean isAmbiguous) {    /**     * 验证：     *    1. 如果有含糊不清的直接报错，     *    2. 如果验证通过，则进行方法的封装     */    MethodInvoker invoker = isAmbiguous        ? new AmbiguousMethodInvoker(method, MessageFormat.format(            &quot;Illegal overloaded getter method with ambiguous type for property &#39;&#39;{0}&#39;&#39; in class &#39;&#39;{1}&#39;&#39;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;,            name, method.getDeclaringClass().getName()))        : new MethodInvoker(method);    getMethods.put(name, invoker);    /**     * 获取返回值的Type ，{@link TypeParameterResolver}     */    Type returnType = TypeParameterResolver.resolveReturnType(method, type);    getTypes.put(name, typeToClass(returnType));  }</code></pre><h2 id="2-2-TypeParameterResolver"><a href="#2-2-TypeParameterResolver" class="headerlink" title="2.2. TypeParameterResolver"></a>2.2. TypeParameterResolver</h2><h2 id="2-3-ObjectFactory"><a href="#2-3-ObjectFactory" class="headerlink" title="2.3. ObjectFactory"></a>2.3. ObjectFactory</h2><h2 id="2-4-Property工具集"><a href="#2-4-Property工具集" class="headerlink" title="2.4. Property工具集"></a>2.4. Property工具集</h2><p>本小节主要介绍反射模块中使用到的三个属性工具类，分别是<code>PropertyTokenizer</code>、<code>PropertyNamer</code>和<code>PropertyCopier</code>。</p><hr><p><strong>此段我暂时也不知道怎么去解释，也许是后续学习能解释这个问题吧。</strong></p><p>在使用<code>Mybatis</code>的过程中，我们会经常碰到一些属性表达式，例如，在查询某用户（<code>User</code>）的订单（<code>Order</code>）的结果集如下表所示：</p><table><thead><tr><th align="center">user_name</th><th align="center">order</th><th align="center">item1</th><th align="center">item2</th><th align="center">. . .</th></tr></thead><tbody><tr><td align="center">Mary</td><td align="center">12460</td><td align="center">IPhone</td><td align="center">Computer</td><td align="center"></td></tr><tr><td align="center">Lisa</td><td align="center">36546</td><td align="center">MX</td><td align="center">Wather</td><td align="center"></td></tr><tr><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td></tr></tbody></table><hr><h3 id="2-4-1-PropertyTokenizer"><a href="#2-4-1-PropertyTokenizer" class="headerlink" title="2.4.1. PropertyTokenizer"></a>2.4.1. PropertyTokenizer</h3><p><code>PropertyTokenizer</code>是一个属性分词器工具，它继承了<code>Iterator</code>接口，它可以迭代处理嵌套的多层表达式。</p><p>由“<code>*</code>”和“<code>[]</code>”组成的表达式是由<code>PropertyTokenizer</code>进行解析的，<code>PropertyTokenizer</code>中各个字段的含义如下所示：</p><pre><code class="java">// fullName = &quot;order[0].items[0].name&quot;  // String[] split = {&quot;order[0]&quot; ,&quot;item[0]&quot; ,&quot;name&quot;}  /**   * 当前表达式的名称:   * e.g. order   *      items   *      name   */  private String name;  /**   * 当前表达式的索引名   * e.g. order[0]   *      items[0]   *      name   */  private final String indexedName;  /**   * 索引下标   * e.g. [0]   *      [0]   *      null   */  private String index;  /**   * 子表达式   * e.g. items[0].name   *      name   *      null   */  private final String children;</code></pre><p>核心方法有三个分别是：</p><ul><li><code>PropertyTokenizer()</code></li></ul><pre><code class="java">/**   * 解析表达式   * @param fullname  要解析的表达式   *                  e.g. order[0].items[0].name   */  public PropertyTokenizer(String fullname) {    //查找&quot;.&quot;的位置    int delim = fullname.indexOf(&#39;.&#39;);    if (delim &gt; -1) {      //初始化name      name = fullname.substring(0, delim);      //初始化children      children = fullname.substring(delim + 1);    } else {      name = fullname;      children = null;    }    //初始化indexName    indexedName = name;    //查找&quot;[&quot;的位置，如果存在，最后要把上面步骤赋值给name中的&quot;[]&quot;去掉    delim = name.indexOf(&#39;[&#39;);    if (delim &gt; -1) {      //初始化index      index = name.substring(delim + 1, name.length() - 1);      //重新赋值给name      name = name.substring(0, delim);    }  }</code></pre><ul><li><code>hasNext()</code></li></ul><pre><code class="java">  /**   * 判断是否还有children   * @return   */  @Override  public boolean hasNext() {    return children != null;  }</code></pre><ul><li><code>next()</code></li></ul><pre><code class="java">  /**   * 继续解析孩子节点   * @return   */  @Override  public PropertyTokenizer next() {    return new PropertyTokenizer(children);  }</code></pre><p>例子：</p><pre><code class="java">import org.apache.ibatis.reflection.property.PropertyTokenizer;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/29 11:12 */public class PropertyTokenizerTest {  public static void main(String[] args) {    String fullName = &quot;orders[0.items[0].name&quot; ;    doTokenizer(fullName);  }  private static void doTokenizer(String name){    PropertyTokenizer propertyTokenizer = new PropertyTokenizer(name);    System.out.println(propertyTokenizer.getIndexedName());    System.out.println(propertyTokenizer.getName());    System.out.println(propertyTokenizer.getIndex());    System.out.println(propertyTokenizer.getChildren());    System.out.println(&quot;.................&quot;);    String children = propertyTokenizer.getChildren();    if (propertyTokenizer.hasNext()){      doTokenizer(children);    }  }}</code></pre><p>运行结果：</p><pre><code>orders[0ordersitems[0].name.................items[0]items0name.................namenamenullnull.................</code></pre><h3 id="2-4-2-PropertyNamer"><a href="#2-4-2-PropertyNamer" class="headerlink" title="2.4.2. PropertyNamer"></a>2.4.2. PropertyNamer</h3><h3 id="2-4-3-PropertyCopier"><a href="#2-4-3-PropertyCopier" class="headerlink" title="2.4.3. PropertyCopier"></a>2.4.3. PropertyCopier</h3><h2 id="2-5-MetaClass"><a href="#2-5-MetaClass" class="headerlink" title="2.5. MetaClass"></a>2.5. MetaClass</h2><h3 id="2-5-1-主要方法详解"><a href="#2-5-1-主要方法详解" class="headerlink" title="2.5.1. 主要方法详解"></a>2.5.1. 主要方法详解</h3><p><code>MetaClass</code>通过<code>Reflector</code>和<code>PropertyTokenizer</code>组合使用，实现了对复杂的属性表达式的解析，并实现了获取指定属性描述信息的功能。<code>MetaClass</code>中各个字段的含义如下：</p><pre><code class="java">  /**   * ReflectorFactory对象，用于缓存Reflector对象   */  private final ReflectorFactory reflectorFactory;  /**   *   在创建MetaClass时会指定一个类，该Reflector对象会用于记录该类相关信息   */  private final Reflector reflector;</code></pre><p><code>MetaClass</code>的构造函数中会为指定的<code>Class</code>创建相应的<code>Reflector</code>对象，并用其初始化<code>MetaClass.reflector</code>字段，具体代码如下所示：</p><pre><code class="java">  /**   * 此构造方法是一个private   * @param type   * @param reflectorFactory     */  private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {    this.reflectorFactory = reflectorFactory;    //创建reflector对象，默认使用的是DefaultReflectorFactory.findForClass()方法    this.reflector = reflectorFactory.findForClass(type);  }  /**   * 使用静态方法创建MetaClass对象   * @param type   * @param reflectorFactory   * @return   */  public static MetaClass forClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {    return new MetaClass(type, reflectorFactory);  }</code></pre><p><code>MetaClass</code>中比较重要的是<code>findProperty()</code>方法，它是通过调用<code>MetaClass.buildProperty()</code>方法实现的：</p><pre><code class="Java">//MetaClass.java    /**   * 只查找&quot;.&quot;导航的属性，并且没有检测下标   * @param name 要查找的属性名称   * @return   */  public String findProperty(String name) {    //委托给buildProperty()方法实现    StringBuilder prop = buildProperty(name, new StringBuilder());    return prop.length() &gt; 0 ? prop.toString() : null;  }</code></pre><pre><code class="java"> private StringBuilder buildProperty(String name, StringBuilder builder) {    //解析表达式    PropertyTokenizer prop = new PropertyTokenizer(name);    //判断是否还有子表达式    if (prop.hasNext()) {      String propertyName = reflector.findPropertyName(prop.getName());      if (propertyName != null) {        builder.append(propertyName);        builder.append(&quot;.&quot;);        //查找属性所对应的MetaClass        MetaClass metaProp = metaClassForProperty(propertyName);        metaProp.buildProperty(prop.getChildren(), builder);      }    } else {      String propertyName = reflector.findPropertyName(name);      if (propertyName != null) {        builder.append(propertyName);      }    }    return builder;  }</code></pre><p>有上述代码可以看出：findPropertory()方法值查找“.”导航的属性，并没有检测下标。</p><p>这里以解析User类中的tele.contry这个属性表达式为例解释上述过程：</p><ol><li><p>首先使用findPropertory(“tele.contry”)；</p></li><li><p>MetaClass.buildPropertry(“tele.country”,stringBuilder)；</p></li><li><p>接着使用PropertryTokenizer解析数据，发现还有子表达式：country，说明此属性表达式所属的类不是当前了，需要查找此属性属于的类；</p></li><li><p>所以要通过MetaClass.metaClassForPropertry(“tele”)，获取到对应的实体类，其中使用到了Reflector.getGetterType()得到了返回值的类型，然后使用MetaClass.forClass()返回返回值对应的元类。</p></li><li><p>递归调用2。</p></li></ol><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129152716-h9Os7u.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153239-L5s0UA.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153351-r3eIeh.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153624-PBw7Sr.png" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153949-KaKXgI.png" srcset="undefined" alt=""></p><h3 id="2-5-2-测试用例"><a href="#2-5-2-测试用例" class="headerlink" title="2.5.2. 测试用例"></a>2.5.2. 测试用例</h3><pre><code class="java">package red.reksai.reflection;import org.apache.ibatis.reflection.DefaultReflectorFactory;import org.apache.ibatis.reflection.MetaClass;import org.junit.jupiter.api.Test;import red.reksai.reflection.entity.User;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/29 10:07 */public class MetaClassTest {  @Test  public  void test() {    MetaClass metaClass = MetaClass.forClass(User.class, new DefaultReflectorFactory());    System.out.println(metaClass.findProperty(&quot;tele.country&quot;));     //tele.country    System.out.println(metaClass.getGetterType(&quot;tele.country&quot;));    // class java.lang.String    System.out.println(metaClass.hasGetter(&quot;tete.country&quot;));    //true    System.out.println(metaClass.getGetterType(&quot;orders[0].items[0]&quot;));    // class red.reksai.reflection.entity.Item  }}</code></pre><h2 id="2-6-ObjectWrapper"><a href="#2-6-ObjectWrapper" class="headerlink" title="2.6. ObjectWrapper"></a>2.6. ObjectWrapper</h2><h2 id="2-7-MetaObject"><a href="#2-7-MetaObject" class="headerlink" title="2.7. MetaObject"></a>2.7. MetaObject</h2>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析器模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​    解析器模块，对应的包是<code>parsing，</code>如下图所示：</p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191126003045-GKXnIt.png" srcset="undefined" style="zoom:50%;" /><p>解析器模块，主要提供了两个功能：</p><ul><li>对XPath进行封装，为Mybatis初始化时解析<code>mybatis-config.xml</code>配置文件以及<code>mapper</code>映射配置文件提供支持。</li><li>为处理动态SQL语句中的占位符提供支持。</li></ul><h1 id="2-XML解析方式"><a href="#2-XML解析方式" class="headerlink" title="2. XML解析方式"></a>2. XML解析方式</h1><p>在mybatis中涉及到多个XML配置文件，因此我们首先要介绍XML解析的相关内容。XML解析的常见的方式有三种：</p><ul><li>DOM（document object model）解析方式</li><li>SAX（simple api for xml）解析方式</li><li>Java6版本开始，JDK致辞的StAX（streaming api for xml）解析方式。</li></ul><p>DOM是基于树形结构的XML解析方式，它将整个XML文档读入内存并构建成一个DOM树,基于这棵树形结构对各个节点（node）进行操作。XML文档中的每一个成分都是一个节点：整个文档是一个文档节点，每个XML标签对应一个元素节点，包含在XML标签中的文本是文本节点，每一个XML属性是一个属性节点，注释属于注释节点。</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>解析后得到的树形结构为：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125100550-l1ZKVS.png" srcset="undefined" alt=""></p><h1 id="3-XPath"><a href="#3-XPath" class="headerlink" title="3. XPath"></a>3. XPath</h1><p>​        mybatis在初始化过程中处理mybatis-config.xml配置文件以及映射文件时，使用的是DOM解析方式，并结合XPath解析xml配置文件，正如前文所述，DOM会对整个XML文档加载到内存中形成树形数据结构，而xpth是一种为查询XML文档而设计的语言，它可以与DOM解析方式配合使用，实现对XML文档的解析。xpath之于XML就好比SQL语言之于数据库。</p><p>​        代码示例：</p><pre><code class="java">import org.apache.ibatis.io.Resources;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.ErrorHandler;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.xpath.*;import java.io.IOException;import java.io.InputStream;/** * XPath解析测试 {@link javax.xml.xpath.XPath} * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 10:11 */public class XPathTest {  public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {    //创建DOM解析器工厂    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();    //开启验证    documentBuilderFactory.setValidating(true);    documentBuilderFactory.setNamespaceAware(false);    documentBuilderFactory.setIgnoringComments(true);    documentBuilderFactory.setIgnoringElementContentWhitespace(false);    documentBuilderFactory.setCoalescing(false);    documentBuilderFactory.setExpandEntityReferences(true);    //得到一个DOM解析器对象    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();    documentBuilder.setErrorHandler(new ErrorHandler() {      @Override      public void warning(SAXParseException exception) throws SAXException {        System.out.println(&quot;warning&quot; + exception.getMessage());      }      @Override      public void error(SAXParseException exception) throws SAXException {        System.out.println(&quot;error&quot; + exception.getMessage());      }      @Override      public void fatalError(SAXParseException exception) throws SAXException {        System.out.println(&quot;fatalError&quot; + exception.getMessage());      }    });    String resource = &quot;resources/xpath-demo.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    //解析xml    Document document = documentBuilder.parse(inputStream);    XPathFactory xPathFactory = XPathFactory.newInstance();    XPath xPath = xPathFactory.newXPath();    XPathExpression xPathExpression = xPath.compile(&quot;/configuration/mappers/mapper&quot;);    NodeList evaluate = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);    for (int i = 0; i &lt; evaluate.getLength() ; i++) {      Node node = evaluate.item(i);      String nodeName = node.getNodeName();      if ((&quot;mapper&quot;).equals(node.getNodeName())){        Node attributeNode = node.getAttributes().getNamedItem(&quot;resource&quot;);        String nodeValue1 = attributeNode.getNodeValue();        System.out.println(nodeName +&quot;......&quot;+nodeValue1);      }    }  }}</code></pre><p>运行结果：</p><pre><code class="java">mapper......org/mybatis/example/BlogMapper.xmlmapper......org/mybatis/example/UserMapper.xml</code></pre><h1 id="4-XPathParser"><a href="#4-XPathParser" class="headerlink" title="4. XPathParser"></a>4. XPathParser</h1><p>Mybatis提供的<code>org.apache.ibatis.parsing.XPathParser</code>类封装了前面涉及到的<code>XPath</code>、<code>Document</code>和<code>EntityResolver</code>，如图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125223756-R177Lc.png" srcset="undefined" alt=""></p><p>XPathParser中各个字段的含义和功能如下所示：</p><pre><code class="java">  /**   * xml document 对象   */  private final Document document;  /**   * 是否开启校验xml   */  private boolean validation;  /**   * 用于加载本地DTD文件   *   * xml实体解析器，默认情况下，对XML校验是，会基于xml文档开始位置定义的DTD文件或者XSD文件，   * 例如：   *    解析mybatis-config.xml配置文件时，会加载http://mybatis.org/dtd/mybatis-3-config.dtd这个DTD文件。   *    但是，如果如果每个应用启动都从网络加载该DTD文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，   *    还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，MyBatis自定义了EntityResolver   *    的实现，达到使用本地DTD文件，从而避免下载网络 DTD 文件的效果。   *   * @see org.apache.ibatis.builder.xml.XMLMapperEntityResolver   */  private EntityResolver entityResolver;  /**   * 变量 Properties对象   */  private Properties variables;  /**   * java XPath对象   *    用于查询xml中的节点和元素   */  private XPath xpath;</code></pre><p>默认情况下，对XML文档进行验证时，会根据XML文档开始位置指定的网址加载对应的<code>DTD</code>文件或者<code>XSD</code>文件。如果是解析<code>mybatis-config.xml</code>配置文件时，默认会加载<code>http://mybatis.org/dtd/mybatis-3-config.dtd</code>这个<code>DTD</code>文件。但是，如果如果每个应用启动都从网络加载该<code>DTD</code>文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，<code>MyBatis</code>自定义了<code>EntityResolver</code>的实现，达到使用本地<code>DTD</code>文件，从而避免下载网络 <code>DTD</code> 文件的效果。<code>XMLMapperEntityResolver</code>是<code>mybatis</code>提供的<code>EntityResolver</code>接口的实现类，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125224446-8JnIIz.png" srcset="undefined" alt=""></p><p><code>EntityResolver</code>接口的核心是<code>resolveEntity()</code>方法，<code>XMLMapperEntityResolver</code>是实现如下所示：</p><pre><code class="java">package org.apache.ibatis.builder.xml;import java.io.IOException;import java.io.InputStream;import java.util.Locale;import org.apache.ibatis.io.Resources;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.SAXException;/** * XML映射器实体解析器 * Offline entity resolver for the MyBatis DTDs. * * @author Clinton Begin * @author Eduardo Macarron */public class XMLMapperEntityResolver implements EntityResolver {  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD的SystemId   */  private static final String IBATIS_CONFIG_SYSTEM = &quot;ibatis-3-config.dtd&quot;;  private static final String IBATIS_MAPPER_SYSTEM = &quot;ibatis-3-mapper.dtd&quot;;  private static final String MYBATIS_CONFIG_SYSTEM = &quot;mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_SYSTEM = &quot;mybatis-3-mapper.dtd&quot;;  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD文件的具体位置   */  private static final String MYBATIS_CONFIG_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;;  /**   * {@link #resolveEntity(String, String)}是{@link EntityResolver} 接口中定义的方法，具体实现如下所示：   *   * Converts a public DTD into a local one.   *   * @param publicId The public id that is what comes after &quot;PUBLIC&quot;   * @param systemId The system id that is what comes after the public id.   * @return The InputSource for the DTD   *   * @throws org.xml.sax.SAXException If anything goes wrong   */  @Override  public InputSource resolveEntity(String publicId, String systemId) throws SAXException {    try {      if (systemId != null) {        String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);        /**         *  查找systemId指定的DTD文档，并调用{@link #getInputSource(String, String, String)}方法读取DTD文档         */        if (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) {          return getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);        } else if (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) {          return getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);        }      }      return null;    } catch (Exception e) {      throw new SAXException(e.toString());    }  }  /**   * 读取DTD文档并形成InputSource对象   * @param path  文件所在路径   * @param publicId    公共标志符   * @param systemId    systemId   * @return InputSource   */  private InputSource getInputSource(String path, String publicId, String systemId) {    InputSource source = null;    if (path != null) {      try {        InputStream in = Resources.getResourceAsStream(path);        source = new InputSource(in);        source.setPublicId(publicId);        source.setSystemId(systemId);      } catch (IOException e) {        // ignore, null is ok      }    }    return source;  }}</code></pre><p>介绍完<code>XMLMapperEntityResolver</code>之后，回到<code>XPathParser</code>的分析。在<code>XPathParser.createDocument()</code>方法中封装了前面介绍的创建<code>Document</code>对象的过程并触发了加载XML文档的过程，具体实现如下：</p><pre><code class="java">/**   * 调用这个方法之前一定要先调用{@link #commonConstructor(boolean, Properties, EntityResolver)}方法完成初始化。   * 将xml解析为Document对象   * @param inputSource   * @return   */  private Document createDocument(InputSource inputSource) {    // important: this must only be called AFTER common constructor    try {      //创建DocumentBuilderFactory对象      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();      //对DocumentBuilderFactory进行一系列的配置      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);      factory.setValidating(validation);      factory.setNamespaceAware(false);      factory.setIgnoringComments(true);      factory.setIgnoringElementContentWhitespace(false);      factory.setCoalescing(false);      factory.setExpandEntityReferences(true);      //创建DocumentBuilder对象并进行配置      DocumentBuilder builder = factory.newDocumentBuilder();      //设置EntityResolver接口对象      builder.setEntityResolver(entityResolver);      builder.setErrorHandler(new ErrorHandler() {        //其中实现的ErrorHandler接口的方法都是空实现        @Override        public void error(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void warning(SAXParseException exception) throws SAXException {          // NOP        }      });      //加载xml文件      return builder.parse(inputSource);    } catch (Exception e) {      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);    }  }/**   * 通用构造：   *    就是通用的赋值操作，主要是的得到一个xpath解析器对document对象进行解析   * @param validation   * @param variables   * @param entityResolver   */  private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) {    this.validation = validation;    this.entityResolver = entityResolver;    this.variables = variables;    XPathFactory factory = XPathFactory.newInstance();    this.xpath = factory.newXPath();  }</code></pre><p><code>XPathParser</code>中提供了一系列的<code>eval*()</code>方法用于解析<code>boolean</code>、<code>short</code>、<code>long</code>、<code>int</code>、<code>String</code>、<code>Node</code>等类型的信息，它通过前面介绍代码中介绍的<code>XPath.evaluate()</code>方法查找指定路径的节点或属性，并进行相应的类型转换。具体的代码比较简单，就不贴出来了，这里需要注意的是<code>XPathParser.evalString()</code><br />方法，其中会调用<code>PropertyParser.parse()</code>方法处理节点中相应的默认值，具体实现如下所示：</p><pre><code class="java"> public String evalString(Object root, String expression) {    String result = (String) evaluate(expression, root, XPathConstants.STRING);    //处理节点中相应的默认值    result = PropertyParser.parse(result, variables);    return result;  }</code></pre><p>在<code>PropertyParser</code>中指定了是否开启默认值的功能以及默认的分隔符，相应字段如下所示：</p><pre><code class="java"> private static final String KEY_PREFIX = &quot;org.apache.ibatis.parsing.PropertyParser.&quot;;  /**   * 在mybatis-config.xml中的&lt;properties&gt;&lt;/properties&gt;节点下配置是否开启默认值功能的对应配置项   * The special property key that indicate whether enable a default value on placeholder.   * &lt;p&gt;   *   The default value is {@code false} (indicate disable a default value on placeholder)   *   If you specify the {@code true}, you can specify key and default value on placeholder (e.g. {@code ${db.username:postgres}}).   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_ENABLE_DEFAULT_VALUE = KEY_PREFIX + &quot;enable-default-value&quot;;  /**   * 配置占位符与默认值之间的默认分隔符的对应配置项   * The special property key that specify a separator for key and default value on placeholder.   * &lt;p&gt;   *   The default separator is {@code &quot;:&quot;}.   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_DEFAULT_VALUE_SEPARATOR = KEY_PREFIX + &quot;default-value-separator&quot;;  /**   * 默认情况下，关闭默认值选项   */  private static final String ENABLE_DEFAULT_VALUE = &quot;false&quot;;  /**   * 默认分隔符是冒号   */  private static final String DEFAULT_VALUE_SEPARATOR = &quot;:&quot;;</code></pre><p><code>PropertyParser.parse()</code>方法中会创建<code>GenericTokenParser解析器，</code>并将默认值的处理委托给<code>GenericTokenParser.parse()</code>方法，实现如下：</p><pre><code class="java">/**   * 当前方法中会创建{@link GenericTokenParser}解析器，并将默认值的处理委托给{@link GenericTokenParser#parse(String)}   * @param string   * @param variables   * @return   */  public static String parse(String string, Properties variables) {    VariableTokenHandler handler = new VariableTokenHandler(variables);    //创建GenericTokenParser对象，并指定其处理的占位符格式为&quot;${}&quot;    GenericTokenParser parser = new GenericTokenParser(&quot;${&quot;, &quot;}&quot;, handler);    return parser.parse(string);  }</code></pre><p><code>GenericTokenParser</code>是一个通用的占位符解析器，其字段的含义如下：</p><pre><code class="java">/**   * 占位符的开始标记   */  private final String openToken;  /**   * 占位符的结束标记   */  private final String closeToken;  /**   * {@link TokenHandler}接口的实现会按照一定的逻辑解析占位符   */  private final TokenHandler handler;</code></pre><p><code>GenericTokenParser.parse()</code>方法的逻辑并不复杂，它会顺序查找<code>openToken</code>和<code>closeToken</code>，解析得到的占位符的字面值，并将其交给<code>TokenHandler</code>处理，然后将解析结果重新拼装成字符串并返回。该方法的实现如下：</p><pre><code class="java">/**   * 此方法的逻辑并不复杂，它会顺序查找{@link #openToken}和{@link #closeToken} ，解析得到占位符的字面值，   * 将将其交给{@link TokenHandler}进行处理，然后将解析结果重新拼装成字符串并返回。   * @param text  拼装之前的字符串   * @return 拼装之后后字符串   */  public String parse(String text) {    //检测text是否为空    if (text == null || text.isEmpty()) {      return &quot;&quot;;    }    // search open token    // 查找开始标记    int start = text.indexOf(openToken);    // 检测start是否为-1    if (start == -1) {      return text;    }    char[] src = text.toCharArray();    int offset = 0;    // builder是用来记录解析后的字符串    final StringBuilder builder = new StringBuilder();    StringBuilder expression = null;    while (start &gt; -1) {      if (start &gt; 0 &amp;&amp; src[start - 1] == &#39;\\&#39;) {        // this open token is escaped. remove the backslash and continue.        // 遇到转移的开始标记，则直接将前面的字符串以及开始标记追加到builder中        builder.append(src, offset, start - offset - 1).append(openToken);        offset = start + openToken.length();      } else {        // found open token. let&#39;s search close token.        // 查找到开始标记，且未转义        if (expression == null) {          expression = new StringBuilder();        } else {          expression.setLength(0);        }        // 将前面的字符串追加到builder中        builder.append(src, offset, start - offset);        offset = start + openToken.length();        // 从offset向后继续查找结束标记        int end = text.indexOf(closeToken, offset);        while (end &gt; -1) {          // 处理转义的结束标记          if (end &gt; offset &amp;&amp; src[end - 1] == &#39;\\&#39;) {            // this close token is escaped. remove the backslash and continue.            expression.append(src, offset, end - offset - 1).append(closeToken);            offset = end + closeToken.length();            end = text.indexOf(closeToken, offset);          } else {            // 将开始标记和结束标记之间的字符串追加到expression中保存            expression.append(src, offset, end - offset);            break;          }        }        //未找到结束标记        if (end == -1) {          // close token was not found.          builder.append(src, start, src.length - start);          offset = src.length;        } else {          //将占位符的字面值交给TokenHandler处理，并将处理结果追加到builder中保存          //最终拼凑出解析后的完整内容          builder.append(handler.handleToken(expression.toString()));          offset = end + closeToken.length();        }      }      //移动start      start = text.indexOf(openToken, offset);    }    if (offset &lt; src.length) {      builder.append(src, offset, src.length - offset);    }    return builder.toString();  }</code></pre><p>占位符有<code>TokenHandler</code>接口的实现进行解析，<code>TokenHandler</code>接口总共有四个实现，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125231024-cKlwtn.png" srcset="undefined" alt=""></p><p>通过对<code>PropertyParser.parse()</code>方法的介绍，我们知道了<code>PropertyParser</code>是使用<code>VariableTokenHandler</code>与<code>GenericTokenParser</code>配合完成占位符解析的，<code>VariableTokenHandler</code>是<code>PropertyReslover</code>中的一个私有静态内部类，其字段的含义如下所示：</p><pre><code class="java"> /**     * &lt;properties&gt;&lt;properties/&gt;节点下定义的键值对，用于替换占位符     */    private final Properties variables;    /**     * 是否支持占位符中使用默认值的功能     */    private final boolean enableDefaultValue;    /**     * 指定占位符和默认值之间的分隔符     */    private final String defaultValueSeparator;</code></pre><p><code>VariableTokenHandler</code>实现了<code>TokenHandler</code>接口中的<code>handlerToken()</code>方法，该实现首先会按照<code>defaultValueSeparator</code>字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值，然后按照切分得到的占位符名称查找对应的值，如果在<code>&lt;properties&gt;</code>节点下未定义相应的键值对，则将切分得到的默认值作为解析结果返回。</p><pre><code class="java">/**     * 实现了{@link TokenHandler}接口中的{@link TokenHandler#handleToken(String)}方法，该实现：     *  1. 首先会按照{@link #defaultValueSeparator}字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值；     *  2. 然后按照切分得到的占位符名称查找对应的值，如果在&lt;properties&gt;&lt;properties/&gt;节点中未定义对应的键值对，     *     则将切分得到的默认值作为解析结果返回。     * @param content     * @return     */    @Override    public String handleToken(String content) {      // 检测variable集合是否为空      if (variables != null) {        String key = content;        //检测是否支持占位符中使用默认值的功能        if (enableDefaultValue) {          // 查找分隔符          final int separatorIndex = content.indexOf(defaultValueSeparator);          String defaultValue = null;          if (separatorIndex &gt;= 0) {            //获取分隔符名称            key = content.substring(0, separatorIndex);            //获取默认值            defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());          }          if (defaultValue != null) {            //在variables集合中查找指定的占位符            return variables.getProperty(key, defaultValue);          }        }        // 不支持默认值的功能，则直接查找variables集合        if (variables.containsKey(key)) {          return variables.getProperty(key);        }      }      //variables集合为空，直接返回      return &quot;${&quot; + content + &quot;}&quot;;    }  }</code></pre><p><code>GenericTokenParser</code>此类不仅用于默认值解析<code>PropertyParser#parse(String, Properties)</code>，还会在动态<code>SQL</code>语句的解析中用到。很明显，<code>GenericTokenParser</code>只是查找到指定的占位符，而具体的解析行为会根据持有的TokenHandler实现的不同而不同，这有点策略模式的意思。<br />回到对<code>XPathParser</code>的分析，<code>XPathParser.evalNode()</code>方法返回值类型是XNode，它对<code>org.w3c.dom.Node</code>对象做了封装和解析，其各个字段的含义如下：</p><pre><code class="java">  /**   * org.w3c.dom.Node对象   */  private final Node node;  /**   * Node节点名称   */  private final String name;  /**   * Node节点内容   */  private final String body;  /**   * 节点属性集合   */  private final Properties attributes;  /**   * mybatis-config.xml配置文件中&lt;properties&gt;&lt;properties/&gt;节点下定义的键值对   */  private final Properties variables;  /**   * XPathParser对象，该Node对象由此XPathParser对象生成   */  private final XPathParser xpathParser;</code></pre><p><code>XNode</code>的构造函数中会调用其<code>parseAttributes()</code>方法和<code>parseBody()</code>方法解析<code>org.w3c.dom.Node</code>对象中的信息，初始化<code>attributes</code>集合和<code>body</code>字段，具体初始化过程如下：</p><pre><code class="java">/**   * 解析Node对象中的Attributes属性集合   * @param n 节点对象   * @return   */  private Properties parseAttributes(Node n) {    Properties attributes = new Properties();    //获取节点的属性结合    NamedNodeMap attributeNodes = n.getAttributes();    if (attributeNodes != null) {      for (int i = 0; i &lt; attributeNodes.getLength(); i++) {        Node attribute = attributeNodes.item(i);        //使用PropertyParser处理每一个属性中的占位符        String value = PropertyParser.parse(attribute.getNodeValue(), variables);        attributes.put(attribute.getNodeName(), value);      }    }    return attributes;  }/**   * 解析Node对象中的信息body字段   * @param node   * @return   */  private String parseBody(Node node) {    String data = getBodyData(node);    //当前节点不是文本节点    if (data == null) {       //处理子节点      NodeList children = node.getChildNodes();      for (int i = 0; i &lt; children.getLength(); i++) {        Node child = children.item(i);        data = getBodyData(child);        if (data != null) {          break;        }      }    }    return data;  }  private String getBodyData(Node child) {    //只处理文本内容    if (child.getNodeType() == Node.CDATA_SECTION_NODE        || child.getNodeType() == Node.TEXT_NODE) {      String data = ((CharacterData) child).getData();      //使用PropertyParser处理文本节点中的占位符      data = PropertyParser.parse(data, variables);      return data;    }    return null;  }</code></pre><p>XPathParser测试用例</p><pre><code class="java">import org.apache.ibatis.builder.xml.XMLMapperEntityResolver;import org.apache.ibatis.io.Resources;import org.apache.ibatis.parsing.XNode;import org.apache.ibatis.parsing.XPathParser;import java.io.IOException;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 16:11 */public class XPathParserTest {  public static void main(String[] args) throws IOException {    String resource = &quot;resources/xpath-demo.xml&quot;;    XPathParser xPathParser = new XPathParser(Resources.getResourceAsReader(resource),true,null,new XMLMapperEntityResolver());    XNode xNode = xPathParser.evalNode(&quot;/configuration&quot;);    List&lt;XNode&gt; children = xNode.getChildren();    for (int i = 0; i &lt; children.size(); i++) {      System.out.println(children.get(i).getName());    }  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2保存密码登录</title>
    <link href="undefinedMac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html"/>
    <url>Mac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html</url>
    
    <content type="html"><![CDATA[<h1 id="iterm2保存密码登录"><a href="#iterm2保存密码登录" class="headerlink" title="iterm2保存密码登录"></a>iterm2保存密码登录</h1><h2 id="1-编写item2login-sh脚本文件"><a href="#1-编写item2login-sh脚本文件" class="headerlink" title="1. 编写item2login.sh脚本文件"></a>1. 编写<code>item2login.sh</code>脚本文件</h2><pre><code class="shell">#!/usr/bin/expect  set timeout 30  spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]  expect {         &quot;(yes/no)?&quot;         {send &quot;yes\n&quot;;exp_continue}         &quot;password:&quot;         {send &quot;[lindex $argv 3]\n&quot;}  }  interact </code></pre><ul><li><p>lindex $argv 0 : port</p></li><li><p>lindex $argv 1：username</p></li><li><p>lindex $argv 2：IP</p></li><li><p>lindex $argv 3：password</p></li></ul><h2 id="2-修改item2login-sh权限"><a href="#2-修改item2login-sh权限" class="headerlink" title="2. 修改item2login.sh权限"></a>2. 修改<code>item2login.sh</code>权限</h2><p>将<code>item2login.sh</code>移动到<code>/usr/local/bin</code>目录下，然后使用<code>chmod 777 item2login.sh</code>修改脚本权限；</p><h2 id="3-在iterm2中添加信息"><a href="#3-在iterm2中添加信息" class="headerlink" title="3. 在iterm2中添加信息"></a>3. 在iterm2中添加信息</h2><p>打开iterm2的<code>Profiles</code>–&gt;<code>Open Profiles...</code>–&gt;<code>Edit Profiles...</code>–&gt;<code>+</code></p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204208-mTkAoN.png" srcset="undefined" alt=""></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>然后就可以选取要登录的服务器了，效果如下所示（因为是测试服务所以没有连接）：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204211-HHVeUW.png" srcset="undefined" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Mac技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>