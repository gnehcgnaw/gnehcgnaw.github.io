<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git_clone提速</title>
    <link href="undefined%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/git_clone%E6%8F%90%E9%80%9F.html"/>
    <url>%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/git_clone%E6%8F%90%E9%80%9F.html</url>
    
    <content type="html"><![CDATA[<h1 id="git-clone提速"><a href="#git-clone提速" class="headerlink" title="git_clone提速"></a>git_clone提速</h1><blockquote><p>此文转载自：<code>https://blog.csdn.net/havedoor/article/details/83350768</code></p></blockquote><h1 id="1-host重定向"><a href="#1-host重定向" class="headerlink" title="1. host重定向"></a>1. host重定向</h1><p>通过<code>http://tool.chinaz.com/dns</code>寻找<code>github.com</code>最高效地址，就是<code>TTL</code>最短的<code>IP</code>地址。</p><ul><li><p>寻找<code>github.com</code>的<code>TTL</code>最短的<code>IP</code>地址</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208231138-GtLhky.png!github_blog" srcset="undefined" alt=""></p></li><li><p>寻找<code>github.global.ssl.fastly.net</code>的<code>TTL</code>最短的<code>IP</code>地址</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208231154-MEUQ5i.png!github_blog" srcset="undefined" alt=""></p></li><li><p>配置<code>hosts</code></p><pre><code>vim /etc/hosts</code></pre><pre><code>13.229.188.59 github.com31.13.83.8    github.global.ssl.fastly.net</code></pre></li></ul><h1 id="2-通过码云中转"><a href="#2-通过码云中转" class="headerlink" title="2. 通过码云中转"></a>2. 通过码云中转</h1><p>在码云上新建一个项目，然后选“导入已有项目”，把<code>github</code>上要<code>clone</code>的工程放进去，一般需要十几分钟完成创建。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208232051-XxMkD2.png!github_blog" srcset="undefined" alt=""></p><h1 id="3-通过代理方式"><a href="#3-通过代理方式" class="headerlink" title="3. 通过代理方式"></a>3. 通过代理方式</h1><p>这种方式需要有<code>VPN</code>代理，本人使用的是<code>Lantern</code>收费版的，感觉甚是不错。</p><ul><li><p>查看自己<code>VPN</code>的<code>proxy</code>端口</p><ul><li>点击Lantern的显示蓝灯，如下所示：</li></ul><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208232954-Ss3M1X.png!github_blog" srcset="undefined" style="zoom:67%;" /><ul><li>弹出浏览器页面，在地址栏可以看到代理端口，如下所示：</li></ul><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208233330-ooV2X5.png!github_blog" srcset="undefined" style="zoom:67%;" /></li><li><p>设置代理（只针对<code>github</code>）</p></li></ul><pre><code>git config --global http.http://github.com.proxy 127.0.0.1:51181git config --global https.https://github.com.proxy 127.0.0.1:51181</code></pre><ul><li>删除代理</li></ul><pre><code>git config --global --unset http.http://github.com.proxygit config --global --unset https.https://github.com.proxy</code></pre><ul><li>查看<code>Git</code>全局配置</li></ul><pre><code>git config --global --list</code></pre><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208234211-1ErGIK.png!github_blog" srcset="undefined" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口层</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E6%8E%A5%E5%8F%A3%E5%B1%82.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E6%8E%A5%E5%8F%A3%E5%B1%82.html</url>
    
    <content type="html"><![CDATA[<h1 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ResultSetHandler</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/ResultSetHandler.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/ResultSetHandler.html</url>
    
    <content type="html"><![CDATA[<h1 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StatementHandler</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/StatementHandler.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/StatementHandler.html</url>
    
    <content type="html"><![CDATA[<h1 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h1><p>StatementHandler接口是Mybatis的核心接口之一，它完成了Mybatis中最核心的一部分工作，也是后面介绍的Executor接口实现的基础。</p><p>StatementHandler接口中的功能很多，例如创建Statement对象，为SQL语句绑定实参，执行select、update、insert、delete等多种类型的SQL语句，批量执行SQL语句，将结果集映射成结果对象。</p><p>StatementHandler接口的定义如下：</p><pre><code class="java">/** * StatementHandler接口中的功能很多，例如创建Statement对象，为SQL语句绑定实参， * 执行select、update、insert、delete等多种类型的SQL语句，批量执行SQL语句，将结果集映射成结果对象。 * 语句处理器 * @author Clinton Begin */public interface StatementHandler {  /**   * 从连接中获取一个Statement   */  Statement prepare(Connection connection, Integer transactionTimeout)      throws SQLException;  /**   * 绑定statement执行时所需的参数   * @param statement   * @throws SQLException   */  void parameterize(Statement statement)      throws SQLException;  /**   * 批量执行SQL语句   * @param statement   * @throws SQLException   */  void batch(Statement statement)      throws SQLException;  /**   * 执行update、insert、delete语句   * @param statement   * @return   * @throws SQLException   */  int update(Statement statement)      throws SQLException;  /**   * 执行select语句   * @param statement   * @param resultHandler   * @param &lt;E&gt;   * @return   * @throws SQLException   */  &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler)      throws SQLException;  /**   * 查询游标   * @param statement   * @param &lt;E&gt;   * @return   * @throws SQLException   */  &lt;E&gt; Cursor&lt;E&gt; queryCursor(Statement statement)      throws SQLException;  /**   * 获取绑定的SQL   * @return   */  BoundSql getBoundSql();  /**   * 获取ParameterHandler   * @return   */  ParameterHandler getParameterHandler();}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SqlNode&amp;SqlSource</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/SqlNode&amp;SqlSource.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/SqlNode&amp;SqlSource.html</url>
    
    <content type="html"><![CDATA[<h1 id="SqlNode-amp-SqlSource"><a href="#SqlNode-amp-SqlSource" class="headerlink" title="SqlNode&amp;SqlSource"></a>SqlNode&amp;SqlSource</h1><p>根据Mybatis初始化过程可知，映射配置文件中定义的SQL节点会被解析成MapperStatement对象，其中的SQL语句会被解析成SqlSource对象，SQL语句中定义的动态SQL节点、文本节点等，则有SqlNode接口的相应实现表示。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis初始化(二)——4.构建语句</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E6%9E%84%E5%BB%BA%E8%AF%AD%E5%8F%A5.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E6%9E%84%E5%BB%BA%E8%AF%AD%E5%8F%A5.html</url>
    
    <content type="html"><![CDATA[<h1 id="构建语句"><a href="#构建语句" class="headerlink" title="构建语句"></a>构建语句</h1><p>在进行解析Mapper映射配置文件的时候，还有一类比较重要的节点需要解析，也就是本节将要介绍的<code>SQL</code>节点。这些<code>SQL</code>节点主要用于定义<code>SQL</code>语句，它们不在有<code>XMLMapperBuilder</code>进行解析，而是有<code>XMLStatementBuilder</code>负责进行解析。</p><h1 id="1-XMLStatementBuilder"><a href="#1-XMLStatementBuilder" class="headerlink" title="1.  XMLStatementBuilder"></a>1.  XMLStatementBuilder</h1><p>下面开始分析其解析<code>SQL</code>相关节点的过程，<code>XMLStatementBuilder.parseStatementNode()</code>方法是解析<code>SQL</code>节点的入口函数，其具体实现如下所示，我将会按照图中标记的步骤分析：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-11-4smjMO.png!github_blog" srcset="undefined" alt=""></p><hr><p><strong>步骤1：</strong>首先判断<code>Configuration.databaseId</code>和<code>select</code>、<code>update</code>、<code>insert</code>、<code>delete</code>标签中配置的<code>databaseId</code>是否一致，如果一致就进行下面的步骤，如果不一致就直接跳出，说白了就是：<code>Mapper</code>映射配置文件都会被加载，但是<code>Mapper</code>映射配置文件的节点有可能不会被解析，这些节点是<code>select</code>、<code>update</code>、<code>insert</code>、<code>delete</code>还有上节说的<code>sql</code>，涉及到的代码如下所示：</p><pre><code class="java">    String id = context.getStringAttribute(&quot;id&quot;);    String databaseId = context.getStringAttribute(&quot;databaseId&quot;);    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {      return;    }</code></pre><hr><p><strong>步骤二、步骤三：</strong>获取节点名称，然后跟枚举类<code>SqlCommand</code>中的属性进行比较，返回指定枚举值的对象，<code>SqlCommand</code>代码如下所示：</p><pre><code class="java">/** * SQL命令的类型 * @author Clinton Begin */public enum SqlCommandType {  UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH}</code></pre><p>步骤二涉及到的代码如下所示：</p><pre><code class="java"> //获取当前节点的名字：例如：select、update、insert、delete、flush    String nodeName = context.getNode().getNodeName();    //拿nodeName和SqlCommendType中的枚举类型比较，然后符合的值    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</code></pre><hr><p><strong>步骤四：</strong>解析节点中的<code>flushCache</code>、<code>useCache</code>、<code>resultOrdered</code>属性，涉及到的代码如下所示：</p><pre><code class="java">    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;    boolean flushCache = context.getBooleanAttribute(&quot;flushCache&quot;, !isSelect);    boolean useCache = context.getBooleanAttribute(&quot;useCache&quot;, isSelect);    boolean resultOrdered = context.getBooleanAttribute(&quot;resultOrdered&quot;, false);</code></pre><p>这段代码看着稀松平常，但是我看到了代码艺术。</p><p><strong>步骤五：</strong>在解析语句之前，先创建<code>XMLIncludeTransformer</code>对象，利用<code>XMLIncluderTransformer.appleIncludes()</code>去解析<code>&lt;include&gt;</code>节点。</p><pre><code class="java">// Include Fragments before parsing    //创建一个XMLIncludeTransformer对象    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);    //处理include标签：找到对应的&lt;sql&gt;标签，将&lt;sql&gt;标签中的占位符替换成&lt;include&gt;节点下&lt;property&gt;的name对应的属性值，然后用sql片段的语句替换include标签    includeParser.applyIncludes(context.getNode());</code></pre><h2 id="1-1-解析-lt-include-gt-节点"><a href="#1-1-解析-lt-include-gt-节点" class="headerlink" title="1.1. 解析&lt;include&gt;节点"></a>1.1. 解析<code>&lt;include&gt;</code>节点</h2><p>在解析<code>SQL</code>节点之前，首先通过<code>XMLIncloudeTransformer</code>解析<code>SQL</code>语句中的<code>&lt;include&gt;</code>节点，该解析过程在<code>XMLIncludeTransformer.applyIncluders()</code>方法实现的：</p><pre><code class="java">public void applyIncludes(Node source) {    Properties variablesContext = new Properties();    //获取mybatis-config.xml中，&lt;properties&gt;节点中定义的变量集合    Properties configurationVariables = configuration.getVariables();    /*     *  下面的一行代码其实就是说，如果configurationVariables不为null，那么就把值赋给variablesContext。     *  if(configurationVariables!=null){     *      variablesContext.putAll(configurationVariables)     *  }     */    Optional.ofNullable(configurationVariables).ifPresent(variablesContext::putAll);    //处理&lt;include&gt;节点    applyIncludes(source, variablesContext, false);  }</code></pre><p>下面是处理<code>&lt;include&gt;</code>节点的<code>applyIncludes()</code>方法重载：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-12-OobCWc.png!github_blog" srcset="undefined" alt=""></p><p>通过示例去解读代码，具体示例如下所示：</p><pre><code class="xml">  &lt;select id=&quot;selectBlogList&quot; resultType=&quot;map&quot;&gt;    select *    &lt;include refid=&quot;fromSqlElement&quot;&gt;      &lt;property name=&quot;tablename&quot; value=&quot;tb_blog&quot;/&gt;    &lt;/include&gt;  &lt;/select&gt;  &lt;sql id=&quot;fromSqlElement&quot;&gt;    from ${tablename}    &lt;include refid=&quot;whereSqlElement&quot;&gt;      &lt;property name=&quot;idValue&quot; value=&quot;1&quot;/&gt;    &lt;/include&gt;  &lt;/sql&gt;  &lt;sql id=&quot;whereSqlElement&quot;&gt;    where blog_id = ${idValue}  &lt;/sql&gt;</code></pre><p>从<strong>步骤一</strong>开始，因为当前解析的是<select>节点，并且<select>节点是一个Node.ElEMENT_NODE，所以会进入到<strong>步骤二</strong>；</p><p>然后进行<strong>步骤四</strong>，判断include=true&amp;&amp;variableContext!=null是否成立，因为此时的include是false，所以不成立，这时候程序直接进入<strong>步骤五</strong>；</p><p><strong>步骤五</strong>是获取所有的子节点，然后遍历，一个个从<strong>步骤一</strong>执行；</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-12-fsJ0OC.png!github_blog" srcset="undefined" alt=""></p><p>当前<select id="selectBlogList" resultType="map">下是有三个节点的，分别是：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-12-ExtY7N.png!github_blog" srcset="undefined" alt=""></p><p><strong>故：</strong></p><hr><p>第一次循环去执行<strong>步骤一</strong>的是：节点值为<code>\n select \n</code>的节点；</p><ul><li>此时程序会进入步骤三，因为included=false，所以直接跳出；</li></ul><hr><p>第二次循环去执行步骤一的是：节点<include>，<strong>因为节点的名称等于include，所以会进入步骤一中的代码</strong>；</p><p><strong>步骤六：</strong>获取<include>上的refid属性的值，然后把这个值作为参数调用findSqlFragment()方法，获取refid值相应的<sql>节点对象，此时获取的节点对象如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-12-NZdXAk.png!github_blog" srcset="undefined" alt=""></p><p>其实就是XML中的以下代码段：</p><pre><code>&lt;sql id=&quot;fromSqlElement&quot;&gt;    from ${tablename}    &lt;include refid=&quot;whereSqlElement&quot;&gt;      &lt;property name=&quot;idValue&quot; value=&quot;1&quot;/&gt;    &lt;/include&gt;  &lt;/sql&gt;</code></pre><p>接着，执行步骤七，通过调用getVariablesContext()方法获取<include>标签下的<property>的name和value，并将其添加到variableContext；</p><p>步骤八：将included设置为ture，表示<select>下<include>下<property>的属性值已经解析，接着会调到步骤四，执行步骤4中的代码，然后使用property中的属性值替换，如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-12-7Q5PiI.png!github_blog" srcset="undefined" alt=""></p><p>最后最后一个值也被解析出来：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-12-gG5r7C.png!github_blog" srcset="undefined" alt=""></p><p>说白了<include>和<sql>节点可以配合使用，多层嵌套，实现更加复杂的SQL片段的重用，这样的话，解析过程就会递归更多层，流程也会变得更加复杂， 但是本质和上述分析是一样的，我总结出来流程如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-12-pmP2cc.jpg!github_blog" srcset="undefined" alt=""></p><p>最后处理完的select节点中的语句的样子，如下所示：</p><pre><code class="sql">      select *    from tb_blog    where blog_id = #{id}</code></pre><h2 id="1-2-解析-lt-selectKey-gt-节点"><a href="#1-2-解析-lt-selectKey-gt-节点" class="headerlink" title="1.2. 解析&lt;selectKey&gt;节点"></a>1.2. 解析<code>&lt;selectKey&gt;</code>节点</h2><p><selectKey>节点可以定义的属性和子节点，如下所示：</p><pre><code class="dtd">&lt;!ELEMENT selectKey (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST selectKeyresultType CDATA #IMPLIEDstatementType (STATEMENT|PREPARED|CALLABLE) #IMPLIEDkeyProperty CDATA #IMPLIEDkeyColumn CDATA #IMPLIEDorder (BEFORE|AFTER) #IMPLIEDdatabaseId CDATA #IMPLIED&gt;</code></pre><p>在<insert>、<update>节点中可以定义<selectKey>节点来解决主键自增问题，<selectKey>节点对应的KeyGenerator接口会在后面详细介绍，这里关注<selectKey>节点的解析。</p><p>XMLStatementBuilder.processSelectKeyNodes()方法负责解析SQL节点中的<selectKey>子节点，具体代码如下所示：</p><pre><code class="java">  private void processSelectKeyNodes(String id, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver) {    //获取所有的selectKey节点    List&lt;XNode&gt; selectKeyNodes = context.evalNodes(&quot;selectKey&quot;);    //解析&lt;selectKey&gt;节点    if (configuration.getDatabaseId() != null) {      parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, configuration.getDatabaseId());    }    parseSelectKeyNodes(id, selectKeyNodes, parameterTypeClass, langDriver, null);    //移除&lt;selectKey&gt;节点    removeSelectKeyNodes(selectKeyNodes);  }</code></pre><p>在parseSelectKeyNode()方法中，首先读取<selectKey>节点的一系列属性，然后调用LanguageDriver.createSqlSource()方法创建对应的SqlSource对象，最后创建MapperStatement对象，并添加到Configuraiton.mappedStatements集合中保存。parseSelectKeyNode()方法的具体实现如下：</p><pre><code class="java"> private void parseSelectKeyNode(String id, XNode nodeToHandle, Class&lt;?&gt; parameterTypeClass, LanguageDriver langDriver, String databaseId) {    //获取&lt;selectKey&gt;节点下的resultType、statementType、keyProperty、keyColumn、order属性的值    String resultType = nodeToHandle.getStringAttribute(&quot;resultType&quot;);    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);    StatementType statementType = StatementType.valueOf(nodeToHandle.getStringAttribute(&quot;statementType&quot;, StatementType.PREPARED.toString()));    String keyProperty = nodeToHandle.getStringAttribute(&quot;keyProperty&quot;);    String keyColumn = nodeToHandle.getStringAttribute(&quot;keyColumn&quot;);    boolean executeBefore = &quot;BEFORE&quot;.equals(nodeToHandle.getStringAttribute(&quot;order&quot;, &quot;AFTER&quot;));    //defaults    //设置一些MappedStatement对象需要的默认配置，    boolean useCache = false;    boolean resultOrdered = false;    KeyGenerator keyGenerator = NoKeyGenerator.INSTANCE;    Integer fetchSize = null;    Integer timeout = null;    boolean flushCache = false;    String parameterMap = null;    String resultMap = null;    ResultSetType resultSetTypeEnum = null;    //通过LanguageDriver.createSqlSource()方法生成SqlSource    SqlSource sqlSource = langDriver.createSqlSource(configuration, nodeToHandle, parameterTypeClass);    SqlCommandType sqlCommandType = SqlCommandType.SELECT;    //然后把解析出来的&lt;selectKey&gt;下面的语句构建成MappedStatement对象    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,        resultSetTypeEnum, flushCache, useCache, resultOrdered,        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, null);    id = builderAssistant.applyCurrentNamespace(id, false);    MappedStatement keyStatement = configuration.getMappedStatement(id, false);    //创建&lt;selectKey&gt;节点对应的KeyGenerator，添加到Configuration.keyGenerators集合中    configuration.addKeyGenerator(id, new SelectKeyGenerator(keyStatement, executeBefore));  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h1><p><code>Mybatis</code>作为一个强大的持久层框架，缓存是其必不可少的功能之一。<code>Mybatis</code>中的缓存是两层结构的，分为一级缓存、二级缓存，但在本质上是相同的，它们使用的都是<code>Cache</code>接口的实现。</p><h1 id="1-装饰者模式"><a href="#1-装饰者模式" class="headerlink" title="1. 装饰者模式"></a>1. 装饰者模式</h1><h1 id="2-Cache接口及其实现"><a href="#2-Cache接口及其实现" class="headerlink" title="2. Cache接口及其实现"></a>2. Cache接口及其实现</h1><p><code>Mybatis</code>中缓存模块相应的代码位于<code>cache</code>包下，其中<code>Cache</code>接口是缓存模块中最核心的接口，它定义了所以缓存的基本行为，<code>Cache</code>接口的定义如下：</p><pre><code class="java">public interface Cache {  /**   * 该缓存对象的ID   * @return The identifier of this cache   */  String getId();  /**   * 向缓存中添加数据，一般情况下key是{@link CacheKey} ，value是查询结果   * @param key Can be any object but usually it is a {@link CacheKey}   * @param value The result of a select.   */  void putObject(Object key, Object value);  /**   * 根据指定的key，在缓存中查找对应的结果对象   * @param key The key   * @return The object stored in the cache.   */  Object getObject(Object key);  /**   * 删除key对应的缓存项   * As of 3.3.0 this method is only called during a rollback   * for any previous value that was missing in the cache.   * This lets any blocking cache to release the lock that   * may have previously put on the key.   * A blocking cache puts a lock when a value is null   * and releases it when the value is back again.   * This way other threads will wait for the value to be   * available instead of hitting the database.   *   *   * @param key The key   * @return Not used   */  Object removeObject(Object key);  /**   * 清空缓存   * Clears this cache instance.   */  void clear();  /**   * 缓存项的个数，该方法不会被Mybatis核心代码使用，所以可提供空实现   * Optional. This method is not called by the core.   *   * @return The number of elements stored in the cache (not its capacity).   */  int getSize();  /**   * 获取读写锁，该方法不会被Mybatis核心代码使用，所以可提供空实现   * Optional. As of 3.2.6 this method is no longer called by the core.   * &lt;p&gt;   * Any locking needed by the cache must be provided internally by the cache provider.   *   * @return A ReadWriteLock   */  default ReadWriteLock getReadWriteLock() {    return null;  }}</code></pre><p><code>Cache</code>接口的实现类有镀铬，但大部分都是装饰器，只有<code>PrepetualCache</code>提供了<code>Cache</code>接口的基本实现。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191202002543-dIi03B.png!github_blog" srcset="undefined" style="zoom:67%;" /><h2 id="2-1-PrepetualCache"><a href="#2-1-PrepetualCache" class="headerlink" title="2.1. PrepetualCache"></a>2.1. PrepetualCache</h2><p><code>PrepetualCache</code>在缓存模块中扮演着<code>ConcreteComponent</code>的角色，其实现比较简单，底层使用<code>HashMap</code>记录缓存项，也是通过该<code>HashMap</code>对象的方法实现的<code>Cache</code>接口中定义的相关方法。<code>PrepetualCache</code>的具体实现如下所示：</p><pre><code class="java">/** * PrepetualCache在缓存模块中扮演着ConcreteComponent的角色， * 其实比较简单，底层使用HashMap记录缓存项，也是通过该HashMap对象的方法实现的Cache接口中定义的相关方法。 * @author Clinton Begin */public class PerpetualCache implements Cache {  private final String id;  /**   * 用于记录缓存项的map对象   */  private final Map&lt;Object, Object&gt; cache = new HashMap&lt;&gt;();  public PerpetualCache(String id) {    this.id = id;  }  @Override  public String getId() {    return id;  }  @Override  public int getSize() {    return cache.size();  }  //下面所有的方法都是通过cache字段记录这个HashMap对象的响应方法实现的  @Override  public void putObject(Object key, Object value) {    cache.put(key, value);  }  @Override  public Object getObject(Object key) {    return cache.get(key);  }  @Override  public Object removeObject(Object key) {    return cache.remove(key);  }  @Override  public void clear() {    cache.clear();  }  //重写了equals()方法和hashCode()方法，两者都只关心id字段，并不关系cache字段  @Override  public boolean equals(Object o) {    if (getId() == null) {      throw new CacheException(&quot;Cache instances require an ID.&quot;);    }    if (this == o) {      return true;    }    if (!(o instanceof Cache)) {      return false;    }    Cache otherCache = (Cache) o;    return getId().equals(otherCache.getId());  }  @Override  public int hashCode() {    if (getId() == null) {      throw new CacheException(&quot;Cache instances require an ID.&quot;);    }    return getId().hashCode();  }}</code></pre><hr><p>下面来介绍<code>cache.decorators</code>包下提供的装饰器，它们都直接实现了<code>Cache</code>接口，扮演着<code>ConcreteDecorator</code>的角色。这些装饰器会在<code>PerpetualCache</code>的基础上提供一些额外的功能，通过多个组合后满足一个特定的需求（比如：二级缓存是，会见到这些装饰器是如何完成动态组合的）。</p><hr><h2 id="2-2-BlockingCache"><a href="#2-2-BlockingCache" class="headerlink" title="2.2. BlockingCache"></a>2.2. BlockingCache</h2><p><code>BlockingCache</code>是阻塞版本的缓存装饰器，它会保证只有一个线程到缓存中查找指定<code>key</code>对应的数据。</p><p><code>BlockingCache</code>中各个字段的含义如下所示：</p><pre><code class="java">  /**   * 阻塞超时时间   */  private long timeout;  /**   * 被装饰的底层Cache对象   */  private final Cache delegate;  /**   * 每个key都有对应的ReentrantLock(重入锁)   */  private final ConcurrentHashMap&lt;Object, ReentrantLock&gt; locks;</code></pre><p><code>BlockingCache</code>是如何保证只有一个线程到缓存中查找指定<code>key</code>的，假设线程A在BlockingCache中未查找到keyA对应的缓存项时，线程A会获取keyA对应的锁，这样后续线程在查找keyA时会发生阻塞，如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191202110151-XxlF5V.png!github_blog" srcset="undefined" alt=""></p><p>有下面是一个上述情况的例子：</p><pre><code class="java">package red.reksai.cache;import org.apache.ibatis.cache.decorators.BlockingCache;import org.apache.ibatis.cache.impl.PerpetualCache;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/12/2 00:44 */public class BlockingCacheTest {  public static void main(String[] args) {    MyThread myThread = new MyThread();    Thread thread1 = new Thread(myThread);    Thread thread2 = new Thread(myThread);    thread1.start();    thread2.start();  }}class MyThread extends  Thread {  public static BlockingCache blockingCache ;  static {    PerpetualCache perpetualCache = new PerpetualCache(&quot;namespace1&quot;);    perpetualCache.putObject(&quot;key&quot;,&quot;aaa&quot;);    blockingCache = new BlockingCache(perpetualCache);  }  @Override  public void run() {    System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+blockingCache.getObject(&quot;key1&quot;));  }}</code></pre><p>放入的是<code>key=&quot;key&quot;</code>，查询的是<code>key=&quot;key1&quot;</code>的值，运行结果如下所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191202103822-ndTZZ7.png!github_blog" srcset="undefined" style="zoom:50%;" /><p>有上图可以发现，只有一个线程执行了，返回的是<code>null</code>，而第二个线程被阻塞了，这是为什么呢？要想解释这个问题只能看<code>BlocklingCache</code>源码了。</p><h3 id="2-2-1-getObject"><a href="#2-2-1-getObject" class="headerlink" title="2.2.1. getObject()"></a>2.2.1. getObject()</h3><p><code>BlockingCache.getObject()</code>方法的代码如下所示，可以看到在获取指定<code>key</code>对应的对象之前，首先要获取锁，如果查询的结果是不是<code>null</code>，即表明查到了结果，那么释放锁，如果没有查询到结果，后续线程查询就会拿不到锁，因为第一次查询没有查询到结果的情况下并没有去释放锁。</p><pre><code class="java">  /**   * 获取指定key对应的对象   * @param key The key 要查询的key   * @return    key所对应的对象   */  @Override  public Object getObject(Object key) {    //获取该key对应的锁    acquireLock(key);    Object value = delegate.getObject(key);    if (value != null) {      //释放锁      releaseLock(key);    }    return value;  }</code></pre><h3 id="2-2-2-acquireLock"><a href="#2-2-2-acquireLock" class="headerlink" title="2.2.2. acquireLock()"></a>2.2.2. acquireLock()</h3><p><code>BlockingCache.acquireLock()</code>方法的代码如下所示：</p><pre><code class="java">/**   * 尝试获取指定key对应的锁：   *    如果该key没有对应的锁对象则为其创建一个ReetrantLock对象，再加锁；   *    如果获取锁失败，则阻塞一段时间。   * @param key   */  private void acquireLock(Object key) {    //获取ReentrantLock    Lock lock = getLockForKey(key);    if (timeout &gt; 0) {      try {        //获取锁带超时时长        boolean acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);        //超时则抛出异常        if (!acquired) {          throw new CacheException(&quot;Couldn&#39;t get a lock in &quot; + timeout + &quot; for the key &quot; +  key + &quot; at the cache &quot; + delegate.getId());        }      } catch (InterruptedException e) {        throw new CacheException(&quot;Got interrupted while trying to acquire lock for key &quot; + key, e);      }    } else {      //获取锁，不带超时时长      lock.lock();    }  }</code></pre><h3 id="2-2-3-getLockForKey"><a href="#2-2-3-getLockForKey" class="headerlink" title="2.2.3. getLockForKey()"></a>2.2.3. getLockForKey()</h3><p><code>BlockingCache.getLockForKey()</code>方法的代码如下所示：</p><pre><code class="java">  /**   * 获取锁，如果该key没有对应的锁对象则为其创建一个ReentrantLock对象   * @param key   * @return   */  private ReentrantLock getLockForKey(Object key) {    return locks.computeIfAbsent(key, k -&gt; new ReentrantLock());  }</code></pre><p>看完以上源码，分析：假设线程A从数据库中查找到keyA对应的结果对象后，将结果对象放入到BlockingCache中，此时线程A会释放keyA的对应的锁，唤醒阻塞在该锁上的线程。其他线程即可以从BlockingCache总获取keyA对应的数据，而不是再次访问数据库，具体如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191202112504-D0BCXB.png!github_blog" srcset="undefined" alt=""></p><h3 id="2-3-4-putObject"><a href="#2-3-4-putObject" class="headerlink" title="2.3.4. putObject()"></a>2.3.4. putObject()</h3><p>BlockingCache.putObject()方法的实现如下所示：</p><pre><code class="java">  @Override  public void putObject(Object key, Object value) {    try {      //向缓存中添加缓存项      delegate.putObject(key, value);    } finally {      //释放锁      releaseLock(key);    }  }</code></pre><h2 id="2-3-FifoCache-amp-LruCache"><a href="#2-3-FifoCache-amp-LruCache" class="headerlink" title="2.3. FifoCache&amp;LruCache"></a>2.3. FifoCache&amp;LruCache</h2><h3 id="2-3-1-FifoCache"><a href="#2-3-1-FifoCache" class="headerlink" title="2.3.1. FifoCache"></a>2.3.1. FifoCache</h3><p>在很多场景下，为了控制缓存的大小，系统需要按照一定的规则清理缓存。FifoCache是先进先出版本的装饰器，当向缓存添加数据时，如果缓存项中的个数已经达到了上线，则会将缓存中最老（即最早进入缓存）的缓存项删除。</p><p>FifoCache中各个字段的含义如下：</p><pre><code class="java">  /**   * 底层被装饰的底层Cache对象   */  private final Cache delegate;  /**   * 用于记录key进入缓存的先后顺序，使用的是LinkedList&lt;Object&gt;类型的集合对象   */  private final Deque&lt;Object&gt; keyList;  /**   * 记录缓存项的上线，超过该值，则需要清理最老的缓存项   */  private int size;</code></pre><p>FifoCache的getObject()和removerObject()方法的实现都是直接调用底层Cache对象的对应方法。在FifoCache.putObject()方法中会完成缓存项个数的检测以及缓存的清理操作，具体实现如下所示：</p><pre><code class="java">  @Override  public void putObject(Object key, Object value) {    //检测并清理缓存    cycleKeyList(key);    //条件缓存项    delegate.putObject(key, value);  }  private void cycleKeyList(Object key) {    //记录key    keyList.addLast(key);    //如果达到缓存上线，则清理最老的缓存项    if (keyList.size() &gt; size) {      Object oldestKey = keyList.removeFirst();      delegate.removeObject(oldestKey);    }  }</code></pre><h3 id="2-3-2-LruCache"><a href="#2-3-2-LruCache" class="headerlink" title="2.3.2. LruCache"></a>2.3.2. LruCache</h3><p><code>LruCache</code>是按照近期最少使用算法（<code>Least Recently Used , LRU</code>）进行缓存清理的装饰器，在需要清理换成时，它会清除最近最少使用的缓存项。<code>LruCache</code>中定义的各个字段的含义如下：</p><pre><code class="java"> /**   * 被装饰的底层Cache对象   */  private final Cache delegate;  /**   * LinkedHashMap&lt;Object,Object&gt; 类型对象，它是一个有序的HashMap，用于记录key最近的使用情况   */  private Map&lt;Object, Object&gt; keyMap;  /**   * 记录最少被使用的缓存项的key   */  private Object eldestKey;</code></pre><p><code>LruCache</code>的构造方法默认设置的缓存大小是<code>1024</code>，我们可以通过其<code>setSize()</code>方法重新设置缓存大小，具体实现如下：</p><pre><code class="java">  /**   * 重置设置缓存大小，   * @param size   */  public void setSize(final int size) {    //注意LinkedHashMap构造函数的第三个参数，true表示该LinkedHashMap记录的属性是access-order，也就是说LinkedHashMap.get()方法会百变器记录的顺序    keyMap = new LinkedHashMap&lt;Object, Object&gt;(size, .75F, true) {      private static final long serialVersionUID = 4267176411845948333L;      //当调用LinkedHashMap.put()方法时，会调用该方法      @Override      protected boolean removeEldestEntry(Map.Entry&lt;Object, Object&gt; eldest) {        //判断hashMap的长度是否大于限定的缓存长度        boolean tooBig = size() &gt; size;        //如果达到缓存上限，后面会删除该项        if (tooBig) {          //获取需要删除的key          eldestKey = eldest.getKey();        }        return tooBig;      }    };  }</code></pre><p>以上代码涉及到了<code>LinkedHashMap</code>的相关方法，我们可以用一个例子解释：</p><pre><code class="java">package red.reksai.javabase;import java.util.LinkedHashMap;import java.util.Map;/** * 高频词汇处理，热度排行 * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/12/2 14:38 */public class LinkedHashMapTest {  static Object eldKey ;  public static void main(String[] args) {    int size = 3;    LinkedHashMap&lt;String, String &gt; linkedHashMap = new LinkedHashMap&lt;String,String &gt;(size, .75F, true){      @Override      protected boolean removeEldestEntry(Map.Entry&lt;String,String&gt; eldest) {        if (size()&gt;size){          eldKey = eldest.getKey();        }        return size()&gt;size ;      }    };    linkedHashMap.put(&quot;1&quot;,&quot;1&quot;);    linkedHashMap.put(&quot;2&quot;,&quot;2&quot;);    linkedHashMap.put(&quot;3&quot;,&quot;3&quot;);    linkedHashMap.get(&quot;1&quot;);    System.out.println(linkedHashMap);    linkedHashMap.put(&quot;4&quot;,&quot;4&quot;);    System.out.println(linkedHashMap);  }}</code></pre><p>运行结果：</p><pre><code class="java">{2=2, 3=3, 1=1}{3=3, 1=1, 4=4}</code></pre><p><code>LruCache</code>就是通过<code>LinkedHashMap</code>的以上特性来确定最久未被使用的缓存项。</p><p><code>LruCache.getObject()</code>方法除了返回缓存项，还会调用<code>keyMap.get()</code>修改<code>key</code>的顺序，表示指定的<code>key</code>最近被使用，具体实现如下所示：</p><pre><code class="java">  @Override  public Object getObject(Object key) {    //修改LinkedHashMap中记录的顺序    keyMap.get(key);    //返回查询的对象    return delegate.getObject(key);  }</code></pre><p><code>LruCache.putObject()</code>方法畜类添加缓存项，还会将<code>eldsetKey</code>字段指定的缓存项清理掉，具体实现如下所示：</p><pre><code class="java">  @Override  public void putObject(Object key, Object value) {    //添加缓存项    delegate.putObject(key, value);    //删除最久未使用的缓存项    cycleKeyList(key);  }   private void cycleKeyList(Object key) {    keyMap.put(key, key);    //eldestKey不为空表示已达到缓存上限    if (eldestKey != null) {      //删除最久未被使用的缓存项      delegate.removeObject(eldestKey);      eldestKey = null;    }  }</code></pre><h2 id="2-4-SoftCache-amp-WeakCache"><a href="#2-4-SoftCache-amp-WeakCache" class="headerlink" title="2.4. SoftCache&amp;WeakCache"></a>2.4. SoftCache&amp;WeakCache</h2><p>在开始介绍<code>SofrCache</code>和<code>WeakCache</code>实现之前， 先了解Java提供的引用类型，它们分别是强引用（<code>Strong Reference</code>）、软引用（<code>SoftReference</code>）、弱引用（<code>WeakReference</code>）和幽灵引用（<code>Phantom Reference</code>）。</p><h3 id="2-4-1-Refernece"><a href="#2-4-1-Refernece" class="headerlink" title="2.4.1. Refernece"></a>2.4.1. Refernece</h3><h4 id="2-4-1-1-强引用"><a href="#2-4-1-1-强引用" class="headerlink" title="2.4.1.1. 强引用"></a>2.4.1.1. 强引用</h4><p>强引用是Java编程中最普遍的引用，例如<code>Object obj = new Object()</code>中，新建的<code>Object</code>对象就是被强引用的。如果一个对象被强引用，即使是Java虚拟机内存空间不足时，<code>GC</code>也绝对不会回收该对象。当<code>Java</code>虚拟机内存不足时，就可能会导致内存溢出，我们常见的就是<code>OutOfMemoryError</code>异常。</p><h4 id="2-4-1-2-软引用"><a href="#2-4-1-2-软引用" class="headerlink" title="2.4.1.2. 软引用"></a>2.4.1.2. 软引用</h4><p>软引用是引用强度仅弱于强引用的一种引用，它使用类<code>SoftReference</code>来表示。当Java虚拟机内存不足时，<code>GC</code>会回收那些只被软引用只想的对象，从而避免内存溢出。在<code>GC</code>释放了那些只被软引用指向的对象之后，虚拟机内存依然不足，才会抛出<code>OutOfMemmoryError</code>异常。软引用适合引用那些可以通过其他方式恢复的对象，例如，数据库缓存中的对象就可以从数据库中恢复，所以<strong>软引用可以用来实现缓存</strong>，下面将要介绍的<code>SoftCache</code>就是通过软引用实现的。</p><p>另外，由于程序使用软引用之前的某个时刻，其所指向的对象可能已经被<code>GC</code>回收掉了，所以通过<code>Reference.get()</code>方法来获取软引用所指向的对象时，总要通过检查该方法返回值是否为<code>null</code>，来判断被软引用的对象是否还存活。</p><h4 id="2-4-1-3-引用队列ReferenceQueue"><a href="#2-4-1-3-引用队列ReferenceQueue" class="headerlink" title="2.4.1.3. 引用队列ReferenceQueue"></a>2.4.1.3. 引用队列<code>ReferenceQueue</code></h4><p>在很多场景下，我们的程序需要在一个对象的可达性（是否已经被<code>GC</code>回收）发生变化时得到通知，引用队列就是用于收集这些信息的队列。在创建<code>SoftReference</code>对象时，可以为其关联一个引用队列，当<code>SoftReference</code>所引用的对象被<code>GC</code>回收时，Java虚拟机就会将该<code>SoftReference</code>对象添加到与之关联的引用队列中。当需要检测这些通知信息时，就可以从引用队列中获取这些<code>SoftReference</code>对象。不仅是<code>SoftReference</code>对象，下面介绍的弱引用和幽灵引用都可以关联相应的队列。</p><h4 id="2-4-1-4-弱引用"><a href="#2-4-1-4-弱引用" class="headerlink" title="2.4.1.4. 弱引用"></a>2.4.1.4. 弱引用</h4><p>弱引用的强度比软引用的强度还弱。弱引用使用<code>WeakReference</code>来表示，它可以引用一个对象，但并不阻止被引用的对象被<code>GC</code>回收。在虚拟机进行<code>GC</code>时，如果指向了一个对象的所有引用都是弱引用，那么该对象会被回收。由此可见，只被弱引用所指向的对象的生命周期是两次<code>GC</code>之间的这段时间。而只被软引用所指向的对象可以经历多次<code>GC</code>，知道出现内存紧张的情况才被回收。</p><p>弱引用典型的应用场景就是<code>JDK</code>提供的<code>java.util.WeakHashMap</code>。<code>WeakHashMap.Entity</code>实现继承了<code>WeakReference</code>。<code>Entity</code>弱引用<code>key</code>，强引用<code>vaule</code>。如图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191203095533-ekS6KA.png!github_blog" srcset="undefined" alt=""></p><p>当不再有强引用指向key的时候，则key可以被垃圾回收，当key被垃圾回收之后，对应的Entity对象也会被Java虚拟机加入到其他关联队列中。当应用程序瑕疵操作WeakHashMap时，例如对WeakHashMap的扩容操作，就会遍历关联的引用队列，将其中的Entity对象从WeakHashMap中删除。</p><h4 id="2-4-1-5-幽灵引用"><a href="#2-4-1-5-幽灵引用" class="headerlink" title="2.4.1.5. 幽灵引用"></a>2.4.1.5. 幽灵引用</h4><p>在介绍幽灵引用的时候，要先了解一下Java提供的对象终止化机制。在Object类里面有一个finalize()方法，设计该方法的初衷是在一个对象被真正回收之前，执行一些清理工作，但是GC的运行时间是不确定的，所以这些清理工作的实际运行时间也是无法预知的，而且JVM虚拟机不能保证finalize()方法一定会被调用。每个对象的finalize()方法至多由GC执行一次，对于再生对象GC不会再次调用其finalize()方法。另外，使用finalize()方法还会导致严重的内存消耗和性能损失。由于finalize()方法存在的种种问题，该方法现在已经被废弃，而我们可以使用幽灵引用实现其代替方案。</p><p>幽灵引用，又叫“虚引用”，它是最弱的一种引用类型， 有类PhantomReference表示。在引用对象被GC回收时，调用签名介绍的SoftReference以及WeakReference的get()方法，得到的是其引用的对象；当引用的对象已经被GC回收时，则得到null。但是PhantomReference.get()方法始终返回null。</p><p>在创建幽灵引用的时候必须要指定一个引用队列。当GC准备回收一个对象的时候，如果发现它还是幽灵引用，就会在回收对象的内存之前，把该虚引用加入到与之关联的引用队列中。程序可以通过检查该引用队列里面的内容，跟踪对象是否已经被回收并惊醒一些清理工作。幽灵引用还可以用来实现比较精细的内存使用控制，例如应用程序可以在确定一个对象要被回收之后，再申请内存创建对象，但这种需求并不多见。</p><p>介绍完Java提供的四种引用类型，我们来介绍SoftCache的实现。</p><h3 id="2-4-2-SoftCache"><a href="#2-4-2-SoftCache" class="headerlink" title="2.4.2. SoftCache"></a>2.4.2. SoftCache</h3><p>SoftCache中各个字段的含义如下所示：</p><h1 id="3-CacheKey"><a href="#3-CacheKey" class="headerlink" title="3. CacheKey"></a>3. CacheKey</h1><p>在Cache中唯一确定一个缓存项需要使用缓存项的key，Mybatis中因为涉及到动态SQL等方面的因素，其缓存的key不能仅仅通过一个String表示，所以Mybatis提供了CacheKey类来表示缓存项的key，在一个Cachekey对象中可以封装多个影响缓存项的因素。</p><p>CacheKey中可以添加多个对象，有这些对象共同确定两个CacheKey对象是否相同。</p><p>CacheKey中核心字段的含义和功能如下所示：</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binding模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/binding%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/binding%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="binding模块"><a href="#binding模块" class="headerlink" title="binding模块"></a>binding模块</h1><p>在<code>iBatis</code>（<code>Mybatis</code>的前身）中，在查询一个<code>Blog</code>对象的时候会调用<code>SqlSession.queryForObject(&quot;selectBlog&quot;,blogId)</code>方法。其中，<code>SqlSession.queryForObject()</code>方法会执行指定的<code>SQL</code>语句进行查询并返回一个结果对象，第一个参数“selectBlog”指明了具体执行的<code>SQL</code>语句的<code>id</code>，该<code>SQL</code>语句定义在相应的映射配置文件中。如果我们错将“<code>selectBlog</code>”写成了“<code>selectBlog1</code>”，在初始化过程中，<code>Mybatis</code>是无法提示该错误的，而在实际调用<code>queryForObject(&quot;selectBlog1&quot;,blogId)</code>方法时才会抛出异常，开发人员才能知道该错误。</p><p>Mybatis提供了binding模块用于解决上述问题，我们可以定义一个接口（Mapper接口），该示例中为TbBlogMapper接口，具体代码如下所指示。注意，这里的TbBlogMapper接口并不需要去继承任何其它接口，而且开发人员不需要提供该接口的实现。</p><pre><code class="java">/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/12/3 15:56 */public interface TbBlogMapper {    List&lt;Map&gt; selectBlogDetails1(@Param(&quot;id&quot;) int id);    List&lt;TbBlog&gt; selectBlogDetails2(@Param(&quot;id&quot;) int id);    List&lt;TbBlog&gt; selectBlogDetails3(@Param(&quot;id&quot;) int id);    List&lt;Map&gt; selectBlogList();}</code></pre><p>该Mapper接口中定义了SQL语句对应的方法，这些方法在Mybatis初始化过程中会与映射配置文件中定义的SQL语句相关联。如果存在无法关联的SQL语句，在Mybatis的初始化过程中节点就会抛出异常。我们可以通过调用Mapper接口中的方法执行相应的SQL语句，这样编译器就可以帮我们提早发现上述问题。查询Blog对象就变成了如下代码：</p><pre><code class="java">BlogMapper blogMapper = sqlSessionFactory.openSession().getMapper(BlogMapper.class);    System.out.println(blogMapper.selectBlog(1));</code></pre><p>在开始分析binding模块的实现之前，先了解一下该模块中核心组件之间的关系，如图所示（Mybatis3.4版本）：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208153336-ujLRln.png!github_blog" srcset="undefined" style="zoom:67%;" /><p>在Mybatis3.5的时候，引入了MapperMethodInvoker，引入原因在后续源码分析中会介绍，所以核心组件之间的关系就发生了变化，如图所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191209001132-lC9CdA.png!github_blog" srcset="undefined" style="zoom:67%;" /><h1 id="1-MapperRegistry"><a href="#1-MapperRegistry" class="headerlink" title="1. MapperRegistry"></a>1. MapperRegistry</h1><p>MapperRegistry是Mapper接口及其对应的代理工厂的注册中心，MapperRegistry中字段的含义如下所示：</p><pre><code class="java"> /**   * Configuration对象，Mybatis全局唯一的配置对象，其中包含了所有配置信息   */  private final Configuration config;  /**   * 记录了Mapper接口与定义{@link MapperProxyFactory}之间的关系   */  private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();</code></pre><h2 id="1-1-addMapper"><a href="#1-1-addMapper" class="headerlink" title="1.1. addMapper()"></a>1.1. addMapper()</h2><p>在<code>Mybatis</code>初始化过程中会读取映射配置文件以及<code>Mapper</code>接口中的注解信息（<code>XMLConfigBuilder.mapperElement()</code>，并调用<code>MapperRegistry.addMapper()</code>方法填充<code>MapperRegistry.knownMappers</code>集合），<code>knownMappers</code>集合的<code>key</code>是<code>Mapper</code>接口对应的<code>Class</code>对象，<code>value</code>为<code>MapperProxyFactory</code>对象，<code>MapperProxyFactory</code>可以为<code>Mapper</code>接口创建代理对象，<code>MapperProxyFactory</code>的实现马上就会分析到。<code>MapperRegistry.addMapper()</code>方法实现如下：</p><pre><code class="java"> /**   * 添加Mapper   * {@link org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement(XNode)} 中调用了addMapper(Class)     * @param type   * @param &lt;T&gt;   */  public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {    //判断是不是接口类型    if (type.isInterface()) {      //是接口类型      //判断Configuration.knownMappers中是否已经有了，即检测是否已经加载过该接口      if (hasMapper(type)) {        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);      }      boolean loadCompleted = false;      try {        //将Mapper接口对应的Class对象和MapperProxyFactory对象添加到knownMappers集合        knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));        // It&#39;s important that the type is added before the parser is run        // otherwise the binding may automatically be attempted by the        // mapper parser. If the type is already known, it won&#39;t try.        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);        parser.parse();        loadCompleted = true;      } finally {        if (!loadCompleted) {          knownMappers.remove(type);        }      }    }  }</code></pre><p>在<code>Mybatis3.2.2</code>之后的版本，<code>addMapper()</code>多了两个方法重载，具体如下所示：</p><pre><code class="java">/**   * @since 3.2.2   */  public void addMappers(String packageName, Class&lt;?&gt; superType) {    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();    for (Class&lt;?&gt; mapperClass : mapperSet) {      addMapper(mapperClass);    }  }  /**   * @since 3.2.2   */  public void addMappers(String packageName) {    addMappers(packageName, Object.class);  }</code></pre><p>这样就可以加载那些，没有<code>mapper.xml</code>配置文件对应的Mapper接口，而这些接口凭借注解，也可以完成相应的操作，示例如下所示：</p><ol><li><p>定义<code>CommentMapper</code>接口</p><pre><code class="java">package red.reksai.bingding.mapper;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import java.util.Map;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/12/8 16:25 */@Mapperpublic interface CommentMapper {  @Select(&quot;select * from tb_comment where comment_id = #{id}&quot;)  public Map selectTbComment(@Param(&quot;id&quot;)int id);}</code></pre></li><li><p>修改<code>mybatis-config.xml</code>配置</p><pre><code class="xml"> &lt;!--在&lt;mappers&gt;内，&lt;mapper&gt;下添加如下配置--&gt; &lt;package name=&quot;red.reksai.bingding.mapper&quot;/&gt;</code></pre></li><li><p>调用<code>addMappers()</code>方法</p><p>调用链：<code>XMLConfigBuider.mapperElement()</code>–&gt;<code>MapperRegistry.addMappers()</code>。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208164710-dusvB3.png!github_blog" srcset="undefined" style="zoom:67%;" /><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208164812-A4jrm3.png!github_blog" srcset="undefined" style="zoom:67%;" /></li></ol><h2 id="1-2-getMapper"><a href="#1-2-getMapper" class="headerlink" title="1.2. getMapper()"></a>1.2. getMapper()</h2><p>在需要执行某<code>SQL</code>语句时，会先调用<code>MapperRegistry.getMapper()</code>方法获取实现了<code>Mapper</code>接口的代理对象，例如：<code>sqlSessionFactory.openSession().getMapper(CommentMapper.class)</code>方法得到的实际上是<code>Mybatis</code>通过<code>jdk</code>动态代理为<code>CommentMapper</code>接口生成的代理对象，如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191208165342-Gn3EQt.png!github_blog" srcset="undefined" alt=""></p><p><code>MapperRegistry.getMapper()</code>方法的代码如下所示：</p><pre><code class="java">  @SuppressWarnings(&quot;unchecked&quot;)  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {    //查找指定的type对应的MapperProxyFactory对象    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);    //如果mapperProxyFactory为空，则抛出异常    if (mapperProxyFactory == null) {      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);    }    try {      //如果mapperProxyFactory不为空，则生成Mapper接口的代理对象并返回      return mapperProxyFactory.newInstance(sqlSession);    } catch (Exception e) {      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);    }  }</code></pre><h1 id="2-MapperProxyFactory"><a href="#2-MapperProxyFactory" class="headerlink" title="2. MapperProxyFactory"></a>2. MapperProxyFactory</h1><p><code>MapperProxyFactory</code>主要负责创建代理对象，其中核心字段的含义如下所示：</p><pre><code class="java">  /**   * 需要代理的MapperInterface对象   */  private final Class&lt;T&gt; mapperInterface;  /**   * 缓存   *    key 是 mapperInterface接口中某方法对应的Method对象；   *    value 是 对应的MappedMethodInvoker   */  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();</code></pre><p><code>MapperProxyFactory.newInstance()</code>方法实现了<code>mapperInterface</code>接口的代理对象的功能，具体代码如下所示：</p><pre><code class="java">  @SuppressWarnings(&quot;unchecked&quot;)  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {    //创建实现了MapperInterface接口的代理对象，从这里可以看出MapperProxy实现了InvocationHandler接口    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);  }  public T newInstance(SqlSession sqlSession) {    //创建MapperProxy对象，每次调用都会创建新的MapperProxy对象    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);    return newInstance(mapperProxy);  }</code></pre><h1 id="3-MapperProxy"><a href="#3-MapperProxy" class="headerlink" title="3. MapperProxy"></a>3. MapperProxy</h1><p><code>MapperProxy</code>在<code>Mybatis3.4</code>版本和<code>mybatis3.5</code>版本是有很大差别的，分别分析不同版本的代码，了解<code>Mybatis</code>官方为什么要这么做？</p><h2 id="3-1-Mybatis3-4的MapperProxy"><a href="#3-1-Mybatis3-4的MapperProxy" class="headerlink" title="3.1. Mybatis3.4的MapperProxy"></a>3.1. Mybatis3.4的MapperProxy</h2><p><code>Mybatis3.4</code>的<code>MapperProxy</code>只展示代码，分析在下面的<code>Mybatis3.5</code>的<code>MapperProxy</code>中进行。</p><p><code>MapperProxy</code>中核心字段的含义如下：</p><pre><code class="java">  private final SqlSession sqlSession;  private final Class&lt;T&gt; mapperInterface;  private final Map&lt;Method, MapperMethod&gt; methodCache;</code></pre><p><code>MapperProxy.invoke()</code>方法，如下所示：</p><pre><code class="java"> @Override  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    try {      if (Object.class.equals(method.getDeclaringClass())) {        return method.invoke(this, args);      } else if (isDefaultMethod(method)) {        return invokeDefaultMethod(proxy, method, args);      }    } catch (Throwable t) {      throw ExceptionUtil.unwrapThrowable(t);    }    final MapperMethod mapperMethod = cachedMapperMethod(method);    return mapperMethod.execute(sqlSession, args);  }</code></pre><p><code>MapperProxy.cachedMapperMethod()</code>方法，如下所示：</p><pre><code>  private MapperMethod cachedMapperMethod(Method method) {    MapperMethod mapperMethod = methodCache.get(method);    if (mapperMethod == null) {      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());      methodCache.put(method, mapperMethod);    }    return mapperMethod;  }</code></pre><p><code>MapperProxy</code>中的其他方法，如下所示：</p><pre><code>@UsesJava7  private Object invokeDefaultMethod(Object proxy, Method method, Object[] args)      throws Throwable {    final Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup.class        .getDeclaredConstructor(Class.class, int.class);    if (!constructor.isAccessible()) {      constructor.setAccessible(true);    }    final Class&lt;?&gt; declaringClass = method.getDeclaringClass();    return constructor        .newInstance(declaringClass,            MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED                | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);  }  /**   * Backport of java.lang.reflect.Method#isDefault()   */  private boolean isDefaultMethod(Method method) {    return (method.getModifiers()        &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC        &amp;&amp; method.getDeclaringClass().isInterface();  }</code></pre><h2 id="3-2-Mybatis3-5的MapperProxy-amp-MapperProxy-MapperMethodInvoker"><a href="#3-2-Mybatis3-5的MapperProxy-amp-MapperProxy-MapperMethodInvoker" class="headerlink" title="3.2. Mybatis3.5的MapperProxy&amp;MapperProxy.MapperMethodInvoker"></a>3.2. Mybatis3.5的MapperProxy&amp;MapperProxy.MapperMethodInvoker</h2><p><code>MapperProxy</code>实现了<code>InvocationHandler</code>接口，那么该类的实现就是代理对象的核心逻辑，<code>MapperProxy</code>中核心字段的含义如下：</p><pre><code class="java">  /**   * MethodHandles.Lookup 允许查找的模式   */  private static final int ALLOWED_MODES = MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED      | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC;  /**   * MethodHandles.Lookup的Constructor对象，针对Java8   */  private static final Constructor&lt;Lookup&gt; lookupConstructor;  /**   * 针对Java9   */  private static final Method privateLookupInMethod;  /**   * 记录了关联的SqlSession对象   */  private final SqlSession sqlSession;  /**   * mapperInterface接口对应的class对象   */  private final Class&lt;T&gt; mapperInterface;  /**   * 缓存   *    key 是 mapperInterface接口中某方法对应的Method对象；   *    value 是 对应的MappedMethodInvoker   */  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache;</code></pre><p><code>MapperProxy</code>在初始化的时候，首先要加载如下静态代码段，具体如下所示：</p><pre><code class="java">  static {    Method privateLookupIn;    try {      // privateLookupIn 是java9中才有的（该方法可以模拟目标类上所有受支持的字节码行为，包括私有访问）      // 参见：https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html      privateLookupIn = MethodHandles.class.getMethod(&quot;privateLookupIn&quot;, Class.class, MethodHandles.Lookup.class);    } catch (NoSuchMethodException e) {      privateLookupIn = null;    }    privateLookupInMethod = privateLookupIn;    Constructor&lt;Lookup&gt; lookup = null;    //判断privateLookupInMethod是不是为空，如果为空表明当前的jdk版本低于jdk9，大于等于jdk1.7，    //因为MethodHandles是jdk1.7才提供的功能    if (privateLookupInMethod == null) {      // JDK 1.8      try {        //获取MethodHandles.Lookup中参数列表为(Class&lt;?&gt; lookupClass, int allowedModes)的构造器        lookup = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);        //将构造器设置为可访问的        lookup.setAccessible(true);      } catch (NoSuchMethodException e) {        throw new IllegalStateException(            &quot;There is neither &#39;privateLookupIn(Class, Lookup)&#39; nor &#39;Lookup(Class, int)&#39; method in java.lang.invoke.MethodHandles.&quot;,            e);      } catch (Exception e) {        lookup = null;      }    }    lookupConstructor = lookup;  }</code></pre><p>刚开始看如上代码有点懵逼，因为我的<code>java.lang.MethodHandles</code>中并没有找到方法名称为<code>privateLookupIn</code>的方法，后来根据参看<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html" target="_blank" rel="noopener">Java官方文档</a>（<code>Java9</code>版本）发现这是<code>Java9</code>新增的一个方法，通过查看官方文档关于这个方法的描述，也就读懂了上面的代码。</p><p><strong>对比<code>Mybatis3.4</code>是没有这段的，我发现引入了<code>MethodHandle</code>，引入的原因其实很简单：一是为了提高性能，二是为了安全，具体可以参看<code>Java9</code>版本关于<code>MethodHandle</code>的相关描述。</strong></p><p>我这里简单带一下思路：其实都是为了实现动态代理，只不过加入<code>MethodHandle</code>之后，流程发生了一点消息的变化，我写了一个简单的<code>Demo</code>，如下所示：</p><pre><code class="java">  @Test  public void test1() throws Throwable{    MethodHandles.Lookup lookup = MethodHandles.lookup();    MethodHandle replace = lookup.findVirtual(String.class, &quot;replace&quot;, MethodType.methodType(String.class, char.class, char.class));    System.out.println((String) replace.invoke(&quot;zhangsan&quot;, Character.valueOf(&#39;g&#39;), &#39;_&#39;));  }</code></pre><p>通过<code>Demo</code>发现要想执行<code>invoke</code>方法要分如下三步：</p><ol><li>获取<code>Lookup</code>对象，通过<code>MethodHandles.lookup()</code>，返回<code>MethodHandles.Lookup</code>对象；</li><li>根据得到的<code>lookup</code>对象去查找要执行的方法，并返回其封装的<code>MethodHandle</code>对象；</li><li>根据得到的<code>methodHandle</code>对象，调用<code>invoke()</code>方法去执行要代理对象要执行的方法。</li></ol><p>不管是Mybatis3.4和3.5版本，<code>MapperProxy.invoke()</code>方法还是<code>MapperProxy</code>中的重中之重，<code>Mybatis3.5</code>的<code>invoke()</code>方法如下所示：</p><pre><code class="java">@Override  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    try {      if (Object.class.equals(method.getDeclaringClass())) {        //如果当前方法是Object中的方法，直接invoke就可以了        return method.invoke(this, args);      } else {        //如果当前方法不属于Object对象的方法，        //那么：        //    1. 从缓存中查找        //    2. 调用invoke方法进行执行        // 参见： red.reksai.javabase.MethodHandlesTest        return cachedInvoker(proxy, method, args).invoke(proxy, method, args, sqlSession);      }    } catch (Throwable t) {      throw ExceptionUtil.unwrapThrowable(t);    }  }</code></pre><p>发现其调用了<code>cachedInvoke()</code>方法，<code>cachedInvoke()</code>如下所示：</p><pre><code class="java">private MapperMethodInvoker cachedInvoker(Object proxy, Method method, Object[] args) throws Throwable {  try {    //从缓存中查找method是否存在，如果不存在就创建一个并存入集合    return methodCache.computeIfAbsent(method, m -&gt; {      //判断当前方法是不是default类型的方法      if (m.isDefault()) {        //是default类型的方法        try {          if (privateLookupInMethod == null) {            //Java8            return new DefaultMethodInvoker(getMethodHandleJava8(method));          } else {            //Java9            return new DefaultMethodInvoker(getMethodHandleJava9(method));          }        } catch (IllegalAccessException | InstantiationException | InvocationTargetException            | NoSuchMethodException e) {          throw new RuntimeException(e);        }      } else {        //不是default类型的方法，就创建一个PlainMethodInvoker对象，并返回        return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));      }    });  } catch (RuntimeException re) {    Throwable cause = re.getCause();    throw cause == null ? re : cause;  }}</code></pre><p>以上代码还涉及到如下代码的调用，<code>MapperProxy</code>的其他方法，如下所示：</p><pre><code class="java">private MethodHandle getMethodHandleJava9(Method method)      throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {    final Class&lt;?&gt; declaringClass = method.getDeclaringClass();    return ((Lookup) privateLookupInMethod.invoke(null, declaringClass, MethodHandles.lookup())).findSpecial(        declaringClass, method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()),        declaringClass);  }  private MethodHandle getMethodHandleJava8(Method method)      throws IllegalAccessException, InstantiationException, InvocationTargetException {    final Class&lt;?&gt; declaringClass = method.getDeclaringClass();    return lookupConstructor.newInstance(declaringClass, ALLOWED_MODES).unreflectSpecial(method, declaringClass);  }  /**   * MapperMethod调用   */  interface MapperMethodInvoker {    Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable;  }  /**   * 普通方法调用   */  private static class PlainMethodInvoker implements MapperMethodInvoker {    private final MapperMethod mapperMethod;    public PlainMethodInvoker(MapperMethod mapperMethod) {      super();      this.mapperMethod = mapperMethod;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable {      return mapperMethod.execute(sqlSession, args);    }  }  /**   * 默认方法调用   */  private static class DefaultMethodInvoker implements MapperMethodInvoker {    private final MethodHandle methodHandle;    public DefaultMethodInvoker(MethodHandle methodHandle) {      super();      this.methodHandle = methodHandle;    }    @Override    public Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable {      return methodHandle.bindTo(proxy).invokeWithArguments(args);    }  }</code></pre><p>通过以上代码的分析，结合如下示例，我用时序图的形式描述了其执行流程，如下图所示：</p><pre><code class="java">CommentMapper mapper = sqlSessionFactory.openSession().getMapper(CommentMapper.class);    System.out.println(mapper.selectTbComment(1));</code></pre><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191209014817-pEQn5X.png!github_blog" srcset="undefined" alt=""></p><p>根据执行的时序图，我们接下来就应该去分析<code>MapperMethod</code>类了。</p><h1 id="4-MapperMethod"><a href="#4-MapperMethod" class="headerlink" title="4. MapperMethod"></a>4. MapperMethod</h1><p>MapperMethod中封装了Mapper接口中对应方法的信息，以及对应SQL语句的信息，MapperMethod可以看做是Mapper接口以及映射配置文件中定义的SQL语句的桥梁。MepperMethod中各个字段的信息如下：</p><pre><code class="java">  /**   * 记录了SQL语句的名称和类型   */  private final SqlCommand command;  /**   * Mapper接口中对应方法的相关新   */  private final MethodSignature method;</code></pre><h2 id="4-1-SqlCommand"><a href="#4-1-SqlCommand" class="headerlink" title="4.1. SqlCommand"></a>4.1. SqlCommand</h2><p><code>SqlCommand</code>是<code>MapperMethod</code>中定义的静态内部类，它使用了<code>name</code>字段记录<code>SQL</code>语句的名称，使用type字段（<code>SqlCommandType</code>类型）记录了<code>SQL</code>语句的类型。<code>SqlCommandType</code>是枚举类型，有效值<code>UNKNOWN</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>、<code>PLUSH</code>。<code>SqlCommand</code>的构造方法会初始化<code>name</code>字段和<code>type</code>字段，代码如下：</p><pre><code class="java">  public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) {       //获取方法的名称      final String methodName = method.getName();      //获取声明类      final Class&lt;?&gt; declaringClass = method.getDeclaringClass();      //获取对应的MapperStatement对象      MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,          configuration);      //判断MappedStatement对象是否为空      if (ms == null) {        //判断当前方法上是不是有@Flush注解        if (method.getAnnotation(Flush.class) != null) {          name = null;          type = SqlCommandType.FLUSH;        } else {          throw new BindingException(&quot;Invalid bound statement (not found): &quot;              + mapperInterface.getName() + &quot;.&quot; + methodName);        }      } else {        name = ms.getId();        type = ms.getSqlCommandType();        if (type == SqlCommandType.UNKNOWN) {          throw new BindingException(&quot;Unknown execution method for: &quot; + name);        }      }    }</code></pre><p><strong>以上代码有个作用于Method的注解@Flush，这个注解的作用在后续进行讲解。</strong></p><h2 id="4-2-MethodSignature"><a href="#4-2-MethodSignature" class="headerlink" title="4.2. MethodSignature"></a>4.2. MethodSignature</h2><p>MethodSignature也是MapperMethod中定义的内部类，其中封装了Mapper接口中定义的方法的相关信息，MethodSignature核心字段如下所示：</p><pre><code class="java">/** * 返回值类型是否为Collection类型或者是数组类型 */private final boolean returnsMany;/** * 返回值类型是否是Map类型 */private final boolean returnsMap;/** * 返回值类型是否为Void类型 */private final boolean returnsVoid;/** * 返回值是否是Cursor类型 */private final boolean returnsCursor;/** * 返回值是否是Optional类型 */private final boolean returnsOptional;/** * 返回值类型 */private final Class&lt;?&gt; returnType;/** * 如果返回值类型是Map,则该字段记录了作为key的列名 */private final String mapKey;/** * 用来标记该方法参数列表中ResultHandler类型参数的位置 */private final Integer resultHandlerIndex;/** * 用来标记该方法参数列表中RowBounds类型参数位置 */private final Integer rowBoundsIndex;/** * 该方法对应的ParamNameResolver对象 */private final ParamNameResolver paramNameResolver;</code></pre><p>在MethodSignature的构造函数中会解析相应的Method对象，并初始化上述字段，具体代码如下所示：</p><pre><code class="java"> public MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) {      //解析方法的返回值类型      Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);      //初始话MethodSignature的字段      if (resolvedReturnType instanceof Class&lt;?&gt;) {        this.returnType = (Class&lt;?&gt;) resolvedReturnType;      } else if (resolvedReturnType instanceof ParameterizedType) {        this.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();      } else {        this.returnType = method.getReturnType();      }      //初始化returnsVoid、returnsMany、returnsCursor、returnsOptional字段      this.returnsVoid = void.class.equals(this.returnType);      this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray();      this.returnsCursor = Cursor.class.equals(this.returnType);      this.returnsOptional = Optional.class.equals(this.returnType);      //若Method对应的方法的返回值是Map且指定了@MapKey注解，则使用getMapKey()方法处理      this.mapKey = getMapKey(method);      this.returnsMap = this.mapKey != null;      //初始话rowBoundsIndex      this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);      //初始化resultHandlerIndex      this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);      //创建ParamNameResolver对象      this.paramNameResolver = new ParamNameResolver(configuration, method);    }</code></pre><p>以上代码涉及到如下几个重要方法或对象：</p><h3 id="4-2-1-getMapKey"><a href="#4-2-1-getMapKey" class="headerlink" title="4.2.1. getMapKey()"></a>4.2.1. getMapKey()</h3><p><code>getMapKey()</code>的代码如下所示：</p><pre><code class="java">  private String getMapKey(Method method) {      String mapKey = null;      //首先判断返回值类型是不是Map      if (Map.class.isAssignableFrom(method.getReturnType())) {        //是map        //看有没有MapKey注解        final MapKey mapKeyAnnotation = method.getAnnotation(MapKey.class);        if (mapKeyAnnotation != null) {          //有MapKey注解则返回，对应的值          mapKey = mapKeyAnnotation.value();        }      }      return mapKey;    }</code></pre><p><code>@MapKey</code>作用于<code>Method</code>，在后续讲解中会涉及到，这里只做结果演示：</p><pre><code class="java"> @Select(&quot;select author_id , author_username from tb_author where author_username = #{name} order by author_id desc&quot;)    Map selectAuthorByName(@Param(&quot;name&quot;)String name);</code></pre><p>要查询的库，如下所示：</p><p>![image-20191217105110828](/Users/gnehcgnaw/Library/Application Support/typora-user-images/image-20191217105110828.png)</p><ol><li><p>查询<code>authot_name=root</code>，那么可以用<code>map</code>接收结果集，因为只有一条，结果是：<code>{author_id=1, author_username=root}</code></p></li><li><p>现在在<code>selectAuthorByName()</code>方法上加上<code>@MapKey(&quot;author_name&quot;)</code>注解，同样还是查询<code>authot_name=root</code>，结果是：<code>{root={author_id=1, author_username=root}}</code>，可以看出<code>MapKey</code>的作用就是指定<code>map</code>的<code>key</code>，把结果集作为<code>value</code>。</p></li><li><p>查询<code>authot_name=lisi</code>，那么正常情况下结果集应该是个<code>List</code>，如果用<code>Map</code>接收会报一个结果集不唯一的异常，但是加上<code>@MapKey(&quot;author_name&quot;)</code>注解之后就不一样了，结果是：<code>{lisi={author_id=3, author_username=lisi}}</code>，我们发现返回值只有一条，说明结果集被覆盖了，因为是用<code>key</code>是<code>lisi</code>，根据<code>Map</code>的特性，<code>key</code>为<code>lisi</code>的数据只有一条。</p></li></ol><p><strong>这里只是把这种现象演示出来，后面会涉及到如果方法上有<code>MapKey</code>标记，<code>Mybatis</code>是如何处理的？</strong></p><h3 id="4-2-2-getUniqueParamIndex"><a href="#4-2-2-getUniqueParamIndex" class="headerlink" title="4.2.2.getUniqueParamIndex()"></a>4.2.2.getUniqueParamIndex()</h3><p><code>getUniqueParamIndex()</code>方法的主要功能是查找指定类型的参数在参数列表中的位置，如下：</p><pre><code class="java">    private Integer getUniqueParamIndex(Method method, Class&lt;?&gt; paramType) {      Integer index = null;      final Class&lt;?&gt;[] argTypes = method.getParameterTypes();      //遍历MethodSignature对应方法的参数列表      for (int i = 0; i &lt; argTypes.length; i++) {        if (paramType.isAssignableFrom(argTypes[i])) {          if (index == null) {            //记录paramType类型参数在参数列表中的位置索引            index = i;          } else {            //RowBounds和ResultHandler类型的参数只能有一个，不能重复出现            throw new BindingException(method.getName() + &quot; cannot have multiple &quot; + paramType.getSimpleName() + &quot; parameters&quot;);          }        }      }      return index;    }</code></pre><h3 id="4-2-3-convertArgsToSqlCommandParam"><a href="#4-2-3-convertArgsToSqlCommandParam" class="headerlink" title="4.2.3.convertArgsToSqlCommandParam()"></a>4.2.3.convertArgsToSqlCommandParam()</h3><p><code>MethodSignature</code>还提供了对应字段的<code>getter/setter</code>方法，其中<code>convertArgsToSqlCommandParam()</code>方法需要介绍一下：</p><pre><code class="java">    /**     * 负责将agr[]数组（用户传入的实参列表）转化成SQL语句的参数列表，它是通过ParamNameResolver.getNamedParams()方法完成的。     * @param args     * @return     */    public Object convertArgsToSqlCommandParam(Object[] args) {      return paramNameResolver.getNamedParams(args);    }</code></pre><h2 id="4-3-execute"><a href="#4-3-execute" class="headerlink" title="4.3. execute()"></a>4.3. execute()</h2><p>分析完MapperMethod中定义的内部类之后，回到MapperMethod继续分析。MapperMethod的核心方式execute()方法，它会根据SQL语句的类型调用SqlSession对应的方法完成数据库操作。SqlSession是Mybatis的核心组件之一，其具体实现后面会详细介绍，这里暂时只需要知道它负责完成数据库操作即可。MapperMethod.execute()方法的具体实现如下：</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transaction</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/Transaction.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/Transaction.html</url>
    
    <content type="html"><![CDATA[<h1 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h1><h1 id="1-Transcation"><a href="#1-Transcation" class="headerlink" title="1. Transcation"></a>1. Transcation</h1><p>在实践开发中，控制数据库事务是一件非常重要的工作，<code>Mybatis</code>使用<code>Transaction</code>接口对数据库事务进行了抽象，<code>Transcation</code>接口的定义如下：</p><pre><code class="java">public interface Transaction {  /**   * 获取对应的数据库连接对象   * Retrieve inner database connection.   * @return DataBase connection   * @throws SQLException   */  Connection getConnection() throws SQLException;  /**   * 提交事务   * Commit inner database connection.   * @throws SQLException   */  void commit() throws SQLException;  /**   * 回滚事务   * Rollback inner database connection.   * @throws SQLException   */  void rollback() throws SQLException;  /**   * 关闭数据库连接   * Close inner database connection.   * @throws SQLException   */  void close() throws SQLException;  /**   * 获取事务超时时间   * Get transaction timeout if set.   * @throws SQLException   */  Integer getTimeout() throws SQLException;}</code></pre><p><code>Transaction</code>接口有<code>JdbcTranscation</code>和<code>ManagedTranscation</code>两个实现，其对象分别由<code>JdbcTranscationFactory</code>和<code>ManagedTranscationFactoy</code>负责创建。这里也使用利用了工厂方法模式。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191201160809-pfdyf4.png!github_blog" srcset="undefined" alt=""></p><h2 id="1-1-JdbcTranscation"><a href="#1-1-JdbcTranscation" class="headerlink" title="1.1. JdbcTranscation"></a>1.1. JdbcTranscation</h2><p><code>JdbcTranscation</code>依赖<code>JDBC Connection</code>控制事务的提交和回滚。<code>JdbcTranscation</code>中字段的含义如下所示：</p><pre><code class="java">  /**   * 事务对应的数据库连接   */  protected Connection connection;  /**   * 数据库连接所属的DataSource   */  protected DataSource dataSource;  /**   * 事务的隔离级别   */  protected TransactionIsolationLevel level;  /**   * 是否自动提交   */  protected boolean autoCommit;</code></pre><p><code>JdbcTranscation</code>的构造方法有两个，分别是传递了<code>Connection</code>的，另一个没有传递的，代码如下所示：</p><pre><code class="java">  /**   * 使用此构造方法，设置了除连接以外的值，至于connection字段的值，在调用{@link Transaction#getConnection()}的时候，   * 调用到{@link DataSource#getConnection()}获取，   *   * 通过这种方式，Connection对象中设置的事务的隔离级别和是否自动提交属性，不会覆盖（除非为null）。   * @param ds   * @param desiredLevel   * @param desiredAutoCommit   */  public JdbcTransaction(DataSource ds, TransactionIsolationLevel desiredLevel, boolean desiredAutoCommit) {    dataSource = ds;    level = desiredLevel;    autoCommit = desiredAutoCommit;  }  /**   * 使用此构造方法，事务的隔离级别和是否自动提交使用的都是Connection中的配置   * @param connection   */  public JdbcTransaction(Connection connection) {    this.connection = connection;  }</code></pre><p>这两者的区别在代码注释中也讲得很清楚了，下面是设计到创建<code>JdbcTranscation</code>对象涉及到的其他方法：</p><pre><code class="java">  @Override  public Connection getConnection() throws SQLException {    if (connection == null) {      openConnection();    }    return connection;  }</code></pre><pre><code class="java">protected void openConnection() throws SQLException {    if (log.isDebugEnabled()) {      log.debug(&quot;Opening JDBC Connection&quot;);    }    connection = dataSource.getConnection();    if (level != null) {      connection.setTransactionIsolation(level.getLevel());    }    setDesiredAutoCommit(autoCommit);  }</code></pre><p><code>JdbcTranscation</code>还有其他方法，例如：<code>commit()</code>和<code>rollback()</code>等，都很简单，不在阐述。</p><h2 id="1-2-ManagedTranscation"><a href="#1-2-ManagedTranscation" class="headerlink" title="1.2. ManagedTranscation"></a>1.2. ManagedTranscation</h2><p><code>ManagedTranscation</code>的实现更加简单，它同样依赖其中的<code>dataSource</code>字段获取连接，但其<code>commit()</code>和<code>rollback()</code>方法都是空实现，事务的提交和回滚都要依赖容器管理的，<code>ManagedTranscation</code>通过<code>closeConnection</code>字段的值控制数据库连接的关闭行为。</p><h1 id="2-TranscationFactory"><a href="#2-TranscationFactory" class="headerlink" title="2. TranscationFactory"></a>2. TranscationFactory</h1><p><code>TranscationFactory</code>接口定义了配置新建<code>TranscationFactory</code>对象的方法，以及创建<code>Transcation</code>对象的方法，代码如下：</p><pre><code class="java">public interface TransactionFactory {  /**   * 配置TransactionFactory对象，一般紧跟着创建完成之后，完成对TransactionFactory的自定义配置   * Sets transaction factory custom properties.   * @param props   */  default void setProperties(Properties props) {    // NOP  }  /**   * 在指定的连接上创建Transaction对象   * Creates a {@link Transaction} out of an existing connection.   * @param conn Existing database connection   * @return Transaction   * @since 3.1.0   */  Transaction newTransaction(Connection conn);  /**   * 从指定数据源中获取数据库连接，并在此连接上创建Transaction对象   * Creates a {@link Transaction} out of a datasource.   * @param dataSource DataSource to take the connection from   * @param level Desired isolation level   * @param autoCommit Desired autocommit   * @return Transaction   * @since 3.1.0   */  Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel level, boolean autoCommit);}</code></pre><p>在实践中，<code>Mybatis</code>通常会与<code>Spring</code>继承使用，数据库的事务是交给<code>Spring</code>进行管理的，其中接口为<code>SpringManagedTranscation</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataSource</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/DataSource.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/DataSource.html</url>
    
    <content type="html"><![CDATA[<h1 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h1><h1 id="1-工厂方法模式"><a href="#1-工厂方法模式" class="headerlink" title="1. 工厂方法模式"></a>1. 工厂方法模式</h1><h1 id="2-DataSourceFactory"><a href="#2-DataSourceFactory" class="headerlink" title="2. DataSourceFactory"></a>2. DataSourceFactory</h1><p>在数据源模块中，<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%B8%80).html#3-8-%E8%A7%A3%E6%9E%90-lt-environments-gt-%E8%8A%82%E7%82%B9" target="_blank" rel="noopener">DataSourceFactory</a>接口扮演工厂接口的角色。<code>UnpooledDataSourceFactory</code>和<code>PooledDataSourceFactory</code>则扮演着具体工厂类的角色。</p><p>我们从<code>DataSourceFactory</code>接口开始分析，其定义如下：</p><pre><code class="java">  /**   * 设置DataSource相关属性，   * 一切紧跟在初始化完成之后，证明：   *  {@link org.apache.ibatis.builder.xml.XMLConfigBuilder#dataSourceElement(XNode)}   * @param props   */  void setProperties(Properties props);  /**   * 获取DataSource对象   * @return   */  DataSource getDataSource();</code></pre><h2 id="2-1-UnpooledDataSourceFactory"><a href="#2-1-UnpooledDataSourceFactory" class="headerlink" title="2.1. UnpooledDataSourceFactory"></a>2.1. UnpooledDataSourceFactory</h2><p>在<code>UnpooledDataSourceFactory</code>的构造方法中会直接创建<code>UnpooledDataSource</code>对象，并初始化<code>UnpooledDatasourceFactory.dataSource</code>字段。</p><pre><code class="java">  protected DataSource dataSource;  /**   * 直接创建一个{@link UnpooledDataSource}   */  public UnpooledDataSourceFactory() {    this.dataSource = new UnpooledDataSource();  }</code></pre><p><code>UnpooledDataSourceFactory.setProperties()</code>方法会完成对<code>UnpooledDataSourceFactory</code>对象的配置，代码如下：</p><pre><code class="java">@Override  public void setProperties(Properties properties) {    Properties driverProperties = new Properties();    //创建DataSource对应的MetaObject    MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);    //遍历properties集合，该集合中配置了数据源需要的信息    for (Object key : properties.keySet()) {      String propertyName = (String) key;      //以&quot;diver.&quot;开头的配置项是对DataSource的配置，记录到diverProperties中保存      if (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) {        String value = properties.getProperty(propertyName);        driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);      }      //是否有该属性对应的setter方法      else if (metaDataSource.hasSetter(propertyName)) {        String value = (String) properties.get(propertyName);        //根据属性类型将value的类型进行类型转换，主要是Integer、Long、Boolean三种类型转换        Object convertedValue = convertValue(metaDataSource, propertyName, value);        //设置DataSource的相关属性        metaDataSource.setValue(propertyName, convertedValue);      } else {        throw new DataSourceException(&quot;Unknown DataSource property: &quot; + propertyName);      }    }    //设置DataSource的driverProperties属性    if (driverProperties.size() &gt; 0) {      metaDataSource.setValue(&quot;driverProperties&quot;, driverProperties);    }  }</code></pre><h2 id="2-2-PooledDataSourceFactory"><a href="#2-2-PooledDataSourceFactory" class="headerlink" title="2.2. PooledDataSourceFactory"></a>2.2. PooledDataSourceFactory</h2><p><code>PooledDataSourceFactory</code>继承了<code>UnpooledDataSourceFactory</code>，但是并没有覆盖<code>setProperties()</code>和<code>getDataSource()</code>方法。两者唯一不同的是<code>PoolDataSoueceFactory</code>的构造函数会将其<code>dataSource</code>字段初始化为<code>PooledDataSource</code>对象。</p><pre><code class="java">/** * 继承了{@link UnpooledDataSourceFactory},但是并没有覆盖{@link UnpooledDataSourceFactory#setProperties(Properties)}和{@link UnpooledDataSourceFactory#getDataSource()}方法， * 唯一不同的是初始化的dataSource是不同的： *      {@link UnpooledDataSourceFactory} 初始化了{@link org.apache.ibatis.datasource.unpooled.UnpooledDataSource} *      {@link PooledDataSourceFactory} 初始化了{@link PooledDataSource} * @author Clinton Begin */public class PooledDataSourceFactory extends UnpooledDataSourceFactory {  public PooledDataSourceFactory() {    this.dataSource = new PooledDataSource();  }}</code></pre><h2 id="2-3-JndiDataSourceFactory"><a href="#2-3-JndiDataSourceFactory" class="headerlink" title="2.3. JndiDataSourceFactory"></a>2.3. JndiDataSourceFactory</h2><p><code>JndiDataSourceFactory</code>是依赖<a href="https://baike.baidu.com/item/JNDI/3792442?fr=aladdin" target="_blank" rel="noopener">JNDI</a>服务从容器中获取用户配置的<code>DataSource</code>，其逻辑并不复杂，可以参看<a href="https://tomcat.apache.org/tomcat-8.5-doc/jndi-resources-howto.html" target="_blank" rel="noopener">Tomcat的JNDI</a>相关文档。</p><h1 id="3-DataSource"><a href="#3-DataSource" class="headerlink" title="3. DataSource"></a>3. DataSource</h1><p><code>javax.sql.DataSource</code>接口在数据源模块中扮演了产品接口的角色，<code>Mybatis</code>提供了两个<code>DataSource</code>接口的实现类，分别是<code>UnpooledDataSource</code>和<code>PooledDataSource</code>，他们扮演着具体产品类的角色。</p><h2 id="3-1-UnpooledDataSource"><a href="#3-1-UnpooledDataSource" class="headerlink" title="3.1. UnpooledDataSource"></a>3.1. UnpooledDataSource</h2><p><code>UnpooledDataSource</code>实现了<code>javax.sql.DataSource</code>接口中定义的<code>getConnection()</code>方法及其重载方法，用于获取数据库连接。每次通过<code>UnpooledDataSource.getConnection()</code>方法获取数据库连接时都会创建一个新连接。<code>UnpooledDataSource</code>中的字段如下，每个字段都有对应的<code>getter</code>和<code>setter</code>方法：</p><pre><code class="java">  /**   * 加载Driver类的类加载器   */  private ClassLoader driverClassLoader;  /**   * 数据库连接驱动的相关配置   */  private Properties driverProperties;  /**   * 缓存所有已注册的数据库连接驱动   */  private static Map&lt;String, Driver&gt; registeredDrivers = new ConcurrentHashMap&lt;&gt;();  /**   * 数据库连接驱动的名称   */  private String driver;  /**   * 数据库Url   */  private String url;  /**   * 用户名   */  private String username;  /**   * 密码   */  private String password;  /**   * 是否自动提交   */  private Boolean autoCommit;  /**   * 事务隔离级别   */  private Integer defaultTransactionIsolationLevel;  /**   * 默认连接网络超时（3.5.2）   */  private Integer defaultNetworkTimeout;</code></pre><h3 id="3-1-1-向DriverManager注册驱动"><a href="#3-1-1-向DriverManager注册驱动" class="headerlink" title="3.1.1. 向DriverManager注册驱动"></a>3.1.1. 向<code>DriverManager</code>注册驱动</h3><p>以<code>JDBC</code>为例，我们知道创建数据库连接之前，首先要向<code>DriverManager</code>注册<code>JDBC</code>驱动类，<code>com.mysql.jdbc.Driver</code>中有如下静态代码块：</p><pre><code class="java">//com.mysql.jdbc.Driver.javastatic {        try {//#ifdef JAVA8            DriverManager.registerDriver(driverInstance, new EmptyDiverAction());//#else/*            DriverManager.registerDriver(driverInstance);*///#endif JAVA8        } catch (Exception e) {        }    }  public static final JDBCDriver driverInstance = new JDBCDriver();</code></pre><p><code>DriverManager</code>中定义了<code>registerDrivers</code>字段用于记录注册的<code>JDBC</code>驱动，定义如下：</p><pre><code class="java">//java.sql.DriverManager.java// List of registered JDBC drivers    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();  public static synchronized void registerDriver(java.sql.Driver driver,            DriverAction da)        throws SQLException {        /* Register the driver if it has not already been added to our list */        if(driver != null) {            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));        } else {            // This is for compatibility with the original DriverManager            throw new NullPointerException();        }        println(&quot;registerDriver: &quot; + driver);    }</code></pre><p>下面我们回到<code>Mybatis</code>中的<code>UnpooledDataSource</code>的分析，<code>UnpooledDataSource</code>中定义了如下静态代码块，在<code>UnpooledDataSource</code>加载时会通过静态代码块将已在<code>DriverManager</code>中注册的<code>JDBC Driver</code>复制一份到<code>UnpooledDataSource.registeredDriver</code>集合中。</p><pre><code class="java">/**   * 此静态代码块，在当前类加载时将已经在DriverManager中注册的JDBC Driver复制一份到{@link UnpooledDataSource#registeredDrivers}中。   */  static {    //获取到能加载到的所有的JDBC的驱动    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();    while (drivers.hasMoreElements()) {      Driver driver = drivers.nextElement();      //添加JDBC驱动      registeredDrivers.put(driver.getClass().getName(), driver);    }  }</code></pre><h3 id="3-1-2-getConnection"><a href="#3-1-2-getConnection" class="headerlink" title="3.1.2. getConnection()"></a>3.1.2. <code>getConnection()</code></h3><p><code>UnpooledDataSource.getConnection()</code>方法：</p><pre><code class="java"> /**   * 获取连接   * @return   * @throws SQLException   */  @Override  public Connection getConnection() throws SQLException {    return doGetConnection(username, password);  }  /**   * 获取连接   * @return   * @throws SQLException   */  @Override  public Connection getConnection(String username, String password) throws SQLException {    return doGetConnection(username, password);  }</code></pre><h3 id="3-1-2-doGetConnection"><a href="#3-1-2-doGetConnection" class="headerlink" title="3.1.2. doGetConnection()"></a>3.1.2. <code>doGetConnection()</code></h3><p><code>UnpooledDataSource.getConnection()</code>方法的所有重载最终会调用<code>UnpooledDataSource.doGetConnection()</code>方法获取数据库连接，具体实现如下：</p><pre><code class="java">  private Connection doGetConnection(String username, String password) throws SQLException {    Properties props = new Properties();    //添加驱动配置    if (driverProperties != null) {      props.putAll(driverProperties);    }    //添加连接用户名的key和value    if (username != null) {      props.setProperty(&quot;user&quot;, username);    }    //添加连接密码的key和value    if (password != null) {      props.setProperty(&quot;password&quot;, password);    }    //利用封装好的配置获取连接    return doGetConnection(props);  }</code></pre><pre><code class="java">  private Connection doGetConnection(Properties properties) throws SQLException {    //初始化数据库驱动    initializeDriver();    //创建真正的数据库连接    Connection connection = DriverManager.getConnection(url, properties);    //配置数据库连接的autoCommit和隔离级别    configureConnection(connection);    return connection;  }</code></pre><h3 id="3-1-3-initializeDriver"><a href="#3-1-3-initializeDriver" class="headerlink" title="3.1.3. initializeDriver()"></a>3.1.3. <code>initializeDriver()</code></h3><p><code>UnpooledDataSource.initializeDriver()</code>方法主要负责数据驱动的初始化，该方法会创建配置中指定的Driver对象，并将其注册到<code>DriverManger</code>以及上面介绍的<code>UnpooledDataSource.registerDriver</code>集合中保存。</p><pre><code class="java">/**   * 初始化数据库驱动   * @throws SQLException   */  private synchronized void initializeDriver() throws SQLException {    //判断驱动注册列表中是否包含我们要连接的数据库驱动，即检测驱动是否已注册    if (!registeredDrivers.containsKey(driver)) {      Class&lt;?&gt; driverType;      try {        //判断是否指定了驱动类的加载器，如果指定了初始化驱动后续操作使用指定的ClassLoader，然后返回不同的驱动类型（ClassLoader不同，就算是同一个java文件，生成的class类型也是不同的。）        if (driverClassLoader != null) {          driverType = Class.forName(driver, true, driverClassLoader);        } else {          //如果没有指定加载器，那么使用默认的驱动类型          driverType = Resources.classForName(driver);        }        // DriverManager requires the driver to be loaded via the system ClassLoader.        // http://www.kfu.com/~nsayer/Java/dyn-jdbc.html        //创建Driver对象        Driver driverInstance = (Driver)driverType.getDeclaredConstructor().newInstance();        //注册驱动，DriverProxy是UnpooledDataSource中的内部类，是Driver的静态代理类        DriverManager.registerDriver(new DriverProxy(driverInstance));        registeredDrivers.put(driver, driverInstance);      } catch (Exception e) {        throw new SQLException(&quot;Error setting driver on UnpooledDataSource. Cause: &quot; + e);      }    }  }</code></pre><h3 id="3-1-4-configureConnection"><a href="#3-1-4-configureConnection" class="headerlink" title="3.1.4. configureConnection()"></a>3.1.4. <code>configureConnection()</code></h3><p><code>UnpooledDataSource.configureConnection()</code>方法会完成数据连接的一系列配置，具体代码如下所示（<code>defaultNetworkTimeout</code>这个属性是<code>Mybatis3.5.2</code>版本加入的）：</p><pre><code class="java">  /**   * 完成数据库连接的一系列配置   * @param conn   * @throws SQLException   */  private void configureConnection(Connection conn) throws SQLException {    //设置网络超时时间，这是3.5.2之后添加的属性    if (defaultNetworkTimeout != null) {      conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout);    }    //设置事务是否自动提交    if (autoCommit != null &amp;&amp; autoCommit != conn.getAutoCommit()) {      conn.setAutoCommit(autoCommit);    }    //设置事务的隔离界别    if (defaultTransactionIsolationLevel != null) {      conn.setTransactionIsolation(defaultTransactionIsolationLevel);    }  }</code></pre><h2 id="3-2-PooledDataSource"><a href="#3-2-PooledDataSource" class="headerlink" title="3.2. PooledDataSource"></a>3.2. PooledDataSource</h2><p>数据库连接的创建时一个非常耗时的，数据库能够建立的连接数也非常有限，所以在绝大多数系统中，数据库连接是非常珍贵的资源，使用数据库连接池就显得尤为必要了。使用数据库连接池会带来很多的好处，例如，可以实现数据库连接的重用、提高响应速度、防止数据库连接过多造成数据库假死、避免数据库连接泄露等。</p><p>数据库连接池在初始化是，一般会创建一定数量的数据库连接并添加到连接池中备用。当程序需要使用数据库连接时，从池中请求连接；当程序不再使用该连接时，会将其返回到池中缓存，等待下次使用，而不是直接关闭。当然，数据库连接线会控制连接总数的上限以及空闲连接数的上限，如果连接池创建的总连接数已达到上限，且都已被占用，则后续请求连接的线程会进入阻塞队列等待，知道有线程释放出可用连接。如果连接池中空闲连接数较多，达到其上限，则后续返回的空闲连接不会放入池中，而是直接关闭，这样可以减少系统维护多余数据库连接的开销。</p><p>如果将总连接数的上线设置得过大，可能会因为连接数过多而导致数据库僵死，系统整体性能下降；如果总连接数上线过小，则无法完全发挥数据库的性能，浪费数据库资源。如果将空闲连接的上线设置得过大，则会浪费系统资源来维护这些空闲连接；如果空闲连接上线过小，当出现瞬间的峰值请求时，系统的快速响应能力就比较弱。<strong>所以在设置数据库连接池的这两个值时，需要进行性能测试、权衡以及一些经验。</strong></p><p><code>PooledDataSource</code>实现了简易数据库连接池的功能，它依赖的组件如下图所指示，其中需要注意的是，<code>PooledDataSource</code>创建新数据库连接的功能是依赖其中封装的<code>UnpooledDataSource</code>对象实现的。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191130164424-ZdSnNd.png!github_blog" srcset="undefined" style="zoom:67%;" /><p>在研究<code>PooledDataSource</code>的时候从一个简单的例子出发，不然不知道怎么研究<code>PooledDataSource</code>、<code>PooledConnection</code>、<code>PoolState</code>、<code>UnpooledDataSource</code>、<code>DataSource</code>五者之间的调用关系：</p><pre><code class="java">package red.reksai.datasource;import org.apache.ibatis.datasource.pooled.PooledDataSourceFactory;import org.apache.ibatis.io.Resources;import org.junit.jupiter.api.Test;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Properties;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/12/1 01:15 */public class PooledDataSourceFactoryTest {  @Test  public void test1() throws IOException, SQLException {    String resources = &quot;resources/config.properties&quot;;    InputStream inputStream = Resources.getResourceAsStream(resources);    Properties properties = new Properties();    properties.load(inputStream);    PooledDataSourceFactory pooledDataSourceFactory = new PooledDataSourceFactory();    pooledDataSourceFactory.setProperties(properties);    Connection connection = pooledDataSourceFactory.getDataSource().getConnection();    PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from blog where blog_id = 1&quot;);    ResultSet resultSet = preparedStatement.executeQuery();    while (resultSet.next()){      System.out.println(resultSet.getString(1));    }  }}</code></pre><p>有上述代码可以发现程序执行的第一步是：<code>new PooledDataSourceFactory()</code>，而在<code>PooledDataSourceFactory</code>构造中<code>new</code> 了一个<code>PooledDataSource</code>，所以我们需要先解析<code>PooledDataSource</code>。</p><p><code>PooledDataSource</code>中的核心字段如下所示：</p><pre><code class="java">/**   * 通过PoolState管理连接池的转台并记录统计信息   */  private final PoolState state = new PoolState(this);  /**   * 创建一个PooledDataSource需要一个UnpooledDataSource   */  private final UnpooledDataSource dataSource;  // OPTIONAL CONFIGURATION FIELDS  // 可选配置字段  /**   * 最大活跃连接数   */  protected int poolMaximumActiveConnections = 10;  /**   * 最大空闲连接数   */  protected int poolMaximumIdleConnections = 5;  /**   * 最大CheckoutTime时间（最大连接时间）   */  protected int poolMaximumCheckoutTime = 20000;  /**   * 在无法获取连接时，线程需要等待的时间   */  protected int poolTimeToWait = 20000;  protected int poolMaximumLocalBadConnectionTolerance = 3;  /**   * 在检测一个数据库连接是否可用时，会给数据库发送一个测试SQL语句   */  protected String poolPingQuery = &quot;NO PING QUERY SET&quot;;  /**   * 是否允许发送测试SQL   */  protected boolean poolPingEnabled;  /**   * 当poolPingConnectionsNotUsedFor毫秒未使用时，会发送一次测试SQL语句，检测连接是否正常   */  protected int poolPingConnectionsNotUsedFor;  /**   * 该hash用于标志着当前的连接池，在构造函数中初始化   *    生成规则：{@link PooledDataSource#assembleConnectionTypeCode(String, String, String)}   */  private int expectedConnectionTypeCode;</code></pre><p><code>PooledDataSource</code>中还提供了上述字段的<code>getter</code>和<code>setter</code>方法，代码比较简单。其中有个与众不同的属性赋值<code>private final PoolState state = new PoolState(this);</code>，这使得我先去研究<code>PoolState</code>了，一会回来。</p><hr><p><code>PoolState</code>是用于管理<code>PooledConnection</code>对象状态的组件。为什么这么说呢？看看它定义的字段：</p><pre><code class="java"> protected PooledDataSource dataSource;  /**   * 空闲的PooledConnection集合   */  protected final List&lt;PooledConnection&gt; idleConnections = new ArrayList&lt;&gt;();  /**   * 活跃的PooledConnection集合   */  protected final List&lt;PooledConnection&gt; activeConnections = new ArrayList&lt;&gt;();  /**   * 请求数据库连接的次数   */  protected long requestCount = 0;  /**   * 获取连接的累计时长   */  protected long accumulatedRequestTime = 0;  /**   * CheckoutTime表示应用从连接池中取出连接，到归还连接这端时长   * accumulatedCheckoutTime记录的是所有连接累计的CheckoutTime时长   */  protected long accumulatedCheckoutTime = 0;  /**   * 当连接长时间未被归还给连接池时，会被认为该连接超时   * claimedOverdueConnectionCount 记录的是超时的连接个数   */  protected long claimedOverdueConnectionCount = 0;  /**   * 累计超时时间   */  protected long accumulatedCheckoutTimeOfOverdueConnections = 0;  /**   * 累计等待时间   */  protected long accumulatedWaitTime = 0;  /**   * 等待次数   */  protected long hadToWaitCount = 0;  /**   * 无效连接数   */  protected long badConnectionCount = 0;</code></pre><p>由以上字段可以看出，<code>PoolState</code>是通过两个<code>Arraylist&lt;PooledConnection&gt;</code>分别管理空闲状态的连接和活跃状态的连接的，当然了<code>PoolState</code>中还定义了一系列用于统计的字段。</p><hr><p>简单介绍完以上，我们再回到<code>PooledDataSource</code>，分析其构造方法，如下所示：</p><pre><code class="java">public PooledDataSource() {    dataSource = new UnpooledDataSource();  }  public PooledDataSource(UnpooledDataSource dataSource) {    this.dataSource = dataSource;  }  public PooledDataSource(String driver, String url, String username, String password) {    dataSource = new UnpooledDataSource(driver, url, username, password);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }  public PooledDataSource(String driver, String url, Properties driverProperties) {    dataSource = new UnpooledDataSource(driver, url, driverProperties);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }  public PooledDataSource(ClassLoader driverClassLoader, String driver, String url, String username, String password) {    dataSource = new UnpooledDataSource(driverClassLoader, driver, url, username, password);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }  public PooledDataSource(ClassLoader driverClassLoader, String driver, String url, Properties driverProperties) {    dataSource = new UnpooledDataSource(driverClassLoader, driver, url, driverProperties);    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());  }</code></pre><p>有<code>PooledDataSource</code>的构造方法可知，<code>PooledDataSource</code>的创建需要一个<code>UnPooledDataSource</code>对象。</p><p>拿到<code>DataSource</code>对象之后，就要通过<code>DataSource.getConnection()</code>去获取数据库连接对象，在<code>PooledDataSource</code>中的<code>getConnection()</code>代码如下所示：</p><pre><code class="java">  /**   * 获取连接：   *    首先通过{@link PooledDataSource#popConnection(String, String)}获取{@link PooledConnection}，   *    因为PooledConnection只实现了{@link InvocationHandler} 接口，并未实现java.sql.Connection，故而这个PooledConnection不能使用，   *    需要使用{@link PooledConnection#getProxyConnection()}获取一个JDK动态代理生成的实现了java.sql.Connection的代理对象。   * @return   * @throws SQLException   */  @Override  public Connection getConnection() throws SQLException {    return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();  }  /**   * 获取连接   * @return   * @throws SQLException   */  @Override  public Connection getConnection(String username, String password) throws SQLException {    return popConnection(username, password).getProxyConnection();  }</code></pre><p>由以上代码可以看出，不管调用的是哪个<code>PooledDataSource.getConnection()</code>方法的重载，最终都调用到了两个方法：</p><ol><li>通过<code>PooledDataSource.popConnection()</code>获取一个<code>PooledConnection</code>，因为<code>PooledConnection</code>只实现了<code>InvocationHandler</code>接口，并未实现<code>java.sql.Connection</code>，故而这个<code>PooledConnection</code>是不能操作数据库的，需要通过它获取一个<code>java.sql.Connection</code>的代理对象，也就有了第二部的操作；</li><li>使用<code>PooledConnection.getProxyConnection()</code>，获取一个<code>JDK</code>动态代理生成的实现了<code>java.sql.Connection</code>的代理对象。（这一步很简单就是一个<code>get</code>值的过程，不去研究。）</li></ol><p>所以我们接下来先分析<code>PooledDataSource.popConnection()</code>方法，此方法具体代码如下所示：</p><pre><code class="java">/**   * pop连接   * @param username   * @param password   * @return   PooledConnection的代理对象   * @throws SQLException   */  private PooledConnection popConnection(String username, String password) throws SQLException {    //等待，默认是不等待    boolean countedWait = false;    PooledConnection conn = null;    //创建或判断连接之前系统时间    long t = System.currentTimeMillis();    //本地错误连接数    int localBadConnectionCount = 0;    //1. 当连接为null的时候，去执行循环    while (conn == null) {      synchronized (state) {        //2. 判断有没有空闲连接        if (!state.idleConnections.isEmpty()) {          // Pool has available connection          //有空闲连接，就获取连接，然后把当前连接从空闲连接中移除          conn = state.idleConnections.remove(0);          if (log.isDebugEnabled()) {            log.debug(&quot;Checked out connection &quot; + conn.getRealHashCode() + &quot; from pool.&quot;);          }        } else {          // Pool does not have available connection          //如果没有空闲连接          //首先判断活跃连接是不是小于最大活跃数，如果小于可以创建新连接          if (state.activeConnections.size() &lt; poolMaximumActiveConnections) {            // Can create new connection            // 创建一个新连接（这是一个代理对象）            conn = new PooledConnection(dataSource.getConnection(), this);            if (log.isDebugEnabled()) {              log.debug(&quot;Created connection &quot; + conn.getRealHashCode() + &quot;.&quot;);            }          } else {            // Cannot create new connection            // 如果判断活跃连接数等于最大活跃数，获取最老的活跃连接            PooledConnection oldestActiveConnection = state.activeConnections.get(0);            // 获取此连接的连接时长（当前时间—取出连接的时间）            long longestCheckoutTime = oldestActiveConnection.getCheckoutTime();            // 然后判断是否超时（此连接的连接时间  和 运行连接的时间  比较）            if (longestCheckoutTime &gt; poolMaximumCheckoutTime) {              // 当前连接超时              // Can claim overdue connection              //对超时连接进行统计              //超时连接数+1              state.claimedOverdueConnectionCount++;              //总累计超时时间 = 原有总累计超时时间+当前连接时间（因为当前连接已经超时）              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;              //总累计连接时间 = 原有总累计连接时间+ 当前连接时间              state.accumulatedCheckoutTime += longestCheckoutTime;              //从活跃连接中移除最老的这个超时连接              state.activeConnections.remove(oldestActiveConnection);              //获取真正的数据库连接，判断数据库提交模式（自动提交事务还是手动）              if (!oldestActiveConnection.getRealConnection().getAutoCommit()) {                try {                  //如果是不自动提交事务的情况，那么就要回滚本次操作                  oldestActiveConnection.getRealConnection().rollback();                } catch (SQLException e) {                  /*                     Just log a message for debug and continue to execute the following                     statement like nothing happened.                     Wrap the bad connection with a new PooledConnection, this will help                     to not interrupt current executing thread and give current thread a                     chance to join the next competition for another valid/good database                     connection. At the end of this loop, bad {@link @conn} will be set as null.                   */                  log.debug(&quot;Bad connection. Could not roll back&quot;);                }              }              //重新创建连接              conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this);              //设置该连接创建的时间戳              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());              //设置该连接的最后使用时间              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());              //然后作废之前的最老的超时连接，因为此前只是从集合中移除，并不表示它不能使用，而这一步就是确保这种情况不会出现。              oldestActiveConnection.invalidate();              if (log.isDebugEnabled()) {                log.debug(&quot;Claimed overdue connection &quot; + conn.getRealHashCode() + &quot;.&quot;);              }            } else {              // 没有空闲连接、活跃的连接数又等于限定的最大连接数（即：无法创建连接）而且无超时连接、则只能阻塞等待              // Must wait              try {                //如果此前没有等待的                if (!countedWait) {                  //先将等待数+1                  state.hadToWaitCount++;                  //然后将状态设置为等待状态                  countedWait = true;                }                if (log.isDebugEnabled()) {                  log.debug(&quot;Waiting as long as &quot; + poolTimeToWait + &quot; milliseconds for connection.&quot;);                }                //获取当前系统时间                long wt = System.currentTimeMillis();                //获取需要等待的时间，利用Object.wait(需要等待的时间)，让当前线程进行等待                state.wait(poolTimeToWait);                //更新累计等待时间：累计等待时间=当得系统时间+当前时间-等待直接记录的系统时间                state.accumulatedWaitTime += System.currentTimeMillis() - wt;              } catch (InterruptedException e) {                break;              }            }          }        }        // 再次判断连接是否为空        // 如果不为空        if (conn != null) {          // ping to server and check the connection is valid or not          //判断连接是否有效          if (conn.isValid()) {            //如果当前连接不是自动提交事务，那就回滚之前操作            if (!conn.getRealConnection().getAutoCommit()) {              conn.getRealConnection().rollback();            }            //然后重现设置用于标识该连接所在的连接池的标识码            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));            //设置连接时长            conn.setCheckoutTimestamp(System.currentTimeMillis());            //设置最后修改时间            conn.setLastUsedTimestamp(System.currentTimeMillis());            //把当前连接添加到活跃连接集合中            state.activeConnections.add(conn);            //然后把连接次数+1            state.requestCount++;            //累计请求连接时间            state.accumulatedRequestTime += System.currentTimeMillis() - t;          } else {            //如果当前连接不为空，但是是失效的，那么表明此连接是一个坏连接（无效连接）            if (log.isDebugEnabled()) {              log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) was returned from the pool, getting another connection.&quot;);            }            //无效连接数+1            state.badConnectionCount++;            //本地错误连接数+1            localBadConnectionCount++;            //设置连接为空            conn = null;            if (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) {              if (log.isDebugEnabled()) {                log.debug(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);              }              throw new SQLException(&quot;PooledDataSource: Could not get a good connection to the database.&quot;);            }          }        }      }    }    //此时连接为空，表明发生了未知错误    if (conn == null) {      if (log.isDebugEnabled()) {        log.debug(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);      }      throw new SQLException(&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;);    }    //最后返回连接    return conn;  }</code></pre><p>以上代码的逻辑流程如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191201140942-l8rFwF.png!github_blog" srcset="undefined" alt=""></p><p>有以上流程，我们发现在在活跃数没有大于最大限定的时候创建了一个新的<code>PooledConnection</code>，这里调用了<code>PooledConnection</code>的构造方法，代码如下所示：</p><pre><code class="java"> public PooledConnection(Connection connection, PooledDataSource dataSource) {    this.hashCode = connection.hashCode();    this.realConnection = connection;    this.dataSource = dataSource;    this.createdTimestamp = System.currentTimeMillis();    this.lastUsedTimestamp = System.currentTimeMillis();    this.valid = true;    /**     * 这里的this 为 {@link PooledConnection#invoke(Object, Method, Object[])}     */    this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);  }</code></pre><p>这里就初始化了一个<code>java.sql.Connection</code>的代理对象（<code>this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this);</code>），后续进行的操作就是通过这个代理对象完成的，因为代理对象的执行最终要执行到<code>InvocartionHandler</code>的实现的<code>invoke()</code>方法，而<code>PooledConnection</code>就实现了<code>InvocationHandler</code>方法，故我们执行的<code>java.sql.Connection</code>中的方法最终执行的都是<code>PooledConnection</code>中的<code>invoke()</code>方法，<code>PooledConnection.invoke()</code>方法代码如下所示：</p><pre><code class="java">/**   * Required for InvocationHandler implementation.   *   * @param proxy  - not used   * @param method - the method to be executed   * @param args   - the parameters to be passed to the method   * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])   */  @Override  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {    String methodName = method.getName();    //如果调用的是close()方法，则重现将连接放回到连接池，而不是真正的关闭数据库连接    if (CLOSE.equals(methodName)) {      dataSource.pushConnection(this);      return null;    }    try {      if (!Object.class.equals(method.getDeclaringClass())) {        // issue #579 toString() should never fail        // throw an SQLException instead of a Runtime        //通过valid字段检测数据库连接是否有效        checkConnection();      }      //调用真正数据库连接对象的对应方法      return method.invoke(realConnection, args);    } catch (Throwable t) {      throw ExceptionUtil.unwrapThrowable(t);    }  }</code></pre><p>以上代码中重要的方法是<code>PooledDataSource.pushConnection()</code>，<code>PooledDataSource.pushConnection()</code>的代码如下所示：</p><pre><code class="java"> /**   * 放回连接   * @param conn   * @throws SQLException   */  protected void pushConnection(PooledConnection conn) throws SQLException {    synchronized (state) {      //从活跃连接集合中移除此连接      state.activeConnections.remove(conn);      //判断此连接是否有效      if (conn.isValid()) {        //判断空闲连接数是否小于最大空闲连接数  （即：判断空闲连接数是否达到上限） 以及此连接是否是该连接池的连接        if (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) {          //空闲连接数没有达到上限          //累计checkOut时长          state.accumulatedCheckoutTime += conn.getCheckoutTime();          //回滚未提交的事务          if (!conn.getRealConnection().getAutoCommit()) {            conn.getRealConnection().rollback();          }          //为返还连接创造新的PooledConnection对象          PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this);          //然后将新对象添加到活跃集合          state.idleConnections.add(newConn);          //设置新连接创建时间戳          newConn.setCreatedTimestamp(conn.getCreatedTimestamp());          //设置新连接最后使用时间戳          newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());          //将老连接对象设置为无效          conn.invalidate();          if (log.isDebugEnabled()) {            log.debug(&quot;Returned connection &quot; + newConn.getRealHashCode() + &quot; to pool.&quot;);          }          //唤醒等待的线程          state.notifyAll();        } else {          //空闲连接数已达到上限   或   PooledConnection对象不属于该连接池          //累计checkOur时长          state.accumulatedCheckoutTime += conn.getCheckoutTime();          //回滚未提交的操作          if (!conn.getRealConnection().getAutoCommit()) {            conn.getRealConnection().rollback();          }          //因为这个PooledConnection对象不属于该连接池，所以直接关闭，而不是放回连接池          conn.getRealConnection().close();          if (log.isDebugEnabled()) {            log.debug(&quot;Closed connection &quot; + conn.getRealHashCode() + &quot;.&quot;);          }          //最后再将对象设置为无效          conn.invalidate();        }      } else {        //如果此连接是无效连接，抛出异常，并且记录先关统计数据        if (log.isDebugEnabled()) {          log.debug(&quot;A bad connection (&quot; + conn.getRealHashCode() + &quot;) attempted to return to the pool, discarding connection.&quot;);        }        //统计无效的PooledConnection对象        state.badConnectionCount++;      }    }  }</code></pre><p>以上代码的逻辑流程如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191201152437-0IpAsL.png!github_blog" srcset="undefined" alt=""></p><hr><p>需要注意的是，<code>PooledDataSouece.pushConnection()</code>方法和<code>PooledDataSouece.popConnection()</code>方法中都调用了<code>PooledDataSource.isValid()</code>方法来检测<code>PooledConnection</code>的有效性，该方法除了检测<code>PooledDataSource.valid</code>字段的值，还会调用<code>PooledDataSource.pingConnection()</code>方法尝试让数据库执行<code>poolPingQuery</code>字段中记录的测试<code>SQL</code>语句，从而检测真正的数据库连接对象是否依然可以正常使用。<code>isValid()</code>方法以及<code>pingConnection()</code>方法的代码如下所示：</p><pre><code class="java">  /**   * 检测PooledConnection的有效性   * Method to see if the connection is usable.   *   * @return True if the connection is usable   */  public boolean isValid() {    //除了检测valid字段外，还要使用PooledDataSource.pingConnection()方法，向数据库发出测试语句来进一步判断    return valid &amp;&amp; realConnection != null &amp;&amp; dataSource.pingConnection(this);  }</code></pre><pre><code class="java">/**   * 用于测试连接   * Method to check to see if a connection is still usable   *   * @param conn - the connection to check   * @return True if the connection is still usable   */  protected boolean pingConnection(PooledConnection conn) {    boolean result = true;    try {      //检测真正的连接是否已关闭      result = !conn.getRealConnection().isClosed();    } catch (SQLException e) {      if (log.isDebugEnabled()) {        log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());      }      result = false;    }    if (result) {      //判断要不要发不出测试语句      if (poolPingEnabled) {        //要        //        if (poolPingConnectionsNotUsedFor &gt;= 0 &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) {          try {            if (log.isDebugEnabled()) {              log.debug(&quot;Testing connection &quot; + conn.getRealHashCode() + &quot; ...&quot;);            }            Connection realConn = conn.getRealConnection();            try (Statement statement = realConn.createStatement()) {              statement.executeQuery(poolPingQuery).close();            }            if (!realConn.getAutoCommit()) {              realConn.rollback();            }            result = true;            if (log.isDebugEnabled()) {              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is GOOD!&quot;);            }          } catch (Exception e) {            log.warn(&quot;Execution of ping query &#39;&quot; + poolPingQuery + &quot;&#39; failed: &quot; + e.getMessage());            try {              conn.getRealConnection().close();            } catch (Exception e2) {              //ignore            }            result = false;            if (log.isDebugEnabled()) {              log.debug(&quot;Connection &quot; + conn.getRealHashCode() + &quot; is BAD: &quot; + e.getMessage());            }          }        }      }    }    return result;  }</code></pre><p>最后需要注意的是<code>PooledDataSource.forceCloseAll()</code>，当修改<code>PooledDataSource</code>的字段是，例如数据库的<code>URL</code>、<code>用户名</code>、<code>密码</code>、<code>autoCommit</code>配置等，都会调用<code>PooledDataSource.forceCloseAll()</code>方法将所有的数据库连接都关掉，同时也会将相应的<code>PooledConnection</code>对象都设置为无效，清空<code>activeConnections</code>集合和<code>idleConnections</code>集合。应用系统之后通过<code>PoolDataSource.getConnection()</code>获取连接时，会按照新的配置重新创建新的数据库连接以及对应的<code>PooledConnection</code>对象。<code>forceCloseAll()</code>方法的具体实现如下所示：</p><pre><code class="java">/**   * `PooledDataSource.forceCloseAll()`，当修改`PooledDataSource`的字段是，例如数据库的`URL`、`用户名`、`密码`、`autoCommit`配置等，   * 都会调用`PooledDataSource.forceCloseAll()`方法将所有的数据库连接都关掉，同时也会将相应的`PooledConnection`对象都设置为无效，   * 清空`activeConnections`集合和`idleConnections`集合。应用系统之后通过`PoolDataSource.getConnection()`获取连接时，   * 会按照新的配置重新创建新的数据库连接以及对应的`PooledConnection`对象.   * Closes all active and idle connections in the pool.   */  public void forceCloseAll() {    synchronized (state) {      expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());      for (int i = state.activeConnections.size(); i &gt; 0; i--) {        try {          PooledConnection conn = state.activeConnections.remove(i - 1);          conn.invalidate();          Connection realConn = conn.getRealConnection();          if (!realConn.getAutoCommit()) {            realConn.rollback();          }          realConn.close();        } catch (Exception e) {          // ignore        }      }      for (int i = state.idleConnections.size(); i &gt; 0; i--) {        try {          PooledConnection conn = state.idleConnections.remove(i - 1);          conn.invalidate();          Connection realConn = conn.getRealConnection();          if (!realConn.getAutoCommit()) {            realConn.rollback();          }          realConn.close();        } catch (Exception e) {          // ignore        }      }    }    if (log.isDebugEnabled()) {      log.debug(&quot;PooledDataSource forcefully closed/removed all connections.&quot;);    }  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
      <tag>工厂方法模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资源加载</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD.html</url>
    
    <content type="html"><![CDATA[<h1 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis初始化(二)——3.解析&lt;sql&gt;节点</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E8%A7%A3%E6%9E%90%3Csql%3E%E8%8A%82%E7%82%B9.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E8%A7%A3%E6%9E%90%3Csql%3E%E8%8A%82%E7%82%B9.html</url>
    
    <content type="html"><![CDATA[<h1 id="解析-lt-sql-gt-节点"><a href="#解析-lt-sql-gt-节点" class="headerlink" title="解析&lt;sql&gt;节点"></a>解析<code>&lt;sql&gt;</code>节点</h1><p>在映射配置文件中，可以使用<code>&lt;sql&gt;</code>节点定义可重用的~语句片段。当需要重用<code>&lt;sql&gt;</code>节点中定义的<code>SQL</code>语句片段时，只需要使用include节点引用相应的片段即可，这样，在编写<code>SQL</code>语句以及维护这些<code>SQL</code>语句时，都会比较方便。<code>&lt;include&gt;</code>节点的解析在后面详细介绍。</p><p><code>XMLMapperBuilder.sqlElement()</code>方法负责解析映射配置文件中定义的的全部<code>&lt;sql&gt;</code>节点，具体代码如下所示：</p><pre><code class="java">  private void sqlElement(List&lt;XNode&gt; list, String requiredDatabaseId) {    //遍历所有的&lt;sql&gt;节点    for (XNode context : list) {      //解析&lt;sql&gt;节点      //获取&lt;sql&gt;节点的databaseId属性的值      String databaseId = context.getStringAttribute(&quot;databaseId&quot;);      //获取&lt;sql&gt;节点的id属性的值      String id = context.getStringAttribute(&quot;id&quot;);      //获取在当前命名空间的对应的全路径id      id = builderAssistant.applyCurrentNamespace(id, false);      //进行数据库ID匹配，如果当前sql片段所属的databaseId和configuration.databaseId相等      if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) {        //将匹配的sql片段，放入Configuration.sqlFragments集合中        sqlFragments.put(id, context);      }    }  }</code></pre><p>这个章节比较简单，所以这里讲一下<code>Configuration.StricMap</code>类：</p><p>这个类在存储解析<code>Mapper</code>映射配置文件中之后的对象中，起到了至关重要的作用，具体体现如下所示：</p><pre><code class="java"> /**   * key = Cache的ID （默认是映射文件的namespace）   * value = Cache对象（二级缓存）   */  protected final Map&lt;String, Cache&gt; caches = new StrictMap&lt;&gt;(&quot;Caches collection&quot;);  /**   * 用于存储ResultMap   */  protected final Map&lt;String, ResultMap&gt; resultMaps = new StrictMap&lt;&gt;(&quot;Result Maps collection&quot;);  protected final Map&lt;String, ParameterMap&gt; parameterMaps = new StrictMap&lt;&gt;(&quot;Parameter Maps collection&quot;); /**   * 用于存储KeyGenerator   */  protected final Map&lt;String, KeyGenerator&gt; keyGenerators = new StrictMap&lt;&gt;(&quot;Key Generators collection&quot;); /**   * 用于存储sql片段   */  protected final Map&lt;String, XNode&gt; sqlFragments = new StrictMap&lt;&gt;(&quot;XML fragments parsed from previous mappers&quot;);</code></pre><p>为什么要使用<code>StricMap</code>完成以上信息的存储，那取决于<code>StricMap</code>的<code>put()</code>方法的一些特性，具体如下所示：</p><pre><code class="java"> public V put(String key, V value) {      //如果检测到重复的key直接抛出异常      if (containsKey(key)) {        throw new IllegalArgumentException(name + &quot; already contains value for &quot; + key            + (conflictMessageProducer == null ? &quot;&quot; : conflictMessageProducer.apply(super.get(key), value)));      }      //如果没有重复的key则添加key以及value      //同时根据key产生shortKey      if (key.contains(&quot;.&quot;)) {        //按照“.”将key切分成数组，然后将数组的最后一项作为shortKey        final String shortKey = getShortName(key);        //如果不包含指定shortKey,则添加该键值对        if (super.get(shortKey) == null) {          super.put(shortKey, value);        } else {          //如果该shortKey已经存在，则将value修改成Ambiguity对象          super.put(shortKey, (V) new Ambiguity(shortKey));        }      }      //如果没有重复的key则添加key以及value（这是全面）      return super.put(key, value);    }</code></pre><p>在调用<code>StricMap.put()</code>方法的时候，首先要检查<code>key</code>是否存在，如果存在会直接报错。</p><p>那么为什么在检查<code>key</code>存在之后就直接报错呢？原因如下所示：</p><ol><li><p>传入的<code>key</code>等于调用<code>builderAssistant.applyCurrentNamespace(id, false)</code>返回的值，在调用<code>builderAssistant.applyCurrentNamespace()</code>方法参入的<code>id</code>是节点的<code>id</code>，例如：<code>whereSqlElement</code>就是传入的<code>id</code>值。</p><pre><code class="xml">&lt;sql id=&quot;whereSqlElement&quot;&gt;    where blog_id = ${idValue}  &lt;/sql&gt;</code></pre><p>因为同一个<code>Mapper.xml</code>中，不用有<code>id</code>相同的标签，如上代码块，而万一<code>Mapper</code>配置文件中真的有两段一样的代码，就应该提前报错告诉开发人员去更改，所以<code>StricMap.put()</code>中的首先检测<code>key</code>是否存在，不存在就直接报错。</p></li><li><p><code>StricMap.put()</code>会向集合中加入两条数据，一条是全名<code>key</code>，一条是<code>shorKey</code>名。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis初始化(二)——2.解析&lt;resultMap&gt;节点</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E8%A7%A3%E6%9E%90%3CresultMap%3E%E8%8A%82%E7%82%B9.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E8%A7%A3%E6%9E%90%3CresultMap%3E%E8%8A%82%E7%82%B9.html</url>
    
    <content type="html"><![CDATA[<h1 id="解析-lt-resultMap-gt-节点"><a href="#解析-lt-resultMap-gt-节点" class="headerlink" title="解析&lt;resultMap&gt;节点"></a>解析<code>&lt;resultMap&gt;</code>节点</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><code>select</code>语句查询得到的结果集是一张二维表，水平方向上看是一个个字段，垂直方向上看是一条条数据。而<code>Java</code>是面向对象的程序设计语言，对象是根据类定义创建的，类之间的引用关系是可以认为是嵌套结构的。在<code>JDBC</code>编程中，为了将结果集中的数据映射成对象，我们需要自己写代码从结果集中获取数据，然后封装成对应的对象并设置对象之间的关系，而这些都是大量的重复性的代码。为了减少这些重复的代码，<code>Mybatis</code>使用<code>&lt;resultMap&gt;</code>节点定义了结果集与结果对象（<code>JavaBean</code>对象）之间的映射规则，<code>&lt;resultMap&gt;</code>节点可以满足绝大部分的映射需求，从未减少开发人员的重复性劳动，提高开发效率。</p><p>在开始介绍<code>&lt;resultMap&gt;</code>节点的解析过程之前，先来介绍该过程中使用的数据结构。每个<code>ResultMapping</code>对象记录了结果集中的一列与<code>JavaBean</code>中一个属性之间的映射关系。在后面的分析过程中我们可以看到，<code>&lt;resultMap&gt;</code>节点下除了<code>&lt;discriminator&gt;</code>子节点的其他子节点，都被解析成对应的<code>ResultMapping</code>对象。<code>ResultMapping</code>对象的核心字段如下所示：</p><pre><code class="java">/**   * Configuration对象   */  private Configuration configuration;  /**   * 对应节点的property属性，表示的是与该列映射的属性   */  private String property;  /**   * 对应节点的column属性，表示的是从数据库中得到的列名或列名的别名   */  private String column;  /**   * 对应节点的javaType属性，表示的是一个JavaBean的完全限定名，或一个类型的别名   */  private Class&lt;?&gt; javaType;  /**   * 对应节点的jdbcType属性，表示的是进行映射的列的JDBC类型   */  private JdbcType jdbcType;  /**   * 对应节点的typeHandler属性， 表示的是类型处理器，它会覆盖默认的类型处理器，   */  private TypeHandler&lt;?&gt; typeHandler;  /**   * 对应节点的resultMap属性，该属性通过id引用另一个&lt;resultMap&gt;节点定义，它负责将结果集中的一部分分列映射成其他关联的结果对象。   * 这样我们就可以通过join方式进行关联查询，然后直接映射多个对象，并同时设置这些对象之间的关系。   */  private String nestedResultMapId;  /**   * 对应节点的select属性，该属性通过id引用了另一个&lt;select&gt;节点定义，它会把指定的列的值传入select属性指定的select语句中作为参数进行查询。   * 使用select属性可能会造成N+1问题。   */  private String nestedQueryId;  /**   * 对应节点的notNullColumns属性拆分后的结果   */  private Set&lt;String&gt; notNullColumns;  /**   * 对应节点的columnPrefix属性   */  private String columnPrefix;  /**   * 处理后的标志，标志有两个：id和constructor   */  private List&lt;ResultFlag&gt; flags;  /**   * 对应节点的column属性拆分后生成的结果，composites.size()&gt;0会是column为null   */  private List&lt;ResultMapping&gt; composites;  /**   * 对应节点的resultSet属性   */  private String resultSet;  /**   * 对应节点的foreignColumn属性   */  private String foreignColumn;  /**   * 对应节点的lazy属性，是否延迟加载   */  private boolean lazy;</code></pre><p><code>ResultMapping</code>中定义了一个内部的<code>Builer</code>类，也应用了建造者模式，该<code>builder</code>类主要用于数据整理和数据校验，实现比较简单。</p><p>另一个主要的类是<code>ResultMap</code>,每个<code>&lt;resultMap&gt;</code>节点都会被解析成一个<code>ResultMap</code>对象，其中每个节点所定义的映射关系，则使用<code>ResultMapping</code>对象表示。</p><p><code>ResultMap</code>中各个字段的含义如下：</p><pre><code class="java">/**   * Configuration对象   */  private Configuration configuration;  /**   * &lt;resultMap&gt;的id属性   */  private String id;  /**   * &lt;resultMap&gt;的type属性   */  private Class&lt;?&gt; type;  /**   * 记录了除&lt;discriminator&gt;节点之外的其他映射关系（即：ResultMapping对象集合）   */  private List&lt;ResultMapping&gt; resultMappings;  /**   * 记录了映射关系中带ID标志的映射关系，例如:&lt;id&gt;节点和&lt;constructor&gt;节点的&lt;idArg&gt;节点   */  private List&lt;ResultMapping&gt; idResultMappings;  /**   * 记录映射关系中带constructor标志的映射关系，例如:&lt;constructor&gt;所有子元素   */  private List&lt;ResultMapping&gt; constructorResultMappings;  /**   * 记录映射关系中不带constructor标志的映射关系   */  private List&lt;ResultMapping&gt; propertyResultMappings;  /**   * 记录映射关系中所有的column属性   */  private Set&lt;String&gt; mappedColumns;  /**   * 记录映射关系中所有的property属性   */  private Set&lt;String&gt; mappedProperties;  /**   * 鉴别器，对应&lt;discriminator&gt;节点   */  private Discriminator discriminator;  /**   * 是否有嵌套的结果集映射，如果某个映射关系中存在resultMap属性，且不存在resultSet属性，则为true   */  private boolean hasNestedResultMaps;  /**   * 是否含有嵌套查询，如果某个属性映射存在select属性，则为true   */  private boolean hasNestedQueries;  /**   * 是否开启自动映射   */  private Boolean autoMapping;</code></pre><h1 id="2-resultMap节点结构"><a href="#2-resultMap节点结构" class="headerlink" title="2. resultMap节点结构"></a>2. <code>resultMap</code>节点结构</h1><h2 id="2-1-resultMap下的子节点"><a href="#2-1-resultMap下的子节点" class="headerlink" title="2.1. resultMap下的子节点"></a>2.1. <code>resultMap</code>下的子节点</h2><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019-12-10-FwRfj6.png!github_blog" srcset="undefined" style="zoom:33%;" /><h2 id="2-2-resultMap节点属性表"><a href="#2-2-resultMap节点属性表" class="headerlink" title="2.2. resultMap节点属性表"></a>2.2. <code>resultMap</code>节点属性表</h2><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019-12-10-09yPHj.png!github_blog" srcset="undefined" alt=""></p><p>由图一可知：<code>&lt;resultMap&gt;</code>下的节点不只一层，而是可以无限嵌套；</p><p>由图二可知：<code>association</code>、<code>collection</code>、<code>constructor</code>下的<code>isArg</code>和<code>arg</code>、<code>discriminiator</code>下的<code>case</code>都可以定义属性<code>resultMap</code>；</p><p>结合<code>ResulMap</code>和<code>ResultMapping</code>类知道了在解析<code>resultMap</code>节点的时候势必要解析嵌套的<code>resultMappings</code>。</p><h1 id="3-解析resultMap节点涉及到的方法"><a href="#3-解析resultMap节点涉及到的方法" class="headerlink" title="3. 解析resultMap节点涉及到的方法"></a>3. 解析<code>resultMap</code>节点涉及到的方法</h1><p>解析<code>resultMap</code>节点涉及到的核心类和方法很多，具体如下所示：</p><ul><li><p>XMLMapperBuilder</p><ul><li><p>resultMapElement()</p></li><li><p>inheritEnclosingType()</p></li><li><p>processConstructorElement()</p></li><li><p>processDiscriminatorElement()</p></li><li><p>buildResultMappingFormContext()</p></li><li><p>processNestedResultMappings()</p></li><li><p>validateCollection()</p></li></ul></li><li><p>MapperBuilderAssistant</p><ul><li>buildDiscriminator()</li><li>buildResultMappings()</li></ul></li><li><p>XNode</p><ul><li>getVauleBasedIdentifier()</li></ul></li><li><p>ResultMapResolver</p><ul><li>resolve()</li></ul></li></ul><h1 id="4-结合示例分析Mybatis解析resultMap节点的过程"><a href="#4-结合示例分析Mybatis解析resultMap节点的过程" class="headerlink" title="4. 结合示例分析Mybatis解析resultMap节点的过程"></a>4. 结合示例分析<code>Mybatis</code>解析<code>resultMap</code>节点的过程</h1><h2 id="4-1-示例一（resultMap节点下只有id和result）"><a href="#4-1-示例一（resultMap节点下只有id和result）" class="headerlink" title="4.1. 示例一（resultMap节点下只有id和result）"></a>4.1. 示例一（<code>resultMap</code>节点下只有<code>id</code>和<code>result</code>）</h2><pre><code class="xml">   &lt;resultMap id=&quot;authorResultMap&quot; type=&quot;TbAuthor&quot;&gt;      &lt;id property=&quot;authorId&quot; column=&quot;author_id&quot;/&gt;      &lt;result property=&quot;authorUsername&quot; column=&quot;author_username&quot;/&gt;      &lt;result property=&quot;authorPassword&quot; column=&quot;author_password&quot;/&gt;      &lt;result property=&quot;authorEmail&quot; column=&quot;author_email&quot;/&gt;   &lt;/resultMap&gt;</code></pre><ol><li><strong>开始解析，解析<code>resultMap</code>节点首先调用的方法就是<code>resultMapElement()</code>，如图所示：</strong></li></ol><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-10-8ftu4k.png!github_blog" srcset="undefined" alt=""></p><ol start="2"><li><strong>根据以下<code>debug</code>的显示，“<del>以下代码主要是解析<code>resultMap</code>中<code>type</code>的属性值，并获取属性值对应的Class类型</del>“（为什么用删除线往后读就知道了）。</strong></li></ol><pre><code class="java">//获取属性值String type = resultMapNode.getStringAttribute(&quot;type&quot;,        resultMapNode.getStringAttribute(&quot;ofType&quot;,            resultMapNode.getStringAttribute(&quot;resultType&quot;,                resultMapNode.getStringAttribute(&quot;javaType&quot;))));//获取resultMap映射的Class类型    Class&lt;?&gt; typeClass = resolveClass(type);    if (typeClass == null) {      typeClass = inheritEnclosingType(resultMapNode, enclosingType);    }</code></pre><p>结合上述列出的<strong>resultMap节点属性表</strong>可知：</p><ul><li><p>type属性只存在于<code>&lt;resultMap&gt;</code>中，而且必须定义为非空属性值；</p></li><li><p><code>&lt;resultMap&gt;</code>节点中不存在ofType、resultType、javaType属性；</p></li><li><p>ofType属性只存在与<code>&lt;collection&gt;</code>节点中；</p></li><li><p>resultType属性可以存在于<code>&lt;discriminator&gt;</code>节点的子节点<code>&lt;case&gt;</code>中；</p></li><li><p>javaType属性可以存下于<code>&lt;id&gt;</code>、<code>&lt;result&gt;</code>、<code>&lt;association&gt;</code>（以及<code>&lt;association&gt;</code>下的<code>&lt;idArg&gt;</code>和<code>&lt;arg&gt;</code>）、<code>&lt;collection&gt;</code>、<code>&lt;discriminator&gt;</code>节点中；</p></li></ul><p>结合<strong>存在即合理</strong>的理论，可知：</p><ul><li>上述的代码就不只是为了解析<code>&lt;resultMap&gt;</code>节点中的属性了；</li><li>也会解析上述所说的包含了<code>ofType</code>、<code>resultType</code>、<code>javaType</code>的节点；</li><li>也有可能解析不包含<code>ofType</code>、<code>resultType</code>、<code>javaType</code>的节点，因为<code>type==null</code>的时候也可以调用<code>inheritEnclosingType()</code>方法返回一个<code>typeClass</code>对象。</li></ul><p>那么就确定<code>resultMapElement()</code>方法，会被符合某些条件的节点调用，后续可知是<code>processNestedResultMappings()</code>方法中也调用了<code>resultMapElement()</code>。</p><ol start="3"><li><strong>初始化对象<code>Discriminator</code>和<code>resultMappings</code>（<code>List&lt;ResultMapping&gt;</code>），并将存入的值<code>add</code>到<code>resultMappings</code>结合中（读到这里也就有了头绪，<code>resultMapElement()</code>方法的用途之一就是迭代将节点解析成<code>ResultMapping</code>对象并将其存入到<code>resultMappings</code>集合中），代码如下所示：</strong></li></ol><pre><code class="java">    //初始化一个Discriminator，用于存放把&lt;discriminator&gt;节点解析的属性    Discriminator discriminator = null;    //初始化一个集合，该集合用于记录解析的结果    List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;&gt;();    resultMappings.addAll(additionalResultMappings);</code></pre><ol start="4"><li><strong>循环解析<code>&lt;resultMap&gt;</code>节点下的所有子节点，代码如下所示：</strong></li></ol><pre><code class="java">//处理&lt;resultMap&gt;的子节点    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();    for (XNode resultChild : resultChildren) {      if (&quot;constructor&quot;.equals(resultChild.getName())) {        //处理&lt;constructor&gt;节点        processConstructorElement(resultChild, typeClass, resultMappings);      } else if (&quot;discriminator&quot;.equals(resultChild.getName())) {        //处理&lt;discriminator&gt;节点        discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);      } else {        //处理&lt;id&gt;、&lt;result&gt;、&lt;association&gt;、&lt;collection&gt; 节点        List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();        //如果是&lt;id&gt;节点，则向flags集合中添加ResultFlag.ID        if (&quot;id&quot;.equals(resultChild.getName())) {          flags.add(ResultFlag.ID);        }        //创建ResultMapping对象，并添加到resultMappings集合        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));      }    }</code></pre><p>因为示例一中没有<code>&lt;constructor&gt;</code>和<code>&lt;discriminator&gt;</code>节点，所以程序会走到最后一个<code>else</code>中，而我们知道<code>&lt;resultMap&gt;</code>节点下还有<code>&lt;id&gt;</code>、<code>&lt;result&gt;</code>、<code>&lt;association&gt;</code>、<code>&lt;collection&gt;</code>节点，所以这个<code>else</code>中的代码会处理<code>&lt;id&gt;</code>、<code>&lt;result&gt;</code>、<code>&lt;association&gt;</code>、<code>&lt;collection&gt;</code>节点。</p><p><code>else</code>中大的步骤可以分为三步：</p><ul><li>创建一个<code>List&lt;ResultFlag&gt;</code>，如果有节点名称为<code>id</code>，那么就添加一个<code>ResultFlag.ID</code>到集合中；</li><li>调用<code>buildResultMappingFromContext()</code>方法得到一个<code>ResultMapping</code>对象；</li><li>将得到的<code>ResultMapping</code>对象对象添加到<code>resultMappings</code>集合中。</li></ul><p>其实最关键的代码一步就是调用<code>buildResultMappingFromContext()</code>方法返回一个<code>ResultMapping</code>对象。</p><ol start="5"><li><strong>通过buildResultMappingFromContext()，从上下文构建resultMapping，具体如下所示：</strong></li></ol><pre><code class="java">private ResultMapping buildResultMappingFromContext(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags) throws Exception {    String property;    if (flags.contains(ResultFlag.CONSTRUCTOR)) {      // 如果是ID标识，则获取name属性的值 例如：constructor 下的idArg*,arg*，只有name，而没有property      property = context.getStringAttribute(&quot;name&quot;);    } else {      //如果是ID标识，则获取property属性的值 例如：&lt;id property=&quot;authorId&quot; column=&quot;author_id&quot;/&gt; property = &quot;authorId&quot;      property = context.getStringAttribute(&quot;property&quot;);    }    //获取column属性值    String column = context.getStringAttribute(&quot;column&quot;);    //获取javaType属性值    String javaType = context.getStringAttribute(&quot;javaType&quot;);    //获取jdbcType属性值    String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;);    //获取select属性值    String nestedSelect = context.getStringAttribute(&quot;select&quot;);    //获取resultMap属性值，并处理其中嵌套的resultMapping    String nestedResultMap = context.getStringAttribute(&quot;resultMap&quot;,        processNestedResultMappings(context, Collections.emptyList(), resultType));    //获取notNullColumn属性值    String notNullColumn = context.getStringAttribute(&quot;notNullColumn&quot;);    //获取columnPrefix属性值    String columnPrefix = context.getStringAttribute(&quot;columnPrefix&quot;);    //获取typeHandler属性值    String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;);    //获取resultSet的属性值    String resultSet = context.getStringAttribute(&quot;resultSet&quot;);    //获取foreignColumn属性值    String foreignColumn = context.getStringAttribute(&quot;foreignColumn&quot;);    //设置lazy的值，会考虑全局的懒加载设置，如果局部属性没有设置fetchType的值，那么使用全部的设置    boolean lazy = &quot;lazy&quot;.equals(context.getStringAttribute(&quot;fetchType&quot;, configuration.isLazyLoadingEnabled() ? &quot;lazy&quot; : &quot;eager&quot;));    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);    //获取当前标签使用的typeHandler的实现类    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler);    //获取jdbcType对应的类    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);    //利用MapperBuilderAssistant构建ResultMappings    return builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);  }</code></pre><p>其实这个方法很简单，就是获取构建<code>ResultMapping</code>对象的属性值，然后通过调用<code>buildResultMapping()</code>构建<code>ResultMapping</code>对象。只不过其中涉及调用<code>processNestedResultMappings()</code>处理嵌套<code>ResultMapping</code>，然后返回其属于的<code>ResultMap</code>的名称。</p><p>因为示例中没有<code>resultMap</code>属性，跟没有嵌套的<code>resultMappings</code>，示例一这种情况，<code>nestedResultMap</code>永远为空。</p><ol start="6"><li>当示例一中<code>&lt;resultMap&gt;</code>下所有的子节点通过<code>for</code>循环遍历解析完之后，返回到<code>resultMapElement()</code>方法的以下位置：</li></ol><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-10-RW7Pss.png!github_blog" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-10-Y0Muzs.png!github_blog" srcset="undefined" alt=""></p><ol start="7"><li>获取当<code>resultMap</code>的<code>id</code>（如果没有通过<code>XNoder.getValueBasedIdentifier()</code>获取一个固定格式的<code>id</code>）；获取<code>extends</code>的属性的值；获取<code>autoMapping</code>的属性的值，然后调用<code>ResultMapResolver</code>的<code>resolve()</code>方法完成<code>ResultMap</code>对象的创建和添加，添加到<code>Configuration.resultMaps</code>中，代码如下所示：</li></ol><pre><code class="java"> String id = resultMapNode.getStringAttribute(&quot;id&quot;,            resultMapNode.getValueBasedIdentifier());    //获取&lt;resultMap&gt;节点的extends属性的值，该属性指定了&lt;resultMap&gt;节点的继承关系    String extend = resultMapNode.getStringAttribute(&quot;extends&quot;);    //获取&lt;resultMap&gt;节点的autoMapping属性的值    //如果该属性设置为true，则启动自动映射功能，即自动查找与列名相同的属性名，并调用setter方法。    //如果该属性设置为false，则需要在&lt;resultMapping&gt;节点内注明映射关系才能调用对应的setter方法。    Boolean autoMapping = resultMapNode.getBooleanAttribute(&quot;autoMapping&quot;);    //创建一个ResultMapResolver，并为当前的ResultMapResolver设置属性初始值，这些初始值会在ResultMapResolver的resolve()方法中派上用场    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);    try {      //创建ResultMap对象，并将其添加到Configuration.resultMap集合中，      return resultMapResolver.resolve();    } catch (IncompleteElementException  e) {      configuration.addIncompleteResultMap(resultMapResolver);      throw e;    }</code></pre><p>![image-20191210232804857](/Users/gnehcgnaw/Library/Application Support/typora-user-images/image-20191210232804857.png)</p><p><strong>为什么解析了一个<code>&lt;resultMap&gt;</code>节点会向<code>Configuration.resultMaps</code>中添加两条记录？</strong></p><p>这是因为<code>resultMaps</code>集合的类型是<code>StrictMap</code>，这个对象的<code>put()</code>方法如下所示：</p><pre><code class="java">  @Override    @SuppressWarnings(&quot;unchecked&quot;)    public V put(String key, V value) {      //如果检测到重复的key直接抛出异常      if (containsKey(key)) {        throw new IllegalArgumentException(name + &quot; already contains value for &quot; + key            + (conflictMessageProducer == null ? &quot;&quot; : conflictMessageProducer.apply(super.get(key), value)));      }      //如果没有重复的key则添加key以及value      //同时根据key产生shortKey      if (key.contains(&quot;.&quot;)) {        //按照“.”将key切分成数组，然后将数组的最后一项作为shortKey        final String shortKey = getShortName(key);        //如果不包含指定shortKey,则添加该键值对        if (super.get(shortKey) == null) {          super.put(shortKey, value);        } else {          //如果该shortKey已经存在，则将value修改成Ambiguity对象          super.put(shortKey, (V) new Ambiguity(shortKey));        }      }      //如果没有重复的key则添加key以及value（这是全面）      return super.put(key, value);    }</code></pre><h2 id="4-2-示例二（在示例一的基础上加上collection和association）"><a href="#4-2-示例二（在示例一的基础上加上collection和association）" class="headerlink" title="4.2. 示例二（在示例一的基础上加上collection和association）"></a>4.2. 示例二（在示例一的基础上加上<code>collection</code>和<code>association</code>）</h2><pre><code class="xml">  &lt;resultMap id=&quot;selectBlogDetailsResultMap2&quot; type=&quot;red.reksai.resultmap.entity.TbBlog&quot;&gt;    &lt;id property=&quot;blogId&quot; column=&quot;blog_id&quot; /&gt;    &lt;result property=&quot;blogTitle&quot; column=&quot;blog_title&quot;/&gt;    &lt;!--关联的嵌套结果映射resultMap=&quot;red.reksai.resultmap.mapper.TbAuthorMapper.authorResultMap&quot;--&gt;    &lt;association property=&quot;tbAuthor&quot; resultMap=&quot;red.reksai.resultmap.mapper.TbAuthorMapper.authorResultMap&quot; /&gt;    &lt;collection property=&quot;tbPosts&quot; ofType=&quot;red.reksai.resultmap.entity.TbPost&quot; resultMap=&quot;red.reksai.resultmap.mapper.TbPostMapper.postResultMap&quot; column=&quot;post_blog_id&quot; &gt;        &lt;collection property=&quot;tbComments&quot; ofType=&quot;red.reksai.resultmap.entity.TbComment&quot;/&gt;    &lt;/collection&gt;  &lt;/resultMap&gt;</code></pre><p>示例二和示例一唯一的不同就是有<code>resultMap</code>了，而且有嵌套的<code>resultMappings</code>了，代码体现就是进入到<code>processNestedResultMappings()</code>方法中的<code>if</code>中，具体如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/2019/12/2019-12-10-sikBap.png!github_blog" srcset="undefined" alt=""></p><p>根据if判断内的条件，可知这里是处理<association>、<collection>、<case>中嵌套的resultMapping的。</p><h2 id="4-3-示例三（在示例二的基础上加上constructor）"><a href="#4-3-示例三（在示例二的基础上加上constructor）" class="headerlink" title="4.3. 示例三（在示例二的基础上加上constructor）"></a>4.3. 示例三（在示例二的基础上加上<code>constructor</code>）</h2><pre><code class="xml"> &lt;resultMap id=&quot;selectBlogDetailsResultMap2&quot; type=&quot;red.reksai.resultmap.entity.TbBlog&quot;&gt;    &lt;constructor&gt;      &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt;    &lt;/constructor&gt;    &lt;id property=&quot;blogId&quot; column=&quot;blog_id&quot; /&gt;    &lt;result property=&quot;blogTitle&quot; column=&quot;blog_title&quot;/&gt;    &lt;!--关联的嵌套结果映射resultMap=&quot;red.reksai.resultmap.mapper.TbAuthorMapper.authorResultMap&quot;--&gt;    &lt;association property=&quot;tbAuthor&quot; resultMap=&quot;red.reksai.resultmap.mapper.TbAuthorMapper.authorResultMap&quot; /&gt;    &lt;collection property=&quot;tbPosts&quot; ofType=&quot;red.reksai.resultmap.entity.TbPost&quot; resultMap=&quot;red.reksai.resultmap.mapper.TbPostMapper.postResultMap&quot; column=&quot;post_blog_id&quot; &gt;        &lt;collection property=&quot;tbComments&quot; ofType=&quot;red.reksai.resultmap.entity.TbComment&quot;/&gt;    &lt;/collection&gt;  &lt;/resultMap&gt;</code></pre><p>如果有<code>&lt;constructor&gt;</code>子节点，会进入<code>processConstructorElement()</code>方法，具体如下所示：</p><p>![image-20191210233735073](/Users/gnehcgnaw/Library/Application Support/typora-user-images/image-20191210233735073.png)</p><pre><code class="java">private void processConstructorElement(XNode resultChild, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) throws Exception {    //获取&lt;constructor&gt;下的子节点    List&lt;XNode&gt; argChildren = resultChild.getChildren();    for (XNode argChild : argChildren) {      List&lt;ResultFlag&gt; flags = new ArrayList&lt;&gt;();      //添加CONSTRUCTOR标志      flags.add(ResultFlag.CONSTRUCTOR);      //如果包含idArg，添加ID标志      if (&quot;idArg&quot;.equals(argChild.getName())) {        flags.add(ResultFlag.ID);      }      //创建ResultMapping对象，并添加到resultMappings集合中      resultMappings.add(buildResultMappingFromContext(argChild, resultType, flags));    }  }</code></pre><h2 id="4-4-示例四（在示例三的基础上加上了discriminator）"><a href="#4-4-示例四（在示例三的基础上加上了discriminator）" class="headerlink" title="4.4. 示例四（在示例三的基础上加上了discriminator）"></a>4.4. 示例四（在示例三的基础上加上了<code>discriminator</code>）</h2><pre><code class="java"> &lt;discriminator javaType=&quot;int&quot; column=&quot;draft&quot;&gt;      &lt;case value=&quot;1&quot; resultType=&quot;DraftPost&quot;/&gt;    &lt;/discriminator&gt;</code></pre><pre><code class="java">private Discriminator processDiscriminatorElement(XNode context, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings) throws Exception {    String column = context.getStringAttribute(&quot;column&quot;);    String javaType = context.getStringAttribute(&quot;javaType&quot;);    String jdbcType = context.getStringAttribute(&quot;jdbcType&quot;);    String typeHandler = context.getStringAttribute(&quot;typeHandler&quot;);    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler);    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);    Map&lt;String, String&gt; discriminatorMap = new HashMap&lt;&gt;();    for (XNode caseChild : context.getChildren()) {      String value = caseChild.getStringAttribute(&quot;value&quot;);      //case节点内是可以定义resultMap的，所以还要去迭代解析直到所有的嵌套的resultMap解析完成为止      String resultMap = caseChild.getStringAttribute(&quot;resultMap&quot;, processNestedResultMappings(caseChild, resultMappings, resultType));      discriminatorMap.put(value, resultMap);    }    return builderAssistant.buildDiscriminator(resultType, column, javaTypeClass, jdbcTypeEnum, typeHandlerClass, discriminatorMap);  }</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis初始化(二)——1.解析&lt;cache&gt;和&lt;cache-ref&gt;节点</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E8%A7%A3%E6%9E%90%3Ccache%3E%E5%92%8C%3Ccache-ref%3E%E8%8A%82%E7%82%B9.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/%E8%A7%A3%E6%9E%90%3Ccache%3E%E5%92%8C%3Ccache-ref%3E%E8%8A%82%E7%82%B9.html</url>
    
    <content type="html"><![CDATA[<h1 id="解析-lt-cache-gt-和-lt-cache-ref-gt-节点"><a href="#解析-lt-cache-gt-和-lt-cache-ref-gt-节点" class="headerlink" title="解析&lt;cache&gt;和&lt;cache-ref&gt;节点"></a>解析<code>&lt;cache&gt;</code>和<code>&lt;cache-ref&gt;</code>节点</h1>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>​        JDBC数据类型与Java语言中的数据类型并不是完全对应的，所以在<code>PreparedStatement</code>为<code>SQL</code>语句绑定参数是，需要从<code>Java</code>类型转换成<code>JDBC</code>类型，而从<code>ResultSet</code>中获取数据时，则需要从<code>JDBC</code>类型转换成<code>Java</code>类型。<code>Mybatis</code>使用类型转换器完成上述两种转换。据图如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127092014-iVyREJ.png!github_blog" srcset="undefined" alt=""></p><p>​        在<code>Mybatis</code>中使用<code>JdbcType</code>这种枚举类型代表<code>JDBC</code>中的数据类型，该枚举类型中定义了<code>TYPE_CODE</code>字段，记录了<code>JDBC</code>类中在<code>java.sql.Types</code>中相应的常量编码，并通过一个静态集合<code>codeLookUp（HashMap&lt;Integer,JdbcType&gt;类型）</code>维护了常量编码与<code>JdbcType</code>之间的对应关系。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127093418-Gzcley.png!github_blog" srcset="undefined" alt=""></p><h1 id="2-TypeHandler"><a href="#2-TypeHandler" class="headerlink" title="2. TypeHandler"></a>2. TypeHandler</h1><p>​        Mybatis中所有的类型转换器都继承了<code>TypeHandler</code>接口，在<code>TypeHandler</code>接口中定义了如下四种方法，这四种方法分为两类：</p><ul><li><code>setParameter()</code>方法<ul><li>负责将数据由<code>Java</code>类型转换成<code>JdbcType</code>类型</li></ul></li><li><code>getResultSet()</code>方法<ul><li>负责将数据由<code>JdbcType</code>类型转换成<code>Java</code>类型</li></ul></li></ul><pre><code class="java">package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * 类型处理器 * 说白了typeHandlers就是用来完成javaType和jdbcType之间的转换 * @author Clinton Begin */public interface TypeHandler&lt;T&gt; {  /**   * 通过PreparedStatement为Sql语句绑定参数是，会将数据从Java类型转换成JdbcType类型   * @param ps   * @param i 转换第几个参数   * @param parameter 参数   * @param jdbcType  要转换的jdbcType的类型   * @throws SQLException   */  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;  /**   * 从ResultSet中获取数据时会调用此方法，将数据有JdbcType类型转换为Java类型   * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;   */  T getResult(ResultSet rs, String columnName) throws SQLException;  T getResult(ResultSet rs, int columnIndex) throws SQLException;  T getResult(CallableStatement cs, int columnIndex) throws SQLException;}</code></pre><p>​        为了方便用户自定义<code>TypeHandler</code>实现，<code>Mybatis</code>提供了<code>BaseTypeHandler</code>这个抽象类，它实现了<code>TypeHandler</code>几口，并继承了<code>TypeReference</code>抽象类，其继承结构如下所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127095043-dUqC8a.png!github_blog" srcset="undefined" style="zoom:50%;" /><p>在<code>BaseTypeHandler</code>中实现了<code>setParameter()</code>和<code>getResult()</code>方法，具体如下所示。</p><pre><code class="java">/**   * 在设置参数的时候，只处理为null的数据，不为空的数据都交给了子类实现   * @param ps   * @param i 转换第几个参数   * @param parameter 参数   * @param jdbcType  要转换的jdbcType的类型   * @throws SQLException   */  @Override  public void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException {    if (parameter == null) {      if (jdbcType == null) {        throw new TypeException(&quot;JDBC requires that the JdbcType must be specified for all nullable parameters.&quot;);      }      try {        ps.setNull(i, jdbcType.TYPE_CODE);      } catch (SQLException e) {        throw new TypeException(&quot;Error setting null for parameter #&quot; + i + &quot; with JdbcType &quot; + jdbcType + &quot; . &quot;              + &quot;Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. &quot;              + &quot;Cause: &quot; + e, e);      }    } else {      try {        //参数不为空，交给子类处理        setNonNullParameter(ps, i, parameter, jdbcType);      } catch (Exception e) {        throw new TypeException(&quot;Error setting non null for parameter #&quot; + i + &quot; with JdbcType &quot; + jdbcType + &quot; . &quot;              + &quot;Try setting a different JdbcType for this parameter or a different configuration property. &quot;              + &quot;Cause: &quot; + e, e);      }    }  }public abstract void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;</code></pre><pre><code class="java">  @Override  public T getResult(ResultSet rs, String columnName) throws SQLException {    try {      return getNullableResult(rs, columnName);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column &#39;&quot; + columnName + &quot;&#39; from result set.  Cause: &quot; + e, e);    }  }  @Override  public T getResult(ResultSet rs, int columnIndex) throws SQLException {    try {      return getNullableResult(rs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column #&quot; + columnIndex + &quot; from result set.  Cause: &quot; + e, e);    }  }  @Override  public T getResult(CallableStatement cs, int columnIndex) throws SQLException {    try {      return getNullableResult(cs, columnIndex);    } catch (Exception e) {      throw new ResultMapException(&quot;Error attempting to get column #&quot; + columnIndex + &quot; from callable statement.  Cause: &quot; + e, e);    }  }  /**   * 3.5.0版本之后getResult方法，不管是空还是非空数据都要交给子类去处理   * @param columnName Colunm name, when configuration &lt;code&gt;useColumnLabel&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;   */  public abstract T getNullableResult(ResultSet rs, String columnName) throws SQLException;  public abstract T getNullableResult(ResultSet rs, int columnIndex) throws SQLException;  public abstract T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException;</code></pre><p>​        <strong>需要注意的是：</strong>在<code>Mybatis3.5</code>及其之后版本，<code>BaseTypeHandler.setParemeter()</code>只处理空参，非空参数交于子类处理，<code>BaseTypeHandler.getResult()</code>不管是空值还是非空都交于子类处理，而<code>Mybatis3.5</code>版本之前，<code>BaseTypeHandler.setParemeter()</code>和<code>BaseTypeHandler.getResult()</code>都是只对空参进行处理的。</p><p>​        <code>BaseTypeHandler</code>的实现类是比较多的，但是实现比较简单。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127101750-TJLaJn.png!github_blog" srcset="undefined" style="zoom:67%;" /><p>这里以<code>IntergerTypeHandler</code>为例简单介绍：</p><pre><code class="java">package org.apache.ibatis.type;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @author Clinton Begin */public class IntegerTypeHandler extends BaseTypeHandler&lt;Integer&gt; {  @Override  public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType)      throws SQLException {    //调用PreparedStatement.setInt()实现参数绑定    ps.setInt(i, parameter);  }  @Override  public Integer getNullableResult(ResultSet rs, String columnName)      throws SQLException {    //调用ResultSet.getInt获取指定列值    int result = rs.getInt(columnName);    return result == 0 &amp;&amp; rs.wasNull() ? null : result;  }  @Override  public Integer getNullableResult(ResultSet rs, int columnIndex)      throws SQLException {    //调用ResultSet.getInt获取指定列值    int result = rs.getInt(columnIndex);    return result == 0 &amp;&amp; rs.wasNull() ? null : result;  }  @Override  public Integer getNullableResult(CallableStatement cs, int columnIndex)    //调用ResultSet.getInt获取指定列值      throws SQLException {    int result = cs.getInt(columnIndex);    return result == 0 &amp;&amp; cs.wasNull() ? null : result;  }}</code></pre><p>​        一般情况下，<code>TypeHandler</code>用于完成单个参数及其单个列值的类型转换，如果存在多列值转换成一个<code>Java</code>对象的需求，应该优先考虑使用在映射文件中定义合适的映射规则（<code>&lt;resultMap&gt;</code>节点）完成映射。</p><h1 id="3-TypeHandlerRegistry"><a href="#3-TypeHandlerRegistry" class="headerlink" title="3. TypeHandlerRegistry"></a>3. TypeHandlerRegistry</h1><p>​        介绍完<code>TypeHandler</code>接口及其功能之后，<code>Mybatis</code>如何管理众多的<code>TypeHandler</code>接口实现，如何知道何时使用哪个<code>TypeHandler</code>接口实现完成转换呢？这是有本小节介绍的<code>TypeHandlerRegistry</code>完成的，在<code>Mybatis</code>初始化过程中，会为所有已知的<code>TypeHandler</code>创建对象，并实现注册到<code>TypeHandlerRegistry</code>中，有<code>TypeHandlerRegistry</code>负责管理这些<code>TypeHandler</code>对象。<br>​        下面先来看看<code>TypeHandlerRegistry</code>中的核心字段的含义：</p><pre><code class="java">  /**   * 记录jdbcType与TypeHandler之间的对应关系，其中JdbcType是一个枚举类型，它定义对应了的JDBC类型   * 该集合主要用于从结果集读取数据是，将数据从jdbc类型转换成Java类型   */  private final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;  jdbcTypeHandlerMap = new EnumMap&lt;&gt;(JdbcType.class);  /**   * 记录了Java类型向指定的jdbcType转换时，需要使用的TypeHandler对象。   * 例如：Java类型中的String 可能转换为数据库的char、varchar等多种类型，所以存在一对多关系   */  private final Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = new ConcurrentHashMap&lt;&gt;();  /**   * 未知类型TypeHandler   */  private final TypeHandler&lt;Object&gt; unknownTypeHandler;  /**   * 记录了全部的TypeHandler的类型以及该类型相应的TypeHandler对象   */  private final Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; allTypeHandlersMap = new HashMap&lt;&gt;();  /**   * 空TypeHandler集合的标识   */  private static final Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap();  /**   * 默认枚举类型处理器   */  private Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler = EnumTypeHandler.class;</code></pre><h2 id="3-1-TypeHandlerRegistry构造方法"><a href="#3-1-TypeHandlerRegistry构造方法" class="headerlink" title="3.1. TypeHandlerRegistry构造方法"></a>3.1. TypeHandlerRegistry构造方法</h2><p><code>TypeHandlerRegistry</code>构造中综合起来做了三步操作：</p><ol><li>创建了一个<code>Configuration</code>，或者通过<code>mybatis-config.xml</code>的初始化传入一个<code>Configuration</code>到<code>TypeHandlerRegistry</code>构造中；</li><li>利用传入的<code>configuration</code>对象，创建一个<code>UnknownTpyeHandler</code>，以备后续使用；</li><li>注册一堆<code>Mybatis</code>为我们提供的默认的<code>TypeHandler</code>。</li></ol><h2 id="3-2-注册TypeHandler对象"><a href="#3-2-注册TypeHandler对象" class="headerlink" title="3.2. 注册TypeHandler对象"></a>3.2. 注册TypeHandler对象</h2><p>TypeHandlerRegistry.register()方法实现了注册TypeHandler对象的功能，register()方法有多个重载，这些重载之间的调用关系如下图所示。</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191127172443-pn2dhu.png!github_blog" srcset="undefined" alt=""></p><p>由上图可以看出，多数的register()方法最终会调用重载7完成注册功能，所以先分析重载7，该方法有三个参数分别是：</p><ul><li><code>Type javaType</code></li><li><code>JdbcType jdbcType</code></li><li><code>TypeHandler&lt;T&gt; handler</code></li></ul><pre><code class="java"> /**   * 最终调用到的重载方法   * @param javaType  能够处理的Java类型   * @param jdbcType   * @param handler   */  // 7  private void register(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler) {    //检测是否明确指定了TypeHandler能够处理的Java类型    if (javaType != null) {      //获取指定Java类型在typeHandlerMap集合中对应的TypeHandler集合      Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);      //如果map为空或者等于NULL_TYPE_HANDLER_MAP，创建新的TypeHandler集合，并添加到typeHandlerMap中      if (map == null || map == NULL_TYPE_HANDLER_MAP) {        map = new HashMap&lt;&gt;();        typeHandlerMap.put(javaType, map);      }      //将TypeHandler对象注册到typeHandlerMap集合中      map.put(jdbcType, handler);    }    //向allTypeHandlersMap集合注册TypeHandler类型和对应的TypeHandler对象    allTypeHandlersMap.put(handler.getClass(), handler);  }</code></pre><h2 id="3-3-查找TypeHandler"><a href="#3-3-查找TypeHandler" class="headerlink" title="3.3. 查找TypeHandler"></a>3.3. 查找TypeHandler</h2><p>介绍完注册<code>TypeHandler</code>对象的功能之后，再来介绍<code>TypeHandlerRegistry</code>提供的查找<code>TypeHandler</code>对象的功能。</p><h1 id="4-TypeAliasRegistry"><a href="#4-TypeAliasRegistry" class="headerlink" title="4. TypeAliasRegistry"></a>4. TypeAliasRegistry</h1><p>在编写<code>SQL</code>语句时，使用别名可以方便理解以及维护，例如表名或列名很长时，我们一般会为其设计易懂易维护的别名。<code>Mybatis</code>将<code>SQL</code>语句中的别名的概念进行了延伸和扩展，<code>Mybatis</code>可以为一个类添加一个别名，之后就可以通过别名引用该类。</p><p><code>Mybati</code>通过<code>TypeAliasRegistry</code>类完成别名的注册和管理功能，<code>TypeAliasRegistry</code>的结构比较简单，它通过<code>typeAliases</code>字段（<code>Map&lt;String, Class&lt;?&gt;&gt;</code>类型）管理别名与Java类型之间的对应关系，通过<code>TypeAliasRegistry.registerAlias()</code>方法完成注册别名，该方法的实现如下所示：</p><pre><code class="java">  /**   * 注册类型别名   * @param alias 被注册类的别名   * @param value  被注册的类   */  public void registerAlias(String alias, Class&lt;?&gt; value) {    if (alias == null) {      throw new TypeException(&quot;The parameter alias cannot be null&quot;);    }    // issue #748    //所有的类型最终都被转换为了小写，所以之前不管你是大写还是小写，最后都不转化了，不要因为大小写是不一样的。    String key = alias.toLowerCase(Locale.ENGLISH);    if (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != null &amp;&amp; !typeAliases.get(key).equals(value)) {      throw new TypeException(&quot;The alias &#39;&quot; + alias + &quot;&#39; is already mapped to the value &#39;&quot; + typeAliases.get(key).getName() + &quot;&#39;.&quot;);    }    typeAliases.put(key, value);  }</code></pre><p><code>TypeAliasRegistry</code>还有很多<code>registerAlias()</code>的重载，如下图所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129164654-qjl9So.png!github_blog" srcset="undefined" alt=""></p><p>其中还有两个重载需要我们注意：</p><ul><li><p>扫描包的</p><pre><code class="java">  /**   * 扫描指定包下面所有的类，并为其类的子类添加别名   * @param packageName   * @param superType   */  public void registerAliases(String packageName, Class&lt;?&gt; superType) {    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();    for (Class&lt;?&gt; type : typeSet) {      // Ignore inner classes and interfaces (including package-info.java)      // Skip also inner classes. See issue #6      if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) {        registerAlias(type);      }    }  }</code></pre></li><li><p>尝试读取<code>@Alias</code>注解的</p><pre><code class="java">  public void registerAlias(Class&lt;?&gt; type) {    //获取类的简单名称，不包括包名    String alias = type.getSimpleName();    //读取Alias注解    Alias aliasAnnotation = type.getAnnotation(Alias.class);    if (aliasAnnotation != null) {      alias = aliasAnnotation.value();    }    registerAlias(alias, type);  }</code></pre></li></ul><p>在<code>TypeAliasRegistry</code>的构造方法中，默认为Java的基本类型及其数组类型、基本类型的包装类型以及数组类型、<code>Data</code>、<code>BigDecimal</code>、<code>ResultSet</code>等类型添加了别名，可以参考<code>Mybatis</code>官网文档（<a href="https://mybatis.org/mybatis-3/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases模块</a>）。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis初始化(一)</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%B8%80).html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%B8%80).html</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis初始化-一"><a href="#Mybatis初始化-一" class="headerlink" title="Mybatis初始化(一)"></a>Mybatis初始化(一)</h1><hr><p><strong>因为篇幅的原因，此部分只分析mybatis-config.xml配置文件的解析。</strong></p><hr><p>类似于<code>Spring</code>，<code>Mybatis</code>等灵活性和扩展性都很高的开源框架都提供了很多配置项，开发人员需要在使用时提供相应的配置信息，实现相应的需求。<code>Mybatis</code>中的配置文件主要有两个，分别是<code>mybatis-config.xml</code>配置文件和映射配置文件。</p><p>现在主流的配置方式除了使用XML配置文件，还会配合注解进行配置。在<code>Mybatis</code>初始化过程中，除了会读取<code>mybatis-config.xml</code>配置文件以及映射配置文件，还会加载配置文件指定的类，处理类中的注解，创建一些配置对象，最终完成框架中各个模块的初始化。另外，也可以使用<code>Java API</code>方式对<code>Mybatis</code>进行配置，这种硬编码的配置方式主要用在配置量比较少且配置信息不常变化的场景下。</p><h1 id="1-建造者模式"><a href="#1-建造者模式" class="headerlink" title="1. 建造者模式"></a>1. 建造者模式</h1><h1 id="2-BaseBuidler"><a href="#2-BaseBuidler" class="headerlink" title="2. BaseBuidler"></a>2. BaseBuidler</h1><p><code>BaseBuilder</code>的子类如下所示：</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128141904-lVPgr8.png!github_blog" srcset="undefined" style="zoom:50%;" /><p>因为<code>VelocitySqlSourceBuilder</code>只是一个测试用例，所以我暂且不把它划为<code>BaseBuilder</code>，包括其静态内部类</p><p><code>ParameterMappingTokenHandler</code>，这样<code>BaseBuilder</code>的子类结构图就如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128142203-inbhpO.png!github_blog" srcset="undefined" alt=""></p><p>正如签名所示，<code>Mybatis</code>的初始化过程使用了建造者模式，这里的<code>BaseBuilder</code>抽象类就扮演了建造者接口的角色。<code>BaseBuilder</code>中的核心字段的含义如下：</p><ul><li><code>Configuration</code></li><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#3-TypeHandlerRegistry" target="_blank" rel="noopener">TypeHandlerRegistry</a></li><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a></li></ul><pre><code class="java"> /**  * Configuration对象是Mybatis初始化过程中的核心对象，Mybatis中几乎所有配置信息都会保存到Configuration对象中。  *    * Configuration对象是Mybatis初始化过程中创建的且是全局唯一的。   * 也有人称它是一个“All in One” 对象   */  protected final Configuration configuration;  /**   * 在mybatis-config.xml配置文件中可以使用&lt;typeAliases&gt;&lt;/typeAliases&gt;标签定义别名，这些定义的别名都会记录在TypeAliasesRegistry对象中   */  protected final TypeAliasRegistry typeAliasRegistry;  /**   * 在mybatis-config.xml配置文件中可以使用&lt;typeHandler&gt;&lt;/typeHandler&gt;标签定义添加的自定义的TypeHandler，   * 完成指定数据库类型与Java类型的转换，这些TypeHandler都会记录在TypeHandlerRegistry中   */  protected final TypeHandlerRegistry typeHandlerRegistry;</code></pre><p><code>BaseBuilder</code>中记录的<code>TypeAliasRegistry</code>对象和<code>TypeHandlerRegistry</code>对象，其实是全局唯一的，它们都是在<code>Configuration</code>对象初始化时创建的，代码如下所示：</p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191128145108-dgZGGY.png!github_blog" srcset="undefined" alt=""></p><p>在<code>BaseBuilder</code>构造函数中，通过相应的<code>Configuration.get*()</code>方法得到<code>TypeAliasRegistry</code>和<code>TypeHandlerRegistry</code>对象，并赋值给<code>BaseBuilder</code>相应的字段。</p><pre><code class="java">  /**   * 构造方法   * @param configuration   */  public BaseBuilder(Configuration configuration) {    this.configuration = configuration;    this.typeAliasRegistry = this.configuration.getTypeAliasRegistry();    this.typeHandlerRegistry = this.configuration.getTypeHandlerRegistry();  }</code></pre><p><code>Configuration</code>中还包含了很多配置项，为了便于读者理解，这里不会罗杰出内个字段的含义，而是在后面介绍的过程中，每涉及到一个配置项时，会结合其在<code>Configuration</code>中相应字段进行详细分析。</p><p><code>BaseBuilder.resolveAlias()</code>方法依赖<code>TypeAliasRegistry</code>解析别名，<code>BaseBuilder.resolveTypeHandler()</code>方法依赖<code>TypeHandlerRegistry</code>查找指定的<code>TypeHandler</code>对象。在阅读完<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a>和<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html#3-TypeHandlerRegistry" target="_blank" rel="noopener">TypeHandlerRegistry</a>的相关实现的介绍后，<code>BaseBuilder.resolveAlias()</code>和<code>BaseBuilder.resolveTypeHandler()</code>就不难理解了。</p><p>前面提到过，<code>Mybatis</code>使用<code>JdbcType</code>枚举类型表示<code>JDBC</code>类型。<code>Mybatis</code>中常用的枚举类型还有<code>ResultSetType</code>和<code>ParameterMode</code>：</p><ul><li><code>ResultSetType</code>枚举表示结果集类型；</li><li><code>ParameterMode</code>枚举类型表示存储过程中的参数类型。</li></ul><p>在<code>BaseBuilder</code>中提供了相应的<code>resolveJdbcType()</code>、<code>resolveResultSetType()</code>、<code>resolveParameterMode()</code>方法，将<code>String</code>转换成对应的枚举类型，实现比较简单。</p><h1 id="3-XMLConfigBuilder"><a href="#3-XMLConfigBuilder" class="headerlink" title="3. XMLConfigBuilder"></a>3. XMLConfigBuilder</h1><p><code>XMLConfigBuilder</code>是<code>BaseBuilder</code>的众多子类之一，它扮演的是具体建造者的角色。<code>XMLConfigBuilder</code>主要负责解析<code>mybatis-config.xml</code>配置文件，其核心字段如下：</p><ul><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html#4-XPathParser" target="_blank" rel="noopener">XPathParser</a></li><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html#4-XPathParser" target="_blank" rel="noopener">ReflectorFactory</a></li></ul><pre><code class="java">/**   *   标识是否被解析过mybatis-config.xml   */  private boolean parsed;  /**   * 用于解析mybatis-config.xml配置文件的XPathParse对象，   */  private final XPathParser parser;  /**   * 标识&lt;environment&gt;&lt;environment/&gt;配置的名称，默认读取&lt;environment&gt;&lt;environment/&gt;标签的default属性   */  private String environment;  /**   * ReflectorFactory负责创建和缓存Reflector对象   */  private final ReflectorFactory localReflectorFactory = new DefaultReflectorFactory();</code></pre><p><code>XMLConfigBuilder.parse()</code>方法是解析<code>mybatis-config.xml</code>配置文件的入口，它通过调用<code>XMLConfigBuilder.parseConfiguration()</code>方法实现整个解析过程，具体实现如下所示：</p><pre><code class="java">//XMLConfigBuilder.java/**   * 解析配置：   *    这里其实有一个细节，就是{@link #parsed} 字段，这是一个boolbean类型的，也就是默认值是false，   *    根据以下代码，发现只有当parsed = false才回去解析配置，为true的时候不会去解析，直接抛出异常，   *    这么做的原因是：因为在解析mybatis中配置文件的时候是一件很消耗性能的事情，所以只解析一次。   * @return configuration配置 （e.g. &lt;configuration&gt; ....&lt;configuration/&gt;）   */  public Configuration parse() {    if (parsed) {      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);    }    parsed = true;    //在mybatis-config.xml配置文件中查找&lt;configuration&gt;&lt;/configuration&gt;节点，并开始解析    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));    return configuration;  }</code></pre><pre><code class="java">//XMLConfigBuilder.java/**   * 解析Configuration标签中的配置   * @param root   */  private void parseConfiguration(XNode root) {    try {      //issue #117 read properties first      //解析&lt;properties&gt;节点      propertiesElement(root.evalNode(&quot;properties&quot;));      // 解析&lt;settings&gt;节点      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));      //设置vfsImpl字段      loadCustomVfs(settings);      //设置logImpl字段      loadCustomLogImpl(settings);      // 解析&lt;typeAliases&gt;节点      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));      // 解析&lt;plugins&gt;节点      pluginElement(root.evalNode(&quot;plugins&quot;));      // 解析&lt;objectFactory&gt;节点      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));      // 解析&lt;objectWrapperFactory&gt;节点      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));      // 解析&lt;reflectorFactory&gt;节点      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));      //将settings值设置到Configuration中      settingsElement(settings);      // read it after objectFactory and objectWrapperFactory issue #631      // 解析&lt;environments&gt;节点      environmentsElement(root.evalNode(&quot;environments&quot;));      // 解析&lt;databaseIdProvider&gt;节点      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));      // 解析&lt;typeHandlers&gt;节点      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));      // 解析&lt;mappers&gt;节点      mapperElement(root.evalNode(&quot;mappers&quot;));    } catch (Exception e) {      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);    }  }</code></pre><p><code>parseConfiguration()</code>方法的代码还是比较整洁的，我们可以清楚地看到，<code>XMLConfigBuilder</code>将<code>mybatis-config.xml</code>配置文件中每一个节点的解析过程封装成一个相应的方法，本小节的后续内容将逐一分析这些节点的解析过程。</p><h2 id="3-1-解析-lt-properties-gt-节点"><a href="#3-1-解析-lt-properties-gt-节点" class="headerlink" title="3.1. 解析&lt;properties&gt;节点"></a>3.1. 解析<code>&lt;properties&gt;</code>节点</h2><p><code>XMLConfigBuilder.propertiesElement()</code>方法会解析<code>mybatis-config.xml</code>配置文件中的<code>&lt;properties&gt;</code>节点，并信形成<code>java.uitl.Properties</code>对象，之后将该<code>Properties</code>对象设置到<code>XPathParser</code>和<code>Configuration</code>的<code>variable</code>字段中。在后面的解析过程中，会使用该<code>Properties</code>对象中的信息替换占位符。<code>propertiesElement()</code>方法的具体实现如下所示：</p><pre><code class="java">/**   * `XMLConfigBuilder.propertiesElement()`方法会解析`mybatis-config.xml`配置文件中的`&lt;properties&gt;`节点，   * 并信形成`java.uitl.Properties`对象，之后将该`Properties`对象设置到`XPathParser`和`Configuration`的`variable`字段中。   * 在后面的解析过程中，会使用该`Properties`对象中的信息替换占位符。   * @param context  e.g. &lt;properties resource=&quot;resources/config.properties&quot;&gt;   *                         &lt;property name=&quot;username&quot; value=&quot;xxx&quot;/&gt;   *                         &lt;property name=&quot;password&quot; value=&quot;xxx&quot;/&gt;   *                      &lt;/properties&gt;   * @throws Exception   */  private void propertiesElement(XNode context) throws Exception {    if (context != null) {      // username = xxx 和password = xxx 两个      Properties defaults = context.getChildrenAsProperties();      String resource = context.getStringAttribute(&quot;resource&quot;);      String url = context.getStringAttribute(&quot;url&quot;);      //properties元素不能同时指定URL和基于资源的属性文件引用。请指定其中一个。      if (resource != null &amp;&amp; url != null) {        throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);      }      //这个其实就是使用外部化配置覆盖内部值      if (resource != null) {        defaults.putAll(Resources.getResourceAsProperties(resource));      } else if (url != null) {        defaults.putAll(Resources.getUrlAsProperties(url));      }      Properties vars = configuration.getVariables();      if (vars != null) {        defaults.putAll(vars);      }      //更新XPathParser和Configuration的variable字段      parser.setVariables(defaults);      configuration.setVariables(defaults);    }  }</code></pre><h2 id="3-2-解析-lt-settings-gt-节点"><a href="#3-2-解析-lt-settings-gt-节点" class="headerlink" title="3.2. 解析&lt;settings&gt;节点"></a>3.2. 解析<code>&lt;settings&gt;</code>节点</h2><p><code>XMLConfigBuilder.settingsAsProperties()</code>方法负责解析<code>&lt;settings&gt;</code>节点，在<code>&lt;settings&gt;</code>节点下的配置是<strong>Mybatis全局性的配置</strong>，它们会改变<code>Mybatis</code>的运行时行为，具体的配置项的含义请阅读参考<a href="https://mybatis.org/mybatis-3/configuration.html#settings" target="_blank" rel="noopener">Mybatis官方文档</a>。需要注意的是，在<code>Mybatis</code>初始化时，这些全局配置信息都会被记录到<code>Configuration</code>对象的对应属性中。例如，开发人员可以通过设置————————。</p><p>在<code>Configuration</code>中存在一个同名的相应字段，如下：</p><p><code>settingsAsProperties()</code>方法的解析方式和<code>propertiesElement()</code>方法类似，但是多了使用<code>MetaClass</code>检测<code>key</code>指定的属性在<code>Configuration</code>类中是否有对应<code>setter</code>方法的步骤。<code>settingsAsProperties()</code>方法的代码如下所示：</p><pre><code class="java">  private Properties settingsAsProperties(XNode context) {    if (context == null) {      return new Properties();    }    Properties props = context.getChildrenAsProperties();    // Check that all settings are known to the configuration class    MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);    //使用`MetaClass`检测`key`指定的属性在`Configuration`类中是否有对应`setter`方法的步骤    for (Object key : props.keySet()) {      if (!metaConfig.hasSetter(String.valueOf(key))) {        throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);      }    }    return props;  }</code></pre><h2 id="3-3-设置vfsImpl和logImpl"><a href="#3-3-设置vfsImpl和logImpl" class="headerlink" title="3.3. 设置vfsImpl和logImpl"></a>3.3. 设置<code>vfsImpl</code>和<code>logImpl</code></h2><p>这两个参数一般不会去处理，所以我只罗列出来，不去解析：</p><h3 id="3-3-1-设置vfsImpl"><a href="#3-3-1-设置vfsImpl" class="headerlink" title="3.3.1. 设置vfsImpl"></a>3.3.1. 设置vfsImpl</h3><p>参看VFS详解</p><pre><code class="java">  private void loadCustomVfs(Properties props) throws ClassNotFoundException {    String value = props.getProperty(&quot;vfsImpl&quot;);    if (value != null) {      String[] clazzes = value.split(&quot;,&quot;);      for (String clazz : clazzes) {        if (!clazz.isEmpty()) {          @SuppressWarnings(&quot;unchecked&quot;)          Class&lt;? extends VFS&gt; vfsImpl = (Class&lt;? extends VFS&gt;)Resources.classForName(clazz);          configuration.setVfsImpl(vfsImpl);        }      }    }  }</code></pre><h3 id="3-3-2-设置logImpl"><a href="#3-3-2-设置logImpl" class="headerlink" title="3.3.2. 设置logImpl"></a>3.3.2. 设置logImpl</h3><pre><code class="java">  private void loadCustomLogImpl(Properties props) {    Class&lt;? extends Log&gt; logImpl = resolveClass(props.getProperty(&quot;logImpl&quot;));    configuration.setLogImpl(logImpl);  }</code></pre><h2 id="3-4-解析-lt-typeAliases-gt-节点"><a href="#3-4-解析-lt-typeAliases-gt-节点" class="headerlink" title="3.4. 解析&lt;typeAliases&gt;节点"></a>3.4. 解析<code>&lt;typeAliases&gt;</code>节点</h2><p><code>XMLConfigBuilder.typeAliasesElement()</code>负责解析<code>&lt;typeAliases&gt;</code>节点及其子节点，然后利用<a href="https://gnehcgnaw.github.io/Mybatis源码分析/基础支持层/类型转换.html#4-TypeAliasRegistry" target="_blank" rel="noopener">TypeAliasRegistry</a>完成别名的注册，具体实现如下所示：</p><pre><code class="java">private void typeAliasesElement(XNode parent) {    if (parent != null) {      for (XNode child : parent.getChildren()) {        /**         * 指定报名，MyBatis 会在包名下面搜索需要的 Java Bean         * 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。         * 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值 。         */        if (&quot;package&quot;.equals(child.getName())) {          String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);        } else {          String alias = child.getStringAttribute(&quot;alias&quot;);          String type = child.getStringAttribute(&quot;type&quot;);          try {            Class&lt;?&gt; clazz = Resources.classForName(type);            if (alias == null) {              typeAliasRegistry.registerAlias(clazz);            } else {              typeAliasRegistry.registerAlias(alias, clazz);            }          } catch (ClassNotFoundException e) {            throw new BuilderException(&quot;Error registering typeAlias for &#39;&quot; + alias + &quot;&#39;. Cause: &quot; + e, e);          }        }      }    }  }</code></pre><h2 id="3-5-解析-lt-plugins-gt-节点"><a href="#3-5-解析-lt-plugins-gt-节点" class="headerlink" title="3.5. 解析&lt;plugins&gt;节点"></a>3.5. 解析<code>&lt;plugins&gt;</code>节点</h2><p>插件是<code>Mybatis</code>提供的扩展机制之一，用户可以通过添加自定义插件在<code>SQL</code>语句执行过程中的某一点进行拦截。<code>Mybatis</code>中的自定义插件只需要实现<code>Interceptor</code>接口，并通过注解指定想要拦截的方法签名即可。在高级主题模块，将详细介绍插件的使用和原理，这里先来分析<code>Mybatis</code>中如何加载和管理插件。</p><p><code>XMLConfigBuilder.pluginElement()</code>方法负责解析<code>&lt;plugins&gt;</code>节点中定义的插件，并完成实例化和配置操作，具体实现如下所示：</p><pre><code class="java"> private void pluginElement(XNode parent) throws Exception {    if (parent != null) {      //遍历全部的子节点，即遍历&lt;plugins&gt;      for (XNode child : parent.getChildren()) {        //获取&lt;plugin&gt;节点的interceptor属性的值        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);        //获取&lt;plugin&gt;下&lt;properties&gt;配置的信息，并形成Properties对象        Properties properties = child.getChildrenAsProperties();        //通过别名获取对应的Clazz，然后通过反射实例化Interceptor对象        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();        //为当前interceptor设置属性值        interceptorInstance.setProperties(properties);        //记录Interceptor对象        configuration.addInterceptor(interceptorInstance);      }    }  }</code></pre><h2 id="3-6-解析-lt-objectFactory-gt-、-lt-objectWrapperFactory-gt-、-lt-reflectorFactory-gt-节点"><a href="#3-6-解析-lt-objectFactory-gt-、-lt-objectWrapperFactory-gt-、-lt-reflectorFactory-gt-节点" class="headerlink" title="3.6. 解析&lt;objectFactory&gt;、&lt;objectWrapperFactory&gt;、&lt;reflectorFactory&gt;节点"></a>3.6. 解析<code>&lt;objectFactory&gt;</code>、<code>&lt;objectWrapperFactory&gt;</code>、<code>&lt;reflectorFactory&gt;</code>节点</h2><p>我们可以通过自定义添加ObjectFactory、ObjectWarpperFactroy、<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html#4-XPathParser" target="_blank" rel="noopener">ReflectorFactory</a>的实现类来扩展<code>Mybatis</code>。</p><p><code>XMLConfigBuilder.objectFactoryElement()</code>方法负责解析并实例化<code>&lt;objectFactory&gt;</code>节点指定的<code>ObjectFactory</code>的实现类，之后将自定义的<code>ObjectFactory</code>对象记录在<code>Configuration.objectFactory</code>字段中，具体实现如下所示：</p><pre><code class="java">  private void objectFactoryElement(XNode context) throws Exception {    if (context != null) {      //获取&lt;objectFactory&gt;中的type属性      String type = context.getStringAttribute(&quot;type&quot;);      //获取&lt;objectFactory&gt;节点下的配置信息，并形成Properties对象      Properties properties = context.getChildrenAsProperties();      //通过别名获取对应的clazz，然后实例化ObjectFactory      ObjectFactory factory = (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();      //为实例化的ObjectFactory对象设置属性      factory.setProperties(properties);      //记录ObjectFactory对象      configuration.setObjectFactory(factory);    }  }</code></pre><p>XMLConfigBuilder对<code>&lt;objectWrapperFactory&gt;</code>和<code>&lt;reflectorFactory&gt;</code>节点的解析，和上述过程类似。</p><h2 id="3-7-将settings值设置到Configuration中"><a href="#3-7-将settings值设置到Configuration中" class="headerlink" title="3.7. 将settings值设置到Configuration中"></a>3.7. 将<code>settings</code>值设置到<code>Configuration</code>中</h2><p><code>XMLConfigBuilder.settingsElement()</code>这个就是最简单的赋值操作，如下所示：</p><pre><code class="java">  private void settingsElement(Properties props) {    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(&quot;autoMappingUnknownColumnBehavior&quot;, &quot;NONE&quot;)));    configuration.setCacheEnabled(booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;), true));    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(&quot;proxyFactory&quot;)));    configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(&quot;lazyLoadingEnabled&quot;), false));    configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(&quot;aggressiveLazyLoading&quot;), false));    configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(&quot;multipleResultSetsEnabled&quot;), true));    configuration.setUseColumnLabel(booleanValueOf(props.getProperty(&quot;useColumnLabel&quot;), true));    configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(&quot;useGeneratedKeys&quot;), false));    configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(&quot;defaultExecutorType&quot;, &quot;SIMPLE&quot;)));    configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(&quot;defaultStatementTimeout&quot;), null));    configuration.setDefaultFetchSize(integerValueOf(props.getProperty(&quot;defaultFetchSize&quot;), null));    configuration.setDefaultResultSetType(resolveResultSetType(props.getProperty(&quot;defaultResultSetType&quot;)));    configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(&quot;mapUnderscoreToCamelCase&quot;), false));    configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(&quot;safeRowBoundsEnabled&quot;), false));    configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(&quot;localCacheScope&quot;, &quot;SESSION&quot;)));    configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(&quot;jdbcTypeForNull&quot;, &quot;OTHER&quot;)));    configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(&quot;lazyLoadTriggerMethods&quot;), &quot;equals,clone,hashCode,toString&quot;));    configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(&quot;safeResultHandlerEnabled&quot;), true));    configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(&quot;defaultScriptingLanguage&quot;)));    configuration.setDefaultEnumTypeHandler(resolveClass(props.getProperty(&quot;defaultEnumTypeHandler&quot;)));    configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(&quot;callSettersOnNulls&quot;), false));    configuration.setUseActualParamName(booleanValueOf(props.getProperty(&quot;useActualParamName&quot;), true));    configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(&quot;returnInstanceForEmptyRow&quot;), false));    configuration.setLogPrefix(props.getProperty(&quot;logPrefix&quot;));    configuration.setConfigurationFactory(resolveClass(props.getProperty(&quot;configurationFactory&quot;)));  }</code></pre><h2 id="3-8-解析-lt-environments-gt-节点"><a href="#3-8-解析-lt-environments-gt-节点" class="headerlink" title="3.8. 解析&lt;environments&gt;节点"></a>3.8. 解析<code>&lt;environments&gt;</code>节点</h2><p>在实际生产中，同一项目可能分为开发、测试和生产多个不同的环境，每个环境的配置可能不尽相同。Mybatis可以配置多个<code>&lt;environment&gt;</code>节点，每个<code>&lt;environment&gt;</code>节点对应一种环境的配置。但是需要注意的是，尽管可以配置多环境，每个SqlSessionFactory实例只能选择其一。</p><p><code>XMLConfigBuilder.environmentElement()</code>方法负责解析<code>&lt;environment&gt;</code>的相关配置，它会根据<code>XMLConfigBuilder.environmen</code>t字段值确定要使用的<code>&lt;environment&gt;</code>配置，之后创建对应的<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/Transaction.html#2-TranscationFactory" target="_blank" rel="noopener">TransactionFactory</a>和<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/DataSource.html#2-DataSourceFactory" target="_blank" rel="noopener">DataSourceFactroy</a>对象，通过<code>DataSourceFactory.getDataSource()</code>获取<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/Transaction.html#2-TranscationFactory" target="_blank" rel="noopener">DataSource</a>对象，并封装进<code>Environment</code>对象中。<code>environmentElement()</code>方法的具体实现如下：</p><pre><code class="java"> private void environmentsElement(XNode context) throws Exception {    if (context != null) {      //未指定XMLConfigBuilder#environment字段的值，那么使用default属性指定的&lt;environment&gt;&lt;/environment&gt;      if (environment == null) {        environment = context.getStringAttribute(&quot;default&quot;);      }      for (XNode child : context.getChildren()) {        String id = child.getStringAttribute(&quot;id&quot;);        //检测字段与XMLConfigBuilder#environment字段是否匹配        if (isSpecifiedEnvironment(id)) {          //创建TransactionFactory：具体实现是先通过TypeAliasRegistry解析别名之后，实例化TransactionFactory          TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));          //创建DataSourceFactory然后得到DataSource          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));          DataSource dataSource = dsFactory.getDataSource();          //创建Environment对象，Environment中封装了上面创建的TransactionFactory和DataSource对象，这里应用的是建造者模式          Environment.Builder environmentBuilder = new Environment.Builder(id)              .transactionFactory(txFactory)              .dataSource(dataSource);          //将Environment对象，记录在Configuration.environment字段中          configuration.setEnvironment(environmentBuilder.build());        }      }    }  }</code></pre><h2 id="3-9-解析-lt-databaseIdProvider-gt-节点"><a href="#3-9-解析-lt-databaseIdProvider-gt-节点" class="headerlink" title="3.9.  解析&lt;databaseIdProvider&gt;节点"></a>3.9.  解析<code>&lt;databaseIdProvider&gt;</code>节点</h2><p><code>Mybatis</code>不能像<code>Hibernate</code>那样使用<a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#database-dialect" target="_blank" rel="noopener">hibernate.dialect</a>进行设置，然后直接帮助开发人员屏蔽多种数据库产品在<code>SQL</code>语言支持方言的差异。但是可以在<code>mybatis-config.xml</code>配置文件中，通过<code>&lt;databaseIdProvider&gt;</code>定义所有支持的数据库产品的<code>databaseId</code>，然后在映射文件中定义<code>SQL</code>语句节点中，通过<code>databaseId</code>指定该<code>SQL</code>语句应用的数据库产品，这样也可以实现类似的功能。</p><p>在<code>Mybatis</code>初始化时，会根据前面确定的<code>DataSource</code>确定当前使用的数据库产品，然后在解析映射配置文件时，加载不带<code>databaseId</code>属性和带有匹配当前数据库<code>databaseId</code>属性的所有<code>SQL</code>语句。如果同时找到了带<code>databaseId</code>和不带<code>databaseId</code>的相同语句，则后者会被舍弃，使用前者。</p><p><code>XMLConfigBuilder.databaseIdProviderElement()</code>方法负责解析<code>&lt;databaseIdProvider&gt;</code>节点，并创建指定的DatabaseIdProvider对象。<code>DatabaseIdProvider</code>会返回一个<code>databaseId</code>值，<code>Mybatis</code>会根据<code>databaseId</code>选择合适的<code>SQL</code>去执行。</p><pre><code class="java">private void databaseIdProviderElement(XNode context) throws Exception {    DatabaseIdProvider databaseIdProvider = null;    if (context != null) {      String type = context.getStringAttribute(&quot;type&quot;);      // awful patch to keep backward compatibility      //为了保证兼容性，修改type取值 &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;      if (&quot;VENDOR&quot;.equals(type)) {        type = &quot;DB_VENDOR&quot;;      }      //解析相关配置信息      Properties properties = context.getChildrenAsProperties();      //创建DatabaseIdProvider对象      databaseIdProvider = (DatabaseIdProvider) resolveClass(type).getDeclaredConstructor().newInstance();      //配置DatabaseIdProvider，完成初始化      databaseIdProvider.setProperties(properties);    }    Environment environment = configuration.getEnvironment();    if (environment != null &amp;&amp; databaseIdProvider != null) {      //通过前面确定的DataSource获取databaseId,并记录到Configuration.databaseId字段中      String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());      configuration.setDatabaseId(databaseId);    }  }</code></pre><h2 id="3-10-解析-lt-typeHandlers-gt-节点"><a href="#3-10-解析-lt-typeHandlers-gt-节点" class="headerlink" title="3.10. 解析&lt;typeHandlers&gt;节点"></a>3.10. 解析<code>&lt;typeHandlers&gt;</code>节点</h2><h2 id="3-11-解析-lt-mappers-gt-节点"><a href="#3-11-解析-lt-mappers-gt-节点" class="headerlink" title="3.11. 解析&lt;mappers&gt;节点"></a>3.11. 解析<code>&lt;mappers&gt;</code>节点</h2><p>在<code>Mybatis</code>初始化时，除了加载<code>mybatis-config.xml</code>配置文件，还会加载全部的映射配置文件，<code>mybatis-config.xml</code>配置文件中的<code>&lt;mappers&gt;</code>节点会告诉我<code>Mybatis</code>去哪些位置查找映射配置文件以及使用了配置注解表示的接口。</p><p><code>XMLConfigBuilder.mapperElement()</code>方法负责解析<code>&lt;mappers&gt;</code>节点，它会创建<code>XMLMapperBuilder</code>对象加载映射文件，如果映射配置文件存在相应的<code>Mapper</code>接口，也会加载相应的<code>Mapper</code>接口，解析其中的注解并完成向<code>MapperRegistry</code>的注册。</p><pre><code class="java">  private void mapperElement(XNode parent) throws Exception {    if (parent != null) {      //处理&lt;mappers&gt;的子节点      for (XNode child : parent.getChildren()) {        //处理&lt;package&gt;节点        if (&quot;package&quot;.equals(child.getName())) {          String mapperPackage = child.getStringAttribute(&quot;name&quot;);          //扫描指定的包，并向MapperRegistry注册Mapper接口          configuration.addMappers(mapperPackage);        } else {          //获取&lt;mapper&gt;节点的resource、url、class属性，这三个属性是互斥的          String resource = child.getStringAttribute(&quot;resource&quot;);          String url = child.getStringAttribute(&quot;url&quot;);          String mapperClass = child.getStringAttribute(&quot;class&quot;);          //如果&lt;mapper&gt;节点指定了resource或者url属性，则创建XMLMapperBuilder对象，并通过该对象解析resource或url属性指定的Mapper配置文件          if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {            ErrorContext.instance().resource(resource);            InputStream inputStream = Resources.getResourceAsStream(resource);            //创建XMLMapperBuilder对象，解析映射配置文件            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());            mapperParser.parse();          } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {            ErrorContext.instance().resource(url);            InputStream inputStream = Resources.getUrlAsStream(url);            //创建XMLMapperBuilder对象，解析映射配置文件            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());            mapperParser.parse();          } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);            //如果&lt;mapper&gt;节点指定了class属性，则向MapperRegistry注册该Mapper接口            configuration.addMapper(mapperInterface);          } else {            throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);          }        }      }    }  }</code></pre><p><code>Mybatis</code>初始化过程中对<code>mybatis-config.xml</code>配置文件的解析过程到这里也就结束了，<a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82/Mybatis%E5%88%9D%E5%A7%8B%E5%8C%96(%E4%BA%8C).html" target="_blank" rel="noopener">Mybatis初始化（二）</a>会接续介绍，介绍<code>Mybatis</code>对映射文件的解析过程。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>核心处理层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射工具箱</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E5%8F%8D%E5%B0%84%E5%B7%A5%E5%85%B7%E7%AE%B1.html</url>
    
    <content type="html"><![CDATA[<h1 id="反射工具箱"><a href="#反射工具箱" class="headerlink" title="反射工具箱"></a>反射工具箱</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​        Mybatis在进行参数处理、结果集映射等操作时，会涉及大量的反射操作。Java中的反射虽然功能强大，但是代码编写起来比较复杂容易出错，为了简化反射操作的相关代码，Mybatis提供了专门的反射模块，该模块位于<code>org.apache.ibatis.reflection</code>包中，它对常见的反射操作做了封装，提供了更加简洁方便的反射API。</p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126092626-rve1an.png!github_blog" srcset="undefined" style="zoom:67%;" /><h1 id="2-Reflector-amp-ReflectorFactory"><a href="#2-Reflector-amp-ReflectorFactory" class="headerlink" title="2. Reflector&amp;ReflectorFactory"></a>2. Reflector&amp;ReflectorFactory</h1><h2 id="2-1-Reflector"><a href="#2-1-Reflector" class="headerlink" title="2.1. Reflector"></a>2.1. Reflector</h2><p>​         <code>Reflector</code>是<code>Mybatis</code>中反射模块的基础，每个<code>Reflector</code>对象都对应一个类，在Reflector中缓存了反射操作需要使用的类的元信息。Reflector中各个字段的含义如下所示：</p><pre><code class="java">/**   * 对应类的类型   */  private final Class&lt;?&gt; type;  /**   * 可读属性的名称集合，可读属性就是存在相应的getter方法的属性，初始值为空数组   */  private final String[] readablePropertyNames;  /**   * 可写属性的名称集合，可写属性就是存在相应setter方法的属性，初始值为空数组   */  private final String[] writablePropertyNames;  /**   * 记录了属性相应的setter方法，key是属性名称，value是Invoke对象，它是对setter方法对应Method对象的封装，后面会详细介绍   */  private final Map&lt;String, Invoker&gt; setMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法集合，key是属性名称，value是Invoke对象，   */  private final Map&lt;String, Invoker&gt; getMethods = new HashMap&lt;&gt;();  /**   * 记录了属性相应的setter方法的参数值类型，key是属性名称，value是setter方法的参数类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; setTypes = new HashMap&lt;&gt;();  /**   * 记录了属性相应的getter方法的返回值类型，key是属性名称，value是getter方法的返回值类型   */  private final Map&lt;String, Class&lt;?&gt;&gt; getTypes = new HashMap&lt;&gt;();  /**   * 记录了默认的构造方法   */  private Constructor&lt;?&gt; defaultConstructor;  /**   * 记录了所有属性名称的集合   */  private Map&lt;String, String&gt; caseInsensitivePropertyMap = new HashMap&lt;&gt;();</code></pre><p>​        在<code>Reflector</code>的构造方法中会解析指定的<code>Class</code>对象，并填充上述集合，具体实现如下所示：</p><pre><code class="java">/**   * 此构造方法中会解析指定的Class对象，并填充上述集合   * @param clazz 需要解析的Class对象   */  public Reflector(Class&lt;?&gt; clazz) {    //初始化type字段    type = clazz;    //查找clazz的默认构造方法（无参构造方法），具体实现是通过反射遍历所有构造方法    addDefaultConstructor(clazz);    //处理clazz中的getter方法，填充getMethods集合和getTypes集合    addGetMethods(clazz);    //处理clazz中的setter方法，填充setMethods集合和setTypes集合    addSetMethods(clazz);    //处理没有getter/setter方法的字段    addFields(clazz);    //根据getMethods和setMethods集合，初始化可读、可写属性的名称集合    readablePropertyNames = getMethods.keySet().toArray(new String[0]);    writablePropertyNames = setMethods.keySet().toArray(new String[0]);    //初始化caseInsensitivePropertyMap，其中记录了所有大写格式的属性名称    for (String propName : readablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }    for (String propName : writablePropertyNames) {      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);    }  }</code></pre><p>​        以上代码中<code>addDefaultConstructor(clazz);</code>很是简单，所以没有必要去分析这个方法，其次就是<code>addGetMethods(clazz);</code>和<code>addSetMethods(clazz);</code>方法，<code>Reflector.addGetMethods()</code>方法主要腹泻解析类中定义的<code>getter</code>方法，<code>Reflector.addSetMethods()</code>方法负责解析类中的<code>setter</code>方法，两者的逻辑类似，这里以<code>addSetMethods(clazz);</code>方法为例进行介绍，<code>addSetMethods()</code>方法不做详细介绍，<code>Reflector.addGetMethods()</code>主要有如下三个核心步骤：</p><pre><code class="java">/**   * 负责解析类中的get方法   * @param clazz   */  private void addGetMethods(Class&lt;?&gt; clazz) {    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = new HashMap&lt;&gt;();    /**     * 1. 调用{@link Reflector#getClassMethods(Class)} 方法获取当前类以及其父类中定义的所有方法的唯一签名以及相应的Method对象。     */    Method[] methods = getClassMethods(clazz);    /**     * 2. 按照JavaBean的规范，从Reflector#getClassMethods(Class)方法返回的Methods数组中查找该类中定义的getter方法，     *    将其记录在conflictingGetters集合中，conflictingGetters集合（ Map&lt;String, List&lt;Method&gt;&gt;类型）的key为属性名称，value是该属性对应的getter方法集合。     *     *    2.1. 具体步骤     *      2.1.1. 得到所有的get方法，（参数类别为空，标志是get的方法）；     *      2.1.2. 将得到的get方法添加到方法冲突集合中；     *          例如：父类 public List&lt;User&gt; getUserList(); 子类 public ArrayList&lt;User&gt; getUserList();     *               在进行{@link Reflector#getClassMethods(Class)}中的{@link Reflector#getSignature(Method)}返回结果是：     *               java.util.List#getUserList和java.util.ArrayList#getUserList，即得到两个方法签名，在{@link Reflector#addUniqueMethods(Map, Method[])}     *               方法中会被认为是两个不同的方法添加到 uniqueMethods集合中，这显然不是我们想要的结果。     *     *  所以后续步骤3 会去解决这种Getter方法的冲突。     *     *  (lambda表达式 :filter forEach )     */    Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));    /**     * 3. 解决Getter冲突     *   1. 为什么会产生冲突呢？     *      步骤2已经解释过为什么会产生冲突了。     *   2. 解决方式是什么？     */    resolveGetterConflicts(conflictingGetters);  }</code></pre><ul><li><p>首先，调用<code>Reflector.getClassMethods()</code>方法获取当前类及其父类中定义的所以方法的唯一签名以及相应的<code>Methods</code>对象。</p><pre><code class="java">private Method[] getClassMethods(Class&lt;?&gt; clazz) {    Map&lt;String, Method&gt; uniqueMethods = new HashMap&lt;&gt;();    Class&lt;?&gt; currentClass = clazz;    while (currentClass != null &amp;&amp; currentClass != Object.class) {      //记录currentClass这个类中定义的全部方法      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());      // we also need to look for interface methods -      // because the class may be abstract      // 记录接口中定义的方法      Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();      for (Class&lt;?&gt; anInterface : interfaces) {        addUniqueMethods(uniqueMethods, anInterface.getMethods());      }      //获取父类，继续while循环      currentClass = currentClass.getSuperclass();    }    Collection&lt;Method&gt; methods = uniqueMethods.values();    //转换成Methods方法数组返回    return methods.toArray(new Method[0]);  }</code></pre><p>在<code>Reflector.addUniqueMethods()</code>方法中会为每个方法生成唯一签名，并记录到<code>uniqueMethods</code>集合中，具体实现如下所示：</p><pre><code class="java"> /**   * 为每个方法生成一个唯一签名，并记录到uniqueMethods集合中   * @param uniqueMethods   * @param methods   */  private void addUniqueMethods(Map&lt;String, Method&gt; uniqueMethods, Method[] methods) {    for (Method currentMethod : methods) {      if (!currentMethod.isBridge()) {        /**         * 通过{@link Reflector#getSignature(Method)}方法得到方法的签名是：返回值类型#方法名称：参数类型列表。         * 例如： Reflector.getSignature(Method)的方法签名是：java.lang.String#getSignature:java.lang.reflect.Method         * 通过Reflector.getSignature(Method)方法得到的方法签名是全局唯一的，可以作为该方法的唯一标识         */        String signature = getSignature(currentMethod);        // check to see if the method is already known        // if it is known, then an extended class must have        // overridden a method        /**         * 检查是否添加过该方法，如果添加过，就无须在向uniqueMethods中添加该方法了。         * 其实这个段代码，如果细品有另一种意思：         *    因为addUniqueMethods方法在{@link Reflector#getClassMethods(Class)}中的while循环被调用了，一次循环被调用两次，         *    这两次调用：先是子类调用，然后是父类接口调用，         * 所以这里检查是否添加过该方法的另一层含义是：         *    检测是否在子类中已经添加过该方法，如果在子类中添加过，则表示子类覆盖了该方法，无须再向uniqueMethods集合中添加该方法了。         *         */        if (!uniqueMethods.containsKey(signature)) {          //记录该签名和方法的对应关系          uniqueMethods.put(signature, currentMethod);        }      }    }  }</code></pre></li><li><p>然后，按照<code>JavaBean</code>的规范，从<code>Reflector.getClassMethods()</code>返回的Method数组中查找该类中定义的<code>getter</code>方法（具体哪些方法算是<code>getter</code>方法，后面会详细介绍），将其记录到<code>conflictingGetters</code>集合中。<code>conflictingGetters</code>集合（<code>Map&lt;String, List&lt;Method&gt;&gt;</code>类型）的<code>key</code>是属性名称，<code>value</code>是该属性对应的<code>getter</code>方法集合。</p><pre><code class="java">//Reflector.javaArrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == 0 &amp;&amp; PropertyNamer.isGetter(m.getName()))      .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));</code></pre><pre><code class="java">//Reflector.java/**   * 添加方法冲突   * @param conflictingMethods   * @param name   * @param method   *   */  private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) {    if (isValidPropertyName(name)) {      /**       * {@link Map#computeIfAbsent(Object, Function)}       * @see red.reksai.reflection.ComputeIfAbsentTest   map jdk1.8新特性       */      List&lt;Method&gt; list = conflictingMethods.computeIfAbsent(name, k -&gt; new ArrayList&lt;&gt;());      list.add(method);    }  }</code></pre><pre><code class="java">//PropertyNamer.java/**   * 根据Javabean的规范，获取对应的属性名称   * @param name   * @return   */  public static String methodToProperty(String name) {    if (name.startsWith(&quot;is&quot;)) {      name = name.substring(2);    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {      name = name.substring(3);    } else {      throw new ReflectionException(&quot;Error parsing property name &#39;&quot; + name + &quot;&#39;.  Didn&#39;t start with &#39;is&#39;, &#39;get&#39; or &#39;set&#39;.&quot;);    }    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {      name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);    }    return name;  }</code></pre></li><li><p>当子类覆盖了父类的getter方法且返回值发生变化时，在步骤1中就会产生两个签名不用的方法。</p><ul><li>例如：</li></ul><pre><code class="java">import org.apache.ibatis.reflection.Reflector;import java.util.ArrayList;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/26 10:19 */public class ReflectorTest {  public static void main(String[] args) {    Reflector reflector = new Reflector(User.class);    System.out.println(reflector);  }}class  User extends Person{  public User() {  }  public User(String userName, String passWord) {    this.userName = userName;    this.passWord = passWord;  }  private String userName ;  private String passWord ;  public String getUserName() {    return userName;  }  public void setUserName(String userName) {    this.userName = userName;  }  public String getPassWord() {    return passWord;  }  public void setPassWord(String passWord) {    this.passWord = passWord;  }  public boolean isStatus() {    return super.getStatus() ;  }  @Override  public void setStatus(boolean status) {    super.setStatus(status);  }  @Override  public ArrayList&lt;Items&gt; getList() {    return (ArrayList&lt;Items&gt;) super.getList();  }  @Override  public void setList(List&lt;Items&gt; list) {    super.setList(list);  }}class Person {  private List&lt;Items&gt; list;  private boolean status ;  public boolean getStatus() {    return status;  }  public void setStatus(boolean status) {    this.status = status;  }  public List&lt;Items&gt; getList() {    return list;  }  public void setList(List&lt;Items&gt; list) {    this.list = list;  }  public Person() {  }  public Person(List&lt;Items&gt; list) {    this.list = list;  }}class Items{  private String itmeId;  private String itmeName ;}</code></pre><ul><li>在以下位置打断点</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233022-6FOt8I.png!github_blog" srcset="undefined" alt=""></p><ul><li>观察conflictingGetters集合中的值，如下所示：</li></ul><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191126233326-2wTK6y.png!github_blog" srcset="undefined" alt=""></p><p>其中属性名称为<code>list</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，这就是因为<code>User</code>在覆盖<code>Person</code>中的<code>getList()</code>方法是返回值从<code>List</code>变成了<code>ArrayList</code>，又因为生成方法签名的规则如下所示，所以就造成了有两个不同方法签名的方法被添加到了<code>uniqueMethods</code>集合中，这不是我们想要的结果。</p><pre><code class="java">// Reflector.java/**   * 生成方法签名   * @param method   * @return   */  private String getSignature(Method method) {    StringBuilder sb = new StringBuilder();    Class&lt;?&gt; returnType = method.getReturnType();    if (returnType != null) {      sb.append(returnType.getName()).append(&#39;#&#39;);    }    sb.append(method.getName());    Class&lt;?&gt;[] parameters = method.getParameterTypes();    for (int i = 0; i &lt; parameters.length; i++) {      sb.append(i == 0 ? &#39;:&#39; : &#39;,&#39;).append(parameters[i].getName());    }    return sb.toString();  }</code></pre><p>其中属性为<code>status</code>对应的<code>getter</code>方法的集合中有两个<code>Method</code>，一个是父类中的<code>boolean getStatus()</code>，另一个是子类中的 <code>boolean isStatus()</code>（涉及到JavaBean规范），说白了此时<code>uniqueMethods</code>集合中也有两个，这也不是我们想要的结果。</p></li><li><p>所以步骤3会调用<code>Reflector.resolveGetterConflicts(conflictingGetters)</code>方法对步骤2中这种覆写的情况进行处理，同时会将处理得到的<code>getter</code>方法记录到<code>getMethods</code>集合中，并将其返回值类型填充到<code>getTypes</code>集合中，<code>Reflector.resolveGetterConflicts()</code>方法的具体实现如下所示：</p></li></ul><pre><code class="Java"> //Reflector.java /**   * 解决get方法的冲突，同时会将处理得到的getter方法记录到getMethods集合中，并将其返回值类型填充到getTypes集合中   * @param conflictingGetters   */  private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) {    //遍历conflictingGetters集合    for (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) {      //优胜Method对象      Method winner = null;      //方法名称      String propName = entry.getKey();      boolean isAmbiguous = false;      // candidate 候选Method对象      for (Method candidate : entry.getValue()) {        //如果优胜对象为空，这时候将候选对象复制给优胜对象        if (winner == null) {          winner = candidate;          // continue是跳过当次循环中剩下的语句，执行下一次循环          continue;        }        //获取优胜者返回值类型        Class&lt;?&gt; winnerType = winner.getReturnType();        //获取候选者返回值类型        Class&lt;?&gt; candidateType = candidate.getReturnType();        /**         * 如果返回值类型相同，就要判断返回值是不是boolean？为什么要判断是不是boolean呢？         */        if (candidateType.equals(winnerType)) {          //如果返回值不是boolean直接          if (!boolean.class.equals(candidateType)) {            isAmbiguous = true;            //break只能跳出1层循环            break;          } else if (candidate.getName().startsWith(&quot;is&quot;)) {            winner = candidate;          }        }        /**         * @see red.reksai.javabase.IsAssignableFromTest         * 判断返回值类型有三种情况：         *  1. 候选者是优胜者的父类，不做任何操作，最终返回子类就行         *  2. 优胜者是候选者的父类，这时候先要将候选者赋值给优胜者，然后返回         *  3. 返回值相同，二义性，         */        else if (candidateType.isAssignableFrom(winnerType)) {          // OK getter type is descendant        } else if (winnerType.isAssignableFrom(candidateType)) {          winner = candidate;        } else {          isAmbiguous = true;          break;        }      }      //该字段只有一个getter方法，直接添加到getMethods集合并填充getTypes集合      addGetMethod(propName, winner, isAmbiguous);    }  }</code></pre><p>正如上面描述的那样，在<code>Reflector.addGetMethod(propName, winner, isAmbiguous);</code>方法中完成了对<code>getMethods</code>集合和<code>getType</code>集合的填充，具体实现如下所示：</p><pre><code class="java">  private void addGetMethod(String name, Method method, boolean isAmbiguous) {    /**     * 验证：     *    1. 如果有含糊不清的直接报错，     *    2. 如果验证通过，则进行方法的封装     */    MethodInvoker invoker = isAmbiguous        ? new AmbiguousMethodInvoker(method, MessageFormat.format(            &quot;Illegal overloaded getter method with ambiguous type for property &#39;&#39;{0}&#39;&#39; in class &#39;&#39;{1}&#39;&#39;. This breaks the JavaBeans specification and can cause unpredictable results.&quot;,            name, method.getDeclaringClass().getName()))        : new MethodInvoker(method);    getMethods.put(name, invoker);    /**     * 获取返回值的Type ，{@link TypeParameterResolver}     */    Type returnType = TypeParameterResolver.resolveReturnType(method, type);    getTypes.put(name, typeToClass(returnType));  }</code></pre><h2 id="2-2-TypeParameterResolver"><a href="#2-2-TypeParameterResolver" class="headerlink" title="2.2. TypeParameterResolver"></a>2.2. TypeParameterResolver</h2><h2 id="2-3-ObjectFactory"><a href="#2-3-ObjectFactory" class="headerlink" title="2.3. ObjectFactory"></a>2.3. ObjectFactory</h2><p><code>Mybatis</code>中有很多模块会使用到<code>ObjectFactory</code>接口，该接口提供了多个<code>create()</code>方法的重载，通过这些方法可以创建指定类型的对象，<code>ObjectFactory</code>接口的定义如下所示：</p><pre><code class="java">/** * Mybatis中有很多模块会使用到ObjectFactory接口，该接口提供了多个create()方法的重载， * 通过这些方create()方法可以创建指定类型的对象。 * @see DefaultObjectFactory * MyBatis uses an ObjectFactory to create all needed new Objects. * * @author Clinton Begin */public interface ObjectFactory {  /**   * 设置配置信息   * Sets configuration properties.   * @param properties configuration properties   */  default void setProperties(Properties properties) {    /**     *   空操纵：说白了，如果要继承ObjectFactory，不仅要定义Properties 属性，还有再提供一个getProperties()的方法     *   e.g. {@link red.reksai.mybatissample.objectfactory.ExampleObjectFactory}（我自定义的测试用例）     *   {@link org.apache.ibatis.submitted.global_variables_defaults.SupportClasses.CustomObjectFactory}(官方测试用例)     *   同时在mybatis-config.xml添加如下配置：     *   &lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&gt;     *       &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;     *   &lt;/objectFactory&gt;     *   这样可以拿到property的值。     */    // NOP  }  /**   * 通过无参构造器创建指定类的对象   * Creates a new object with default constructor.   * @param type Object type   * @return   */  &lt;T&gt; T create(Class&lt;T&gt; type);  /**   * 根据参数列表，从指定的类型中选择合适的构造器创建对象   * Creates a new object with the specified constructor and params.   * @param type Object type   * @param constructorArgTypes Constructor argument types   * @param constructorArgs Constructor argument values   * @return   */  &lt;T&gt; T create(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs);  /**   * 检测指定类型是否是集合类型，主要处理java.util.Collection及其子类   * Returns true if this object can have a set of other objects.   * It&#39;s main purpose is to support non-java.util.Collection objects like Scala collections.   *   * @param type Object type   * @return whether it is a collection or not   * @since 3.1.0   */  &lt;T&gt; boolean isCollection(Class&lt;T&gt; type);}</code></pre><p><code>DefaultObjectFactory</code>是<code>Mybatis</code>提供的<code>ObjectFactory</code>接口的唯一实现，它是一个反射工厂，其<code>create()</code>方法通过调用<code>instanceClass()</code>方法实现。<code>DefaultObjectFactory.instanceClass()</code>方法会根据传入的参数列表选择合适的构造函数实例化对象，具体实现如下：</p><pre><code class="java">private  &lt;T&gt; T instantiateClass(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) {    try {      Constructor&lt;T&gt; constructor;      //通过无参构造器创建对象      if (constructorArgTypes == null || constructorArgs == null) {        constructor = type.getDeclaredConstructor();        try {          return constructor.newInstance();        } catch (IllegalAccessException e) {          if (Reflector.canControlMemberAccessible()) {            constructor.setAccessible(true);            return constructor.newInstance();          } else {            throw e;          }        }      }      //根据指定的参数列表查找构造函数，并实例化对象      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(new Class[constructorArgTypes.size()]));      try {        return constructor.newInstance(constructorArgs.toArray(new Object[constructorArgs.size()]));      } catch (IllegalAccessException e) {        if (Reflector.canControlMemberAccessible()) {          constructor.setAccessible(true);          return constructor.newInstance(constructorArgs.toArray(new Object[constructorArgs.size()]));        } else {          throw e;        }      }    } catch (Exception e) {      String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList)          .stream().map(Class::getSimpleName).collect(Collectors.joining(&quot;,&quot;));      String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList)          .stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;));      throw new ReflectionException(&quot;Error instantiating &quot; + type + &quot; with invalid types (&quot; + argTypes + &quot;) or values (&quot; + argValues + &quot;). Cause: &quot; + e, e);    }  }</code></pre><p>除了使用<code>Mybatis</code>提供的<code>DefaultObjectFactory</code>实现，我们还可以在<code>mybatis-config.xml</code>配置文件中指定自定义的<code>ObjectFactory</code>接口实现类，从而实现功能上的扩展，在后面介绍<code>Mybatis</code>初始化流程的时候，还会提到该扩展点。</p><h2 id="2-4-Property工具集"><a href="#2-4-Property工具集" class="headerlink" title="2.4. Property工具集"></a>2.4. Property工具集</h2><p>本小节主要介绍反射模块中使用到的三个属性工具类，分别是<code>PropertyTokenizer</code>、<code>PropertyNamer</code>和<code>PropertyCopier</code>。</p><hr><p><strong>此段我暂时也不知道怎么去解释，也许是后续学习能解释这个问题吧。</strong></p><p>在使用<code>Mybatis</code>的过程中，我们会经常碰到一些属性表达式，例如，在查询某用户（<code>User</code>）的订单（<code>Order</code>）的结果集如下表所示：</p><table><thead><tr><th align="center">user_name</th><th align="center">order</th><th align="center">item1</th><th align="center">item2</th><th align="center">. . .</th></tr></thead><tbody><tr><td align="center">Mary</td><td align="center">12460</td><td align="center">IPhone</td><td align="center">Computer</td><td align="center"></td></tr><tr><td align="center">Lisa</td><td align="center">36546</td><td align="center">MX</td><td align="center">Wather</td><td align="center"></td></tr><tr><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td><td align="center">. . .</td></tr></tbody></table><hr><h3 id="2-4-1-PropertyTokenizer"><a href="#2-4-1-PropertyTokenizer" class="headerlink" title="2.4.1. PropertyTokenizer"></a>2.4.1. PropertyTokenizer</h3><p><code>PropertyTokenizer</code>是一个属性分词器工具，它继承了<code>Iterator</code>接口，它可以迭代处理嵌套的多层表达式。</p><p>由“<code>*</code>”和“<code>[]</code>”组成的表达式是由<code>PropertyTokenizer</code>进行解析的，<code>PropertyTokenizer</code>中各个字段的含义如下所示：</p><pre><code class="java">// fullName = &quot;order[0].items[0].name&quot;  // String[] split = {&quot;order[0]&quot; ,&quot;item[0]&quot; ,&quot;name&quot;}  /**   * 当前表达式的名称:   * e.g. order   *      items   *      name   */  private String name;  /**   * 当前表达式的索引名   * e.g. order[0]   *      items[0]   *      name   */  private final String indexedName;  /**   * 索引下标   * e.g. [0]   *      [0]   *      null   */  private String index;  /**   * 子表达式   * e.g. items[0].name   *      name   *      null   */  private final String children;</code></pre><p>核心方法有三个分别是：</p><ul><li><code>PropertyTokenizer()</code></li></ul><pre><code class="java">/**   * 解析表达式   * @param fullname  要解析的表达式   *                  e.g. order[0].items[0].name   */  public PropertyTokenizer(String fullname) {    //查找&quot;.&quot;的位置    int delim = fullname.indexOf(&#39;.&#39;);    if (delim &gt; -1) {      //初始化name      name = fullname.substring(0, delim);      //初始化children      children = fullname.substring(delim + 1);    } else {      name = fullname;      children = null;    }    //初始化indexName    indexedName = name;    //查找&quot;[&quot;的位置，如果存在，最后要把上面步骤赋值给name中的&quot;[]&quot;去掉    delim = name.indexOf(&#39;[&#39;);    if (delim &gt; -1) {      //初始化index      index = name.substring(delim + 1, name.length() - 1);      //重新赋值给name      name = name.substring(0, delim);    }  }</code></pre><ul><li><code>hasNext()</code></li></ul><pre><code class="java">  /**   * 判断是否还有children   * @return   */  @Override  public boolean hasNext() {    return children != null;  }</code></pre><ul><li><code>next()</code></li></ul><pre><code class="java">  /**   * 继续解析孩子节点   * @return   */  @Override  public PropertyTokenizer next() {    return new PropertyTokenizer(children);  }</code></pre><p>例子：</p><pre><code class="java">import org.apache.ibatis.reflection.property.PropertyTokenizer;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/29 11:12 */public class PropertyTokenizerTest {  public static void main(String[] args) {    String fullName = &quot;orders[0.items[0].name&quot; ;    doTokenizer(fullName);  }  private static void doTokenizer(String name){    PropertyTokenizer propertyTokenizer = new PropertyTokenizer(name);    System.out.println(propertyTokenizer.getIndexedName());    System.out.println(propertyTokenizer.getName());    System.out.println(propertyTokenizer.getIndex());    System.out.println(propertyTokenizer.getChildren());    System.out.println(&quot;.................&quot;);    String children = propertyTokenizer.getChildren();    if (propertyTokenizer.hasNext()){      doTokenizer(children);    }  }}</code></pre><p>运行结果：</p><pre><code>orders[0ordersitems[0].name.................items[0]items0name.................namenamenullnull.................</code></pre><h3 id="2-4-2-PropertyNamer"><a href="#2-4-2-PropertyNamer" class="headerlink" title="2.4.2. PropertyNamer"></a>2.4.2. PropertyNamer</h3><h3 id="2-4-3-PropertyCopier"><a href="#2-4-3-PropertyCopier" class="headerlink" title="2.4.3. PropertyCopier"></a>2.4.3. PropertyCopier</h3><h2 id="2-5-MetaClass"><a href="#2-5-MetaClass" class="headerlink" title="2.5. MetaClass"></a>2.5. MetaClass</h2><h3 id="2-5-1-主要方法详解"><a href="#2-5-1-主要方法详解" class="headerlink" title="2.5.1. 主要方法详解"></a>2.5.1. 主要方法详解</h3><p><code>MetaClass</code>通过<code>Reflector</code>和<code>PropertyTokenizer</code>组合使用，实现了对复杂的属性表达式的解析，并实现了获取指定属性描述信息的功能。<code>MetaClass</code>中各个字段的含义如下：</p><pre><code class="java">  /**   * ReflectorFactory对象，用于缓存Reflector对象   */  private final ReflectorFactory reflectorFactory;  /**   *   在创建MetaClass时会指定一个类，该Reflector对象会用于记录该类相关信息   */  private final Reflector reflector;</code></pre><p><code>MetaClass</code>的构造函数中会为指定的<code>Class</code>创建相应的<code>Reflector</code>对象，并用其初始化<code>MetaClass.reflector</code>字段，具体代码如下所示：</p><pre><code class="java">  /**   * 此构造方法是一个private   * @param type   * @param reflectorFactory     */  private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {    this.reflectorFactory = reflectorFactory;    //创建reflector对象，默认使用的是DefaultReflectorFactory.findForClass()方法    this.reflector = reflectorFactory.findForClass(type);  }  /**   * 使用静态方法创建MetaClass对象   * @param type   * @param reflectorFactory   * @return   */  public static MetaClass forClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) {    return new MetaClass(type, reflectorFactory);  }</code></pre><p><code>MetaClass</code>中比较重要的是<code>findProperty()</code>方法，它是通过调用<code>MetaClass.buildProperty()</code>方法实现的：</p><pre><code class="Java">//MetaClass.java    /**   * 只查找&quot;.&quot;导航的属性，并且没有检测下标   * @param name 要查找的属性名称   * @return   */  public String findProperty(String name) {    //委托给buildProperty()方法实现    StringBuilder prop = buildProperty(name, new StringBuilder());    return prop.length() &gt; 0 ? prop.toString() : null;  }</code></pre><pre><code class="java"> private StringBuilder buildProperty(String name, StringBuilder builder) {    //解析表达式    PropertyTokenizer prop = new PropertyTokenizer(name);    //判断是否还有子表达式    if (prop.hasNext()) {      String propertyName = reflector.findPropertyName(prop.getName());      if (propertyName != null) {        builder.append(propertyName);        builder.append(&quot;.&quot;);        //查找属性所对应的MetaClass        MetaClass metaProp = metaClassForProperty(propertyName);        metaProp.buildProperty(prop.getChildren(), builder);      }    } else {      String propertyName = reflector.findPropertyName(name);      if (propertyName != null) {        builder.append(propertyName);      }    }    return builder;  }</code></pre><p>有上述代码可以看出：findPropertory()方法值查找“.”导航的属性，并没有检测下标。</p><p>这里以解析User类中的tele.contry这个属性表达式为例解释上述过程：</p><ol><li><p>首先使用findPropertory(“tele.contry”)；</p></li><li><p>MetaClass.buildPropertry(“tele.country”,stringBuilder)；</p></li><li><p>接着使用PropertryTokenizer解析数据，发现还有子表达式：country，说明此属性表达式所属的类不是当前了，需要查找此属性属于的类；</p></li><li><p>所以要通过MetaClass.metaClassForPropertry(“tele”)，获取到对应的实体类，其中使用到了Reflector.getGetterType()得到了返回值的类型，然后使用MetaClass.forClass()返回返回值对应的元类。</p></li><li><p>递归调用2。</p></li></ol><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129152716-h9Os7u.png!github_blog" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153239-L5s0UA.png!github_blog" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153351-r3eIeh.png!github_blog" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153624-PBw7Sr.png!github_blog" srcset="undefined" alt=""></p><p><img src="https://gnehcgnaw.oss-cn-hongkong.aliyuncs.com/blog/20191129153949-KaKXgI.png!github_blog" srcset="undefined" alt=""></p><h3 id="2-5-2-测试用例"><a href="#2-5-2-测试用例" class="headerlink" title="2.5.2. 测试用例"></a>2.5.2. 测试用例</h3><pre><code class="java">package red.reksai.reflection;import org.apache.ibatis.reflection.DefaultReflectorFactory;import org.apache.ibatis.reflection.MetaClass;import org.junit.jupiter.api.Test;import red.reksai.reflection.entity.User;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/29 10:07 */public class MetaClassTest {  @Test  public  void test() {    MetaClass metaClass = MetaClass.forClass(User.class, new DefaultReflectorFactory());    System.out.println(metaClass.findProperty(&quot;tele.country&quot;));     //tele.country    System.out.println(metaClass.getGetterType(&quot;tele.country&quot;));    // class java.lang.String    System.out.println(metaClass.hasGetter(&quot;tete.country&quot;));    //true    System.out.println(metaClass.getGetterType(&quot;orders[0].items[0]&quot;));    // class red.reksai.reflection.entity.Item  }}</code></pre><h2 id="2-6-ObjectWrapper"><a href="#2-6-ObjectWrapper" class="headerlink" title="2.6. ObjectWrapper"></a>2.6. ObjectWrapper</h2><h2 id="2-7-MetaObject"><a href="#2-7-MetaObject" class="headerlink" title="2.7. MetaObject"></a>2.7. MetaObject</h2><h2 id="2-8-ParamNameResolver"><a href="#2-8-ParamNameResolver" class="headerlink" title="2.8. ParamNameResolver"></a>2.8. ParamNameResolver</h2><p><code>ParamNameResolver</code>是参数名称解析器，把传入的实参，解析成对象，分为两种：一种是不加<code>@Param</code>注解的；一种是加了注解的，<code>Mybatis</code>源码中的使用场景在后续介绍，使用的类有：</p><ol><li><a href="https://gnehcgnaw.github.io/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/binding%E6%A8%A1%E5%9D%97.html#4-2-3-convertArgsToSqlCommandParam" target="_blank" rel="noopener">MapperMethod</a></li><li>ProviderSqlSource</li><li>Jdbc3KeyGenerator</li></ol><pre><code class="java">/** * 参数名称解析器 */public class ParamNameResolver {  /**   *   通用前缀，假如没有定义参数名称，最后在同一个方法的参数列表就是param1 、param2 一次类推。   */  public static final String GENERIC_NAME_PREFIX = &quot;param&quot;;  /**   * 参数的名称是有顺序的   * &lt;p&gt;   * The key is the index and the value is the name of the parameter.&lt;br /&gt;   * The name is obtained from {@link Param} if specified. When {@link Param} is not specified,   * the parameter index is used. Note that this index could be different from the actual index   * when the method has special parameters (i.e. {@link RowBounds} or {@link ResultHandler}).   * &lt;/p&gt;   * &lt;ul&gt;   * &lt;li&gt;aMethod(@Param(&quot;M&quot;) int a, @Param(&quot;N&quot;) int b) -&amp;gt; {{0, "M"}, {1, "N"}}&lt;/li&gt;   * &lt;li&gt;aMethod(int a, int b) -&amp;gt; {{0, "0"}, {1, "1"}}&lt;/li&gt;   * &lt;li&gt;aMethod(int a, RowBounds rb, int b) -&amp;gt; {{0, "0"}, {2, "1"}}&lt;/li&gt;   * &lt;/ul&gt;   */  private final SortedMap&lt;Integer, String&gt; names;  /**   *   参数是否被注解注释   */  private boolean hasParamAnnotation;  public ParamNameResolver(Configuration config, Method method) {    final Class&lt;?&gt;[] paramTypes = method.getParameterTypes();    final Annotation[][] paramAnnotations = method.getParameterAnnotations();    final SortedMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;();    int paramCount = paramAnnotations.length;    // get names from @Param annotations    for (int paramIndex = 0; paramIndex &lt; paramCount; paramIndex++) {      if (isSpecialParameter(paramTypes[paramIndex])) {        // skip special parameters        continue;      }      String name = null;      for (Annotation annotation : paramAnnotations[paramIndex]) {        if (annotation instanceof Param) {          hasParamAnnotation = true;          name = ((Param) annotation).value();          break;        }      }      if (name == null) {        // @Param was not specified.        if (config.isUseActualParamName()) {          name = getActualParamName(method, paramIndex);        }        if (name == null) {          // use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)          // gcode issue #71          name = String.valueOf(map.size());        }      }      map.put(paramIndex, name);    }    names = Collections.unmodifiableSortedMap(map);  }  private String getActualParamName(Method method, int paramIndex) {    return ParamNameUtil.getParamNames(method).get(paramIndex);  }  private static boolean isSpecialParameter(Class&lt;?&gt; clazz) {    return RowBounds.class.isAssignableFrom(clazz) || ResultHandler.class.isAssignableFrom(clazz);  }  /**   * Returns parameter names referenced by SQL providers.   */  public String[] getNames() {    return names.values().toArray(new String[0]);  }  /**   * &lt;p&gt;   * A single non-special parameter is returned without a name.   * Multiple parameters are named using the naming rule.   * In addition to the default names, this method also adds the generic names (param1, param2,   * ...).   * &lt;/p&gt;   */  public Object getNamedParams(Object[] args) {    final int paramCount = names.size();    if (args == null || paramCount == 0) {      return null;    }    // 没有加注解，并且只有一个参数的时候就返回第一个就就行，这样是为了节省性能    else if (!hasParamAnnotation &amp;&amp; paramCount == 1) {      return args[names.firstKey()];    }    /**     * 假如加了注解，返回的参数形式就有两套：     *  e.g.     *    @Param 这是一套     *    param1, param2, ...这是另一套     */    else {      final Map&lt;String, Object&gt; param = new ParamMap&lt;&gt;();      int i = 0;      for (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) {        param.put(entry.getValue(), args[entry.getKey()]);        // add generic param names (param1, param2, ...)        final String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + 1);        // ensure not to overwrite parameter named with @Param        if (!names.containsValue(genericParamName)) {          param.put(genericParamName, args[entry.getKey()]);        }        i++;      }      return param;    }  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析器模块</title>
    <link href="undefinedMybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html"/>
    <url>Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81%E5%B1%82/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%9D%97.html</url>
    
    <content type="html"><![CDATA[<h1 id="解析器模块"><a href="#解析器模块" class="headerlink" title="解析器模块"></a>解析器模块</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>​    解析器模块，对应的包是<code>parsing，</code>如下图所示：</p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191126003045-GKXnIt.png" srcset="undefined" style="zoom:50%;" /><p>解析器模块，主要提供了两个功能：</p><ul><li>对XPath进行封装，为Mybatis初始化时解析<code>mybatis-config.xml</code>配置文件以及<code>mapper</code>映射配置文件提供支持。</li><li>为处理动态SQL语句中的占位符提供支持。</li></ul><h1 id="2-XML解析方式"><a href="#2-XML解析方式" class="headerlink" title="2. XML解析方式"></a>2. XML解析方式</h1><p>在mybatis中涉及到多个XML配置文件，因此我们首先要介绍XML解析的相关内容。XML解析的常见的方式有三种：</p><ul><li>DOM（document object model）解析方式</li><li>SAX（simple api for xml）解析方式</li><li>Java6版本开始，JDK致辞的StAX（streaming api for xml）解析方式。</li></ul><p>DOM是基于树形结构的XML解析方式，它将整个XML文档读入内存并构建成一个DOM树,基于这棵树形结构对各个节点（node）进行操作。XML文档中的每一个成分都是一个节点：整个文档是一个文档节点，每个XML标签对应一个元素节点，包含在XML标签中的文本是文本节点，每一个XML属性是一个属性节点，注释属于注释节点。</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>解析后得到的树形结构为：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125100550-l1ZKVS.png" srcset="undefined" alt=""></p><h1 id="3-XPath"><a href="#3-XPath" class="headerlink" title="3. XPath"></a>3. XPath</h1><p>​        mybatis在初始化过程中处理mybatis-config.xml配置文件以及映射文件时，使用的是DOM解析方式，并结合XPath解析xml配置文件，正如前文所述，DOM会对整个XML文档加载到内存中形成树形数据结构，而xpth是一种为查询XML文档而设计的语言，它可以与DOM解析方式配合使用，实现对XML文档的解析。xpath之于XML就好比SQL语言之于数据库。</p><p>​        代码示例：</p><pre><code class="java">import org.apache.ibatis.io.Resources;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.ErrorHandler;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.xpath.*;import java.io.IOException;import java.io.InputStream;/** * XPath解析测试 {@link javax.xml.xpath.XPath} * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 10:11 */public class XPathTest {  public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException {    //创建DOM解析器工厂    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();    //开启验证    documentBuilderFactory.setValidating(true);    documentBuilderFactory.setNamespaceAware(false);    documentBuilderFactory.setIgnoringComments(true);    documentBuilderFactory.setIgnoringElementContentWhitespace(false);    documentBuilderFactory.setCoalescing(false);    documentBuilderFactory.setExpandEntityReferences(true);    //得到一个DOM解析器对象    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();    documentBuilder.setErrorHandler(new ErrorHandler() {      @Override      public void warning(SAXParseException exception) throws SAXException {        System.out.println(&quot;warning&quot; + exception.getMessage());      }      @Override      public void error(SAXParseException exception) throws SAXException {        System.out.println(&quot;error&quot; + exception.getMessage());      }      @Override      public void fatalError(SAXParseException exception) throws SAXException {        System.out.println(&quot;fatalError&quot; + exception.getMessage());      }    });    String resource = &quot;resources/xpath-demo.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    //解析xml    Document document = documentBuilder.parse(inputStream);    XPathFactory xPathFactory = XPathFactory.newInstance();    XPath xPath = xPathFactory.newXPath();    XPathExpression xPathExpression = xPath.compile(&quot;/configuration/mappers/mapper&quot;);    NodeList evaluate = (NodeList) xPathExpression.evaluate(document, XPathConstants.NODESET);    for (int i = 0; i &lt; evaluate.getLength() ; i++) {      Node node = evaluate.item(i);      String nodeName = node.getNodeName();      if ((&quot;mapper&quot;).equals(node.getNodeName())){        Node attributeNode = node.getAttributes().getNamedItem(&quot;resource&quot;);        String nodeValue1 = attributeNode.getNodeValue();        System.out.println(nodeName +&quot;......&quot;+nodeValue1);      }    }  }}</code></pre><p>运行结果：</p><pre><code class="java">mapper......org/mybatis/example/BlogMapper.xmlmapper......org/mybatis/example/UserMapper.xml</code></pre><h1 id="4-XPathParser"><a href="#4-XPathParser" class="headerlink" title="4. XPathParser"></a>4. XPathParser</h1><p>Mybatis提供的<code>org.apache.ibatis.parsing.XPathParser</code>类封装了前面涉及到的<code>XPath</code>、<code>Document</code>和<code>EntityResolver</code>，如图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125223756-R177Lc.png" srcset="undefined" alt=""></p><p>XPathParser中各个字段的含义和功能如下所示：</p><pre><code class="java">  /**   * xml document 对象   */  private final Document document;  /**   * 是否开启校验xml   */  private boolean validation;  /**   * 用于加载本地DTD文件   *   * xml实体解析器，默认情况下，对XML校验是，会基于xml文档开始位置定义的DTD文件或者XSD文件，   * 例如：   *    解析mybatis-config.xml配置文件时，会加载http://mybatis.org/dtd/mybatis-3-config.dtd这个DTD文件。   *    但是，如果如果每个应用启动都从网络加载该DTD文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，   *    还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，MyBatis自定义了EntityResolver   *    的实现，达到使用本地DTD文件，从而避免下载网络 DTD 文件的效果。   *   * @see org.apache.ibatis.builder.xml.XMLMapperEntityResolver   */  private EntityResolver entityResolver;  /**   * 变量 Properties对象   */  private Properties variables;  /**   * java XPath对象   *    用于查询xml中的节点和元素   */  private XPath xpath;</code></pre><p>默认情况下，对XML文档进行验证时，会根据XML文档开始位置指定的网址加载对应的<code>DTD</code>文件或者<code>XSD</code>文件。如果是解析<code>mybatis-config.xml</code>配置文件时，默认会加载<code>http://mybatis.org/dtd/mybatis-3-config.dtd</code>这个<code>DTD</code>文件。但是，如果如果每个应用启动都从网络加载该<code>DTD</code>文件，势必在弱网络下体验非常下，甚至说应用部署在无网络的环境下，还会导致下载不下来，那么就会出现XML校验失败的情况 ，所以，在实际场景下，<code>MyBatis</code>自定义了<code>EntityResolver</code>的实现，达到使用本地<code>DTD</code>文件，从而避免下载网络 <code>DTD</code> 文件的效果。<code>XMLMapperEntityResolver</code>是<code>mybatis</code>提供的<code>EntityResolver</code>接口的实现类，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125224446-8JnIIz.png" srcset="undefined" alt=""></p><p><code>EntityResolver</code>接口的核心是<code>resolveEntity()</code>方法，<code>XMLMapperEntityResolver</code>是实现如下所示：</p><pre><code class="java">package org.apache.ibatis.builder.xml;import java.io.IOException;import java.io.InputStream;import java.util.Locale;import org.apache.ibatis.io.Resources;import org.xml.sax.EntityResolver;import org.xml.sax.InputSource;import org.xml.sax.SAXException;/** * XML映射器实体解析器 * Offline entity resolver for the MyBatis DTDs. * * @author Clinton Begin * @author Eduardo Macarron */public class XMLMapperEntityResolver implements EntityResolver {  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD的SystemId   */  private static final String IBATIS_CONFIG_SYSTEM = &quot;ibatis-3-config.dtd&quot;;  private static final String IBATIS_MAPPER_SYSTEM = &quot;ibatis-3-mapper.dtd&quot;;  private static final String MYBATIS_CONFIG_SYSTEM = &quot;mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_SYSTEM = &quot;mybatis-3-mapper.dtd&quot;;  /**   * 指定mybatis-config.xml文件和映射文件对应的DTD文件的具体位置   */  private static final String MYBATIS_CONFIG_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-config.dtd&quot;;  private static final String MYBATIS_MAPPER_DTD = &quot;org/apache/ibatis/builder/xml/mybatis-3-mapper.dtd&quot;;  /**   * {@link #resolveEntity(String, String)}是{@link EntityResolver} 接口中定义的方法，具体实现如下所示：   *   * Converts a public DTD into a local one.   *   * @param publicId The public id that is what comes after &quot;PUBLIC&quot;   * @param systemId The system id that is what comes after the public id.   * @return The InputSource for the DTD   *   * @throws org.xml.sax.SAXException If anything goes wrong   */  @Override  public InputSource resolveEntity(String publicId, String systemId) throws SAXException {    try {      if (systemId != null) {        String lowerCaseSystemId = systemId.toLowerCase(Locale.ENGLISH);        /**         *  查找systemId指定的DTD文档，并调用{@link #getInputSource(String, String, String)}方法读取DTD文档         */        if (lowerCaseSystemId.contains(MYBATIS_CONFIG_SYSTEM) || lowerCaseSystemId.contains(IBATIS_CONFIG_SYSTEM)) {          return getInputSource(MYBATIS_CONFIG_DTD, publicId, systemId);        } else if (lowerCaseSystemId.contains(MYBATIS_MAPPER_SYSTEM) || lowerCaseSystemId.contains(IBATIS_MAPPER_SYSTEM)) {          return getInputSource(MYBATIS_MAPPER_DTD, publicId, systemId);        }      }      return null;    } catch (Exception e) {      throw new SAXException(e.toString());    }  }  /**   * 读取DTD文档并形成InputSource对象   * @param path  文件所在路径   * @param publicId    公共标志符   * @param systemId    systemId   * @return InputSource   */  private InputSource getInputSource(String path, String publicId, String systemId) {    InputSource source = null;    if (path != null) {      try {        InputStream in = Resources.getResourceAsStream(path);        source = new InputSource(in);        source.setPublicId(publicId);        source.setSystemId(systemId);      } catch (IOException e) {        // ignore, null is ok      }    }    return source;  }}</code></pre><p>介绍完<code>XMLMapperEntityResolver</code>之后，回到<code>XPathParser</code>的分析。在<code>XPathParser.createDocument()</code>方法中封装了前面介绍的创建<code>Document</code>对象的过程并触发了加载XML文档的过程，具体实现如下：</p><pre><code class="java">/**   * 调用这个方法之前一定要先调用{@link #commonConstructor(boolean, Properties, EntityResolver)}方法完成初始化。   * 将xml解析为Document对象   * @param inputSource   * @return   */  private Document createDocument(InputSource inputSource) {    // important: this must only be called AFTER common constructor    try {      //创建DocumentBuilderFactory对象      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();      //对DocumentBuilderFactory进行一系列的配置      factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);      factory.setValidating(validation);      factory.setNamespaceAware(false);      factory.setIgnoringComments(true);      factory.setIgnoringElementContentWhitespace(false);      factory.setCoalescing(false);      factory.setExpandEntityReferences(true);      //创建DocumentBuilder对象并进行配置      DocumentBuilder builder = factory.newDocumentBuilder();      //设置EntityResolver接口对象      builder.setEntityResolver(entityResolver);      builder.setErrorHandler(new ErrorHandler() {        //其中实现的ErrorHandler接口的方法都是空实现        @Override        public void error(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {          throw exception;        }        @Override        public void warning(SAXParseException exception) throws SAXException {          // NOP        }      });      //加载xml文件      return builder.parse(inputSource);    } catch (Exception e) {      throw new BuilderException(&quot;Error creating document instance.  Cause: &quot; + e, e);    }  }/**   * 通用构造：   *    就是通用的赋值操作，主要是的得到一个xpath解析器对document对象进行解析   * @param validation   * @param variables   * @param entityResolver   */  private void commonConstructor(boolean validation, Properties variables, EntityResolver entityResolver) {    this.validation = validation;    this.entityResolver = entityResolver;    this.variables = variables;    XPathFactory factory = XPathFactory.newInstance();    this.xpath = factory.newXPath();  }</code></pre><p><code>XPathParser</code>中提供了一系列的<code>eval*()</code>方法用于解析<code>boolean</code>、<code>short</code>、<code>long</code>、<code>int</code>、<code>String</code>、<code>Node</code>等类型的信息，它通过前面介绍代码中介绍的<code>XPath.evaluate()</code>方法查找指定路径的节点或属性，并进行相应的类型转换。具体的代码比较简单，就不贴出来了，这里需要注意的是<code>XPathParser.evalString()</code><br />方法，其中会调用<code>PropertyParser.parse()</code>方法处理节点中相应的默认值，具体实现如下所示：</p><pre><code class="java"> public String evalString(Object root, String expression) {    String result = (String) evaluate(expression, root, XPathConstants.STRING);    //处理节点中相应的默认值    result = PropertyParser.parse(result, variables);    return result;  }</code></pre><p>在<code>PropertyParser</code>中指定了是否开启默认值的功能以及默认的分隔符，相应字段如下所示：</p><pre><code class="java"> private static final String KEY_PREFIX = &quot;org.apache.ibatis.parsing.PropertyParser.&quot;;  /**   * 在mybatis-config.xml中的&lt;properties&gt;&lt;/properties&gt;节点下配置是否开启默认值功能的对应配置项   * The special property key that indicate whether enable a default value on placeholder.   * &lt;p&gt;   *   The default value is {@code false} (indicate disable a default value on placeholder)   *   If you specify the {@code true}, you can specify key and default value on placeholder (e.g. {@code ${db.username:postgres}}).   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_ENABLE_DEFAULT_VALUE = KEY_PREFIX + &quot;enable-default-value&quot;;  /**   * 配置占位符与默认值之间的默认分隔符的对应配置项   * The special property key that specify a separator for key and default value on placeholder.   * &lt;p&gt;   *   The default separator is {@code &quot;:&quot;}.   * &lt;/p&gt;   * @since 3.4.2   */  public static final String KEY_DEFAULT_VALUE_SEPARATOR = KEY_PREFIX + &quot;default-value-separator&quot;;  /**   * 默认情况下，关闭默认值选项   */  private static final String ENABLE_DEFAULT_VALUE = &quot;false&quot;;  /**   * 默认分隔符是冒号   */  private static final String DEFAULT_VALUE_SEPARATOR = &quot;:&quot;;</code></pre><p><code>PropertyParser.parse()</code>方法中会创建<code>GenericTokenParser解析器，</code>并将默认值的处理委托给<code>GenericTokenParser.parse()</code>方法，实现如下：</p><pre><code class="java">/**   * 当前方法中会创建{@link GenericTokenParser}解析器，并将默认值的处理委托给{@link GenericTokenParser#parse(String)}   * @param string   * @param variables   * @return   */  public static String parse(String string, Properties variables) {    VariableTokenHandler handler = new VariableTokenHandler(variables);    //创建GenericTokenParser对象，并指定其处理的占位符格式为&quot;${}&quot;    GenericTokenParser parser = new GenericTokenParser(&quot;${&quot;, &quot;}&quot;, handler);    return parser.parse(string);  }</code></pre><p><code>GenericTokenParser</code>是一个通用的占位符解析器，其字段的含义如下：</p><pre><code class="java">/**   * 占位符的开始标记   */  private final String openToken;  /**   * 占位符的结束标记   */  private final String closeToken;  /**   * {@link TokenHandler}接口的实现会按照一定的逻辑解析占位符   */  private final TokenHandler handler;</code></pre><p><code>GenericTokenParser.parse()</code>方法的逻辑并不复杂，它会顺序查找<code>openToken</code>和<code>closeToken</code>，解析得到的占位符的字面值，并将其交给<code>TokenHandler</code>处理，然后将解析结果重新拼装成字符串并返回。该方法的实现如下：</p><pre><code class="java">/**   * 此方法的逻辑并不复杂，它会顺序查找{@link #openToken}和{@link #closeToken} ，解析得到占位符的字面值，   * 将将其交给{@link TokenHandler}进行处理，然后将解析结果重新拼装成字符串并返回。   * @param text  拼装之前的字符串   * @return 拼装之后后字符串   */  public String parse(String text) {    //检测text是否为空    if (text == null || text.isEmpty()) {      return &quot;&quot;;    }    // search open token    // 查找开始标记    int start = text.indexOf(openToken);    // 检测start是否为-1    if (start == -1) {      return text;    }    char[] src = text.toCharArray();    int offset = 0;    // builder是用来记录解析后的字符串    final StringBuilder builder = new StringBuilder();    StringBuilder expression = null;    while (start &gt; -1) {      if (start &gt; 0 &amp;&amp; src[start - 1] == &#39;\\&#39;) {        // this open token is escaped. remove the backslash and continue.        // 遇到转移的开始标记，则直接将前面的字符串以及开始标记追加到builder中        builder.append(src, offset, start - offset - 1).append(openToken);        offset = start + openToken.length();      } else {        // found open token. let&#39;s search close token.        // 查找到开始标记，且未转义        if (expression == null) {          expression = new StringBuilder();        } else {          expression.setLength(0);        }        // 将前面的字符串追加到builder中        builder.append(src, offset, start - offset);        offset = start + openToken.length();        // 从offset向后继续查找结束标记        int end = text.indexOf(closeToken, offset);        while (end &gt; -1) {          // 处理转义的结束标记          if (end &gt; offset &amp;&amp; src[end - 1] == &#39;\\&#39;) {            // this close token is escaped. remove the backslash and continue.            expression.append(src, offset, end - offset - 1).append(closeToken);            offset = end + closeToken.length();            end = text.indexOf(closeToken, offset);          } else {            // 将开始标记和结束标记之间的字符串追加到expression中保存            expression.append(src, offset, end - offset);            break;          }        }        //未找到结束标记        if (end == -1) {          // close token was not found.          builder.append(src, start, src.length - start);          offset = src.length;        } else {          //将占位符的字面值交给TokenHandler处理，并将处理结果追加到builder中保存          //最终拼凑出解析后的完整内容          builder.append(handler.handleToken(expression.toString()));          offset = end + closeToken.length();        }      }      //移动start      start = text.indexOf(openToken, offset);    }    if (offset &lt; src.length) {      builder.append(src, offset, src.length - offset);    }    return builder.toString();  }</code></pre><p>占位符有<code>TokenHandler</code>接口的实现进行解析，<code>TokenHandler</code>接口总共有四个实现，如下图所示：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191125231024-cKlwtn.png" srcset="undefined" alt=""></p><p>通过对<code>PropertyParser.parse()</code>方法的介绍，我们知道了<code>PropertyParser</code>是使用<code>VariableTokenHandler</code>与<code>GenericTokenParser</code>配合完成占位符解析的，<code>VariableTokenHandler</code>是<code>PropertyReslover</code>中的一个私有静态内部类，其字段的含义如下所示：</p><pre><code class="java"> /**     * &lt;properties&gt;&lt;properties/&gt;节点下定义的键值对，用于替换占位符     */    private final Properties variables;    /**     * 是否支持占位符中使用默认值的功能     */    private final boolean enableDefaultValue;    /**     * 指定占位符和默认值之间的分隔符     */    private final String defaultValueSeparator;</code></pre><p><code>VariableTokenHandler</code>实现了<code>TokenHandler</code>接口中的<code>handlerToken()</code>方法，该实现首先会按照<code>defaultValueSeparator</code>字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值，然后按照切分得到的占位符名称查找对应的值，如果在<code>&lt;properties&gt;</code>节点下未定义相应的键值对，则将切分得到的默认值作为解析结果返回。</p><pre><code class="java">/**     * 实现了{@link TokenHandler}接口中的{@link TokenHandler#handleToken(String)}方法，该实现：     *  1. 首先会按照{@link #defaultValueSeparator}字段指定的分隔符对整个占位符切分，得到占位符的名称和默认值；     *  2. 然后按照切分得到的占位符名称查找对应的值，如果在&lt;properties&gt;&lt;properties/&gt;节点中未定义对应的键值对，     *     则将切分得到的默认值作为解析结果返回。     * @param content     * @return     */    @Override    public String handleToken(String content) {      // 检测variable集合是否为空      if (variables != null) {        String key = content;        //检测是否支持占位符中使用默认值的功能        if (enableDefaultValue) {          // 查找分隔符          final int separatorIndex = content.indexOf(defaultValueSeparator);          String defaultValue = null;          if (separatorIndex &gt;= 0) {            //获取分隔符名称            key = content.substring(0, separatorIndex);            //获取默认值            defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());          }          if (defaultValue != null) {            //在variables集合中查找指定的占位符            return variables.getProperty(key, defaultValue);          }        }        // 不支持默认值的功能，则直接查找variables集合        if (variables.containsKey(key)) {          return variables.getProperty(key);        }      }      //variables集合为空，直接返回      return &quot;${&quot; + content + &quot;}&quot;;    }  }</code></pre><p><code>GenericTokenParser</code>此类不仅用于默认值解析<code>PropertyParser#parse(String, Properties)</code>，还会在动态<code>SQL</code>语句的解析中用到。很明显，<code>GenericTokenParser</code>只是查找到指定的占位符，而具体的解析行为会根据持有的TokenHandler实现的不同而不同，这有点策略模式的意思。<br />回到对<code>XPathParser</code>的分析，<code>XPathParser.evalNode()</code>方法返回值类型是XNode，它对<code>org.w3c.dom.Node</code>对象做了封装和解析，其各个字段的含义如下：</p><pre><code class="java">  /**   * org.w3c.dom.Node对象   */  private final Node node;  /**   * Node节点名称   */  private final String name;  /**   * Node节点内容   */  private final String body;  /**   * 节点属性集合   */  private final Properties attributes;  /**   * mybatis-config.xml配置文件中&lt;properties&gt;&lt;properties/&gt;节点下定义的键值对   */  private final Properties variables;  /**   * XPathParser对象，该Node对象由此XPathParser对象生成   */  private final XPathParser xpathParser;</code></pre><p><code>XNode</code>的构造函数中会调用其<code>parseAttributes()</code>方法和<code>parseBody()</code>方法解析<code>org.w3c.dom.Node</code>对象中的信息，初始化<code>attributes</code>集合和<code>body</code>字段，具体初始化过程如下：</p><pre><code class="java">/**   * 解析Node对象中的Attributes属性集合   * @param n 节点对象   * @return   */  private Properties parseAttributes(Node n) {    Properties attributes = new Properties();    //获取节点的属性结合    NamedNodeMap attributeNodes = n.getAttributes();    if (attributeNodes != null) {      for (int i = 0; i &lt; attributeNodes.getLength(); i++) {        Node attribute = attributeNodes.item(i);        //使用PropertyParser处理每一个属性中的占位符        String value = PropertyParser.parse(attribute.getNodeValue(), variables);        attributes.put(attribute.getNodeName(), value);      }    }    return attributes;  }/**   * 解析Node对象中的信息body字段   * @param node   * @return   */  private String parseBody(Node node) {    String data = getBodyData(node);    //当前节点不是文本节点    if (data == null) {       //处理子节点      NodeList children = node.getChildNodes();      for (int i = 0; i &lt; children.getLength(); i++) {        Node child = children.item(i);        data = getBodyData(child);        if (data != null) {          break;        }      }    }    return data;  }  private String getBodyData(Node child) {    //只处理文本内容    if (child.getNodeType() == Node.CDATA_SECTION_NODE        || child.getNodeType() == Node.TEXT_NODE) {      String data = ((CharacterData) child).getData();      //使用PropertyParser处理文本节点中的占位符      data = PropertyParser.parse(data, variables);      return data;    }    return null;  }</code></pre><p>XPathParser测试用例</p><pre><code class="java">import org.apache.ibatis.builder.xml.XMLMapperEntityResolver;import org.apache.ibatis.io.Resources;import org.apache.ibatis.parsing.XNode;import org.apache.ibatis.parsing.XPathParser;import java.io.IOException;import java.util.List;/** * @author : &lt;a href=&quot;mailto:gnehcgnaw@gmail.com&quot;&gt;gnehcgnaw&lt;/a&gt; * @since : 2019/11/25 16:11 */public class XPathParserTest {  public static void main(String[] args) throws IOException {    String resource = &quot;resources/xpath-demo.xml&quot;;    XPathParser xPathParser = new XPathParser(Resources.getResourceAsReader(resource),true,null,new XMLMapperEntityResolver());    XNode xNode = xPathParser.evalNode(&quot;/configuration&quot;);    List&lt;XNode&gt; children = xNode.getChildren();    for (int i = 0; i &lt; children.size(); i++) {      System.out.println(children.get(i).getName());    }  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Mybatis源码分析</category>
      
      <category>基础支持层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2保存密码登录</title>
    <link href="undefinedMac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html"/>
    <url>Mac%E6%8A%80%E5%B7%A7/iterm2%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95.html</url>
    
    <content type="html"><![CDATA[<h1 id="iterm2保存密码登录"><a href="#iterm2保存密码登录" class="headerlink" title="iterm2保存密码登录"></a>iterm2保存密码登录</h1><h2 id="1-编写item2login-sh脚本文件"><a href="#1-编写item2login-sh脚本文件" class="headerlink" title="1. 编写item2login.sh脚本文件"></a>1. 编写<code>item2login.sh</code>脚本文件</h2><pre><code class="shell">#!/usr/bin/expect  set timeout 30  spawn ssh -p [lindex $argv 0] [lindex $argv 1]@[lindex $argv 2]  expect {         &quot;(yes/no)?&quot;         {send &quot;yes\n&quot;;exp_continue}         &quot;password:&quot;         {send &quot;[lindex $argv 3]\n&quot;}  }  interact </code></pre><ul><li><p>lindex $argv 0 : port</p></li><li><p>lindex $argv 1：username</p></li><li><p>lindex $argv 2：IP</p></li><li><p>lindex $argv 3：password</p></li></ul><h2 id="2-修改item2login-sh权限"><a href="#2-修改item2login-sh权限" class="headerlink" title="2. 修改item2login.sh权限"></a>2. 修改<code>item2login.sh</code>权限</h2><p>将<code>item2login.sh</code>移动到<code>/usr/local/bin</code>目录下，然后使用<code>chmod 777 item2login.sh</code>修改脚本权限；</p><h2 id="3-在iterm2中添加信息"><a href="#3-在iterm2中添加信息" class="headerlink" title="3. 在iterm2中添加信息"></a>3. 在iterm2中添加信息</h2><p>打开iterm2的<code>Profiles</code>–&gt;<code>Open Profiles...</code>–&gt;<code>Edit Profiles...</code>–&gt;<code>+</code></p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204208-mTkAoN.png" srcset="undefined" alt=""></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>然后就可以选取要登录的服务器了，效果如下所示（因为是测试服务所以没有连接）：</p><p><img src="https://raw.githubusercontent.com/gnehcgnaw/gnehcgnaw.github.io/imgs/uploads/20191115204211-HHVeUW.png" srcset="undefined" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Mac技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>